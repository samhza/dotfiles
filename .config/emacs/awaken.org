#+TITLE: Wake Up Snorlax!
#+AUTHOR: noctuid
#+TODO: TODO(t) IN-PROGRESS(p) WAITING(w) | DONE(d) CANCELED(c)

# [[./todo.org]]

# I'm using ~org-sort-entries~ (with =a=) for sorting many subheadings.

* Initial Notes
** Org Configuration
I moved my Emacs init file to org after becoming comfortable enough with evil to use Emacs instead of vim for editing my init file. The initial reason I switched to org was to be able to use org's outline syntax instead of marker folds (={{{...}}}=). The main reasons I haven't switched back are because I prefer writing notes using org's markup and soft-wrapping over using comments and hard-wrapping. Also, org's extra features and packages like [[https://github.com/abo-abo/worf][worf]] make org very convenient and powerful, and I like being able to easily export to other formats.

That said, using an org init file has a lot of downsides as well. Input lag can be an issue for larger org files depending on the enabled minor modes, having to first open a new buffer to edit an elisp source block can be annoying, and ~org-babel-load-file~ is very slow and requires loading org mode. Also, org's outline syntax can easily be used in non-org files, so that is not a unique feature of an org configuration.

There are ways to mitigate these issues though. After disabling some minor modes (mainly =git-gutter-mode=), input lag is not an issue for me. Using ~polymode~ allows editing elisp directly in the same buffer. Previously, ~polymode~ was completely unusable for me in large files because moving the point into a code block froze Emacs for a couple of seconds. A lot of work has gone into polymode, and speed is no longer an issue (thank you @vspinu), but my polymode config still needs work. On the other hand, ~org-edit-special~ may be desirable as a form of narrowing. Finally, slow tangling can be dealt with either by tangling (asynchronously) after startup or by [[http://www.holgerschurig.de/en/emacs-efficiently-untangling-elisp/][using a custom tangling function]]. Both of these solutions don't require loading org during startup.

** Changes From Default Evil/Vim Keybindings
As great as vim's default keybindings are, they aren't tailored towards my most commonly used actions/commands, and I don't use QWERTY, so I change a lot of them. Some of these are common swaps (e.g. =;= as =:=), but a lot of these changes are more opinionated.

*** Basic Swaps/Changes
- line movement keys swapped (e.g. swapping default =j= and =gj=)
- =Y= consistent with =D= (see ~evil-want-Y-yank-to-eol~)
- =a= and =A= swapped
- =;= instead of =:=
- =:= as ~eval-expression~ (default =;= moved to =r= prefix)
- =/= as a swiper command (default =/= moved to =r= prefix)
- =RET= for following (e.g. links or jumping to definitions like =M-.= or vim's =C-]=) and for confirmation/finalization (e.g. finalizing org capture, finalizing git commit, exiting org source mode buffer, etc.)

*** Colemak Swaps/Changes
- =hnei= instead of =hjkl= (for text editing, only =ne= are used)
- default =n= and =N= to =k= and =K=
- default =K= to =N=
- default =e= to =j=
- =H= for "jump to beginning" commands (e.g. beginning of heading or function)
- =l= as =C-o= and =L= as =C-i=; =i= is kept for entering insert state

The default =J= (join) and (particularly) =K= (doc lookup) are useful in vim; so I keep their functionality. I don't use the default =H= or =L= (which swap/move windows) at all, so I remap them to more useful commands.
I find =C-o= (~evil-jump-backward~) to be a command that deserves a better position, so I rebind =l= to it (mnemonic "[l]ast") instead of using =l= for insertion, which is a common Colemak change. For symmetry, I also remove =h=, so =hi= do not perform horizontal movement. The vertical movement keybindings are useful enough for me to keep, especially when using relative line numbers. I use a modifier with =h= and =i= if I need horizontal movement (navigation layer; not part of Emacs config). In modes where insertion doesn't make sense and horizontal movement is more useful (e.g. =mu4e= and =dired=), I keep =hnei=.

Although I now use Colemak-DH (where =m= is in the QWERTY =h= position), I still use =h= as "left." This is partially because all my configuration files already used =h= before I switchedB. ecause the idea of Colemak-DH is to move =h= to a better location, I don't think any changes are necessary.

*** Standard Prefixes
These are global prefixes that are sometimes bound in =general-override-mode-map= (whose evil auxiliary keymaps are evil intercept keymaps). =m= and =,= do not need to be bound globally since they are specific to the current major mode and group respectively. Keys like =r= that may not be useful in every major mode are not bound in an evil intercept map either. =SPC= and =t= are the main keys that are bound in evil intercept maps, so that their functionality will always be available.

Having a lot of prefixes helps to keep the number of keypresses required for a command at around two for the most common commands. I've remapped my least used vim letter keys as prefixes (which conveniently happen to also be home row keys for Colemak). =s= and =r= are probably the least generic/useful default vim keys. The default =s= and =S= are equivalent to =cl= and =cc=. They aren't useful enough to me to deserve dedicated keys. The same is true for =r= (~evil-replace~), and I don't use =R= (~evil-replace-state~) at all. I use =x= occasionally (e.g. =xp= is convenient for swapping characters), so I keep it. I never use =X=, but it's not in a good enough position for me to want to repurpose it. On the other hand, =SPC= is generally the best position on the keyboard and doesn't have a unique keybinding either (same as =l=), so its one of my most used prefix keys.

The more "controversial" keys I use as prefixes are =m=, =h=, =t=, and =T=. I used ='= a lot more than =m= in vim and didn't use =m= at all until recently in Emacs (you can persist markers, but you have to use =desktop-mode= or extract the code to do it yourself). I don't use =M= at all (~evil-window-middle~, which moves the point to the middle of the window), so I move ~evil-set-marker~ to =M= and use =m= as a prefix. As for =t=, =T=, =f=, and =F=, I prefer to use a two-char search command that will search across lines and allow selection with avy when there is more than one match (like =vim-sneak= or =vim-easymotion=). I bind these commands to =f= and =F= and use =t= as a prefix key as I can just change the characters I search for if I want to go to the character before some other character.

- =SPC=: for buffer/file/group navigation/management
- =,=: for "quickmarked" files/applications for the current group
- =r=: for "[r]emote" movement and for "[r]emoved" (or "[r]emapped") keys
  - used for remote motions (motions using avy; also used for remote text objects in =evil-(inner|outer)-text-objects-map=)
  - used for preserving some clobbered keys (e.g. the default =;=, =,=, and =/= are now prefixed with =r=)
- =s=: for "[s]tarting" applications (mu4e, elfeed, mingus, woman, proced, calc, etc.) and for "[s]traight" commands (on =ss= currently)
- =t=: previously my "leader" key in vim
  - window navigation/management
  - other general-purpose commonly used commands (e.g. ~link-hint-open-link~)
- =T=: used for one-off "gi[t]" commands (previously on =tg=; haven't completely switched over yet)
- =h=: bound to ~help-command~
- =m=: used for "[m]ajor [m]ode" specific keybindings (e.g. org commands)
- =tt=: used to "[t]oggle" options and minor modes (previously I was using =co=, but I didn't want =c= to be a prefix everywhere)

** Configuration Principles
My configuration may not meet these requirements at this point in time, but these are the goals.

- Speed (nice but not a primary goal)
  - Aggressively use autoloads and ~with-eval-after-load~ for configuration to cut down on startup time when it makes sense. Previously I had a lot of ~use-package~ statements with =:defer <time>=. I avoid this now unless I think it's unlikely I need to use a package immediately and there's no better way to autoload it. For packages that don't make sense to load with keybindings I have often copied what doom does with some minor modifications. Example differences: I am using the =evil-(operator|visual)-state-entry-hook= hooks for loading packages that just provide text objects, I'm using =evil-insert-state-entry-hook= with read-only/major mode type checks for loading some packages, I'm using a hook for when I run a keybinding to switch the scratch buffer to Emacs lisp mode, etc.). I'm also using doom's :defer-incrementally for larger packages (org, lispy, magit, etc.). :defer-incrementally helps prevent large pauses especially if you start the daemon before creating a client.
  - Configuration should work when using the daemon (e.g. some functionality that relies on GUI Emacs needs to be run later). When using the daemon, startup time isn't as important, but it should still be fast. I try to keep ~emacs-init-time~ at <0.6 seconds (when I started using Emacs, I was requiring everything during initialization, and startup could take 20-60 seconds on my old laptop). Probably I could get things to look faster if I load after init (though that will require some changes).
  - Use profiling to diagnose performance issues during and after startup.
  - Benchmark with a combination of benchmark-init, profile-dotemacs, and tracking where packages are required for debugging (see custom init.el flags)
- Intelligent handling of errors in init file
  - Localize recoverable errors and convert them to warnings whenever possible (e.g. if a package fails to install, warn and don't run its configuration). This means wrapping anything that requires a package to be loaded in a ~with-eval-after-load~ (usually via ~use-package~ or ~general-with-package~).
  - Isolate sections (source blocks) where possible, so that one section failing will not affect other sections. When there is some non-recoverable error somewhere in my init (e.g. ~(call-to-misspelled-function)~), I can start Emacs with =--with-demoted-errors= (flag I'm handling in =./init.el=) to demote errors for every source block. This means that I can still use Emacs with most of my configuration to fix my init file without needing to switch to a stable configuration or a different editor.
  - Use a stable init file for errors that break everything (e.g. missing/extra parens). I'm automatically saving my configuration when it successfully loads with a =-stable.el= suffix, and I can load this configuration by specifying =--stable=. As for package breakage, straight can handle locking versions/commits (next bullet).
  - Use ~straight-freeze-versions~ to be able to recover with ~straight-thaw-versions~ if package updates break things.
  - Don't assume that any packages besides the core packages (e.g. =straight=, =use-package=, =general=, and =evil=) have been loaded. Sections should otherwise be independent and reorderable.
  - Conditionally load non-portable functionality to prevent errors when using on other computers. Don't rely on unpushed functionality in personal packages (I was really bad about this in the past).
- Idempotency
  - Make configuration idempotent, so that any part can be run again without issues. It isn't as important to be able to reload the whole file in Emacs as it is for other software since it's more normal to just incrementally eval whatever you're working on.
- Short/Sane/Consistent Keybindings
  - As mentioned in the previous section, I prefer to have a lot of prefix keys to keep keybindings shorter.
  - I need to work on keybinding consistency (=m= keybindings are slightly different between programming modes). I plan to use and contribute to =evil-collection= more in the future to do this.
- Readability/Editabilty
  - Document issues and the purpose of any code that might not be immediately clear later. All non-trivial functions should have docstrings.
  - Use one big org file for fast/easy navigation.

I have some more package-specific guidelines listed in the use-package, straight.el, and general.el sections below.

** Style Guidelines
- Sharp quote all functions (including commands in keybindings).
- Don't enable minor modes with a =+1= argument (any argument is unnecessary when ~define-minor-mode~ is used; the mode is only toggled when the command is called interactively; this means that it is not necessary to use a lambda or named function to enable a minor mode with ~add-hook~).
- Generally try to follow these [[https://github.com/bbatsov/emacs-lisp-style-guide][Emacs Lisp Style Guidelines]].

* Utilities/Helper Packages and Basic Setup
** CL Lib
Used throughout configuration.
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src

** Helpers
*** General
#+begin_src emacs-lisp
(defconst noct-lisp-mode-hooks
  '(emacs-lisp-mode-hook
    eshell-mode-hook
    fennel-mode-hook
    ielm-mode-hook
    scheme-mode-hook
    sly-mrepl-mode-hook
    clojure-mode-hook
    lisp-mode-hook)
  "List of hooks for all used lisp modes.")

(defconst noct-minibuffer-maps
  '(minibuffer-local-map
    minibuffer-local-ns-map
    minibuffer-local-completion-map
    minibuffer-local-must-match-map
    minibuffer-local-isearch-map
    evil-ex-completion-map)
  "List of minibuffer keymaps.")

(defconst noct-self-insert-commands
  '(self-insert-command
    org-self-insert-command
    LaTeX-insert-left-brace
    outshine-self-insert-command
    lispy-space)
  "List of self-insert commands.")

(defun noct-blog-dir-p (file)
  "Return whether the current file is in my blog post directory."
  (file-in-directory-p
   file
   (expand-file-name "content-org" (getenv "BLOG"))))

(defun noct-kill-this-buffer ()
  "`kill-this-buffer' with no menu-bar checks.
`kill-this-buffer' is supposed to be called from the menu bar.
See https://www.reddit.com/r/emacs/comments/64xb3q/killthisbuffer_sometimes_just_stops_working/."
  (interactive)
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer))))

(defun noct-inhibit-message-advice (oldfun &rest args)
  "Apply OLDFUN to ARGS with `inhibit-message' non-nil."
  (let ((inhibit-message t))
    (apply oldfun args)))

(defun noct-no-message (orig-fun &rest args)
  "Apply ORIG-FUN to ARGS with `message' overriden as `ignore'."
  (cl-letf (((symbol-function 'message) #'ignore))
    (apply orig-fun args)))

;; TODO as good as `quiet!'
(defmacro noct-silently (&rest body)
  (declare (indent 0) (debug t))
  `(let ((inhibit-message t)
         (save-silently t))
     (cl-letf (((symbol-function 'message) #'ignore))
       ,@body)))

(defun noct-silence-advice (oldfun &rest args)
  (noct-silently
    (apply oldfun args)))

(defun noct-inhibit-error-advice (oldfunc &rest args)
  "Run OLDFUN with ARGS, demoting errors to warnings.
Unlike with `with-demoted-errors', do this regardless of the value of
`debug-on-error'."
  (let (debug-on-error)
    (condition-case err
        (apply oldfunc args)
      (error
       (display-warning 'noct-error (format "Demoted error: %S" err))
       nil))))

(cl-defun noct-basename (&optional (file (buffer-file-name)))
  "Return the basename of FILE."
  (file-name-sans-extension (file-name-nondirectory file)))

;; TODO simplest way to evaluate /parts/ of a variable once only
(defmacro noct-letenv (env-binds &rest body)
  "Bind ENV-BINDS temporarily while running BODY.
Restore the old values for all specified environment variables after running
BODY (even on failure)."
  (declare (indent 1) (debug let))
  (let ((original-env (cl-gensym)))
    `(let ((,original-env
            (list ,@(mapcar (lambda (bind)
                              `(cons ,(car bind) (getenv ,(car bind))))
                            env-binds))))
       (unwind-protect
           (progn
             ,@(mapcar (lambda (bind)
                         `(setenv ,(car bind) ,(cadr bind)))
                       env-binds)
             ,@body)
         ,@(mapcar (lambda (bind)
                     `(setenv ,(car bind)
                              (alist-get ,(car bind)
                                         ,original-env
                                         nil
                                         nil
                                         #'equal)))
                   env-binds)))))

;; TODO use something more sophisticated?
;; alternatively, username check alone should be enough
(defconst noct-personal-computer-p
  (and (string= (user-login-name) "noctuid")
       (file-directory-p "~/ag-sys")))

(defmacro noct-with-q-to-exit (&rest body)
  `(progn ,@body
          (general-def 'normal 'local "q" #'delete-frame)))

(defun noct-bind-q-to-quit ()
  "Bind q to `quit-window' in the current buffer."
  (general-def 'normal 'local "q" #'quit-window))

(defmacro noct-disable-global-mode (mode)
  "Return a function that disables a global minor mode for the current buffer.
This works by adding to `after-change-major-mode-hook' locally to disable the
mode. Doing something like (add-hook 'major-mode-hook (lambda () (mode -1)))
will not work because global minor modes enable minor modes after major mode
hooks run."
  `(lambda ()
     (general-add-hook 'after-change-major-mode-hook
                       (lambda () (,mode -1))
                       t
                       t)))


(defmacro noct-run-at-active-interval (interval idle-interval &rest body)
  "Every INTERVAL seconds, unless idle for > IDLE-INTERVAL seconds, run BODY.
Also, after IDLE-INTERVAL seconds of idle time, run BODY. This allows using an
idle timer to quickly run BODY when Emacs becomes idle but also ensures that
BODY is run periodically even if Emacs is actively being used."
  (declare (indent 2))
  `(progn
     (run-at-time (current-time) ,interval
                  (lambda ()
                    (let* ((idle-time (current-idle-time))
                           (idle-secs (when idle-time
                                        (float-time idle-time))))
                      (unless (and idle-secs
                                   (> idle-secs ,idle-interval))
                        ,@body))))
     (run-with-idle-timer ,idle-interval t (lambda () ,@body))))

(defmacro noct-defun (name arglist &optional docstring &rest body)
  "`defun' but guaranteed return the created function."
  (declare (doc-string 3) (indent 2))
  `(progn (defun ,name ,arglist ,docstring ,@body)
          #',name))

(defmacro noct-c (&rest body)
  "Like `general-lambda' but create named function based on BODY.
Strip out parens and replace spaces/newlines with - to make the name more
readable."
  (declare (indent defun))
  ;; generally don't like overuse threading macros, but this seems like the
  ;; place to use
  ;; makes flycheck unhappy though
  (let ((name (thread-last body
                (format "%s")
                (replace-regexp-in-string "[()]" "")
                (replace-regexp-in-string (rx (or space "\n")) "-")
                (intern))))
    `(noct-defun ,name ()
       (interactive)
       ,@body)))

(defmacro noct-disable (mode)
  "Return a named function that disables MODE."
  (let ((name (intern (format "noct-disable-%s" mode))))
    `(noct-defun ,name (&rest _)
       ,(format "Disable %s." mode)
       (,mode -1))))

(defun noct-undo-a (orig-fun &rest args)
  "Wrap a call to ORIG-FUN with ARGS in `evil-with-undo'."
  (evil-with-undo
    (apply orig-fun args)))

(defun noct-add-undo-bounds (command)
  "Advise COMMAND to be wrapped in `evil-with-undo'."
  (general-after 'evil
    (general-add-advice command :around #'noct-undo-a)))
#+end_src

*** GUI Related
#+begin_src emacs-lisp
;; TODO handling minor modes that should only be enabled for GUI frames is
;; difficult; previously, I was toggling modes using `focus-in-hook' (now
;; obsolete), and it didn't work well
;; TODO for daemon, probably would be better to run once and add to
;; `server-after-make-frame-hook'
;; (defmacro noct-if-gui-p (then else &optional once)
;;   "Every time a frame is created, run THEN if it is a GUI frame.
;; Otherwise run ELSE. If ONCE is non-nil, only run THEN or ELSE the first time a
;; frame is created."
;;   (declare (indent 1)))
;; NOTE it seems the best way to handle this is for the minor mode itself to
;; take care of it by dynamically checking `display-graphic-p' like ivy-posframe
;; now does

(defmacro noct-after-gui (&rest body)
  "Run BODY once after the first GUI frame is created."
  (declare (indent 0) (debug t))
  `(if (display-graphic-p)
       (progn ,@body)
     (general-add-hook 'server-after-make-frame-hook
                       (lambda () ,@body)
                       nil
                       nil
                       t)))

;; NOTE these only work for GUI
(defun noct-default-monitor-geometry ()
  "Return geometry for the first monitor in `display-monitor-attributes-list'."
  (let* ((first-monitor (car (display-monitor-attributes-list))))
    (alist-get 'geometry first-monitor)))

(defun noct-default-monitor-width ()
  "Return the width of the first monitor in `display-monitor-attributes-list'."
  (nth 2 (noct-default-monitor-geometry)))

(defun noct-default-monitor-height ()
  "Return the height of the first monitor in `display-monitor-attributes-list'."
  (nth 3 (noct-default-monitor-geometry)))

(defun noct-border-width ()
  "Return the width to use for borders.
Uses 4 pixels FHD and 8 on 4k."
  (round (* 0.00208333333 (noct-default-monitor-width))))

(defun noct-posframe-poshandler-frame-near-top-center (info)
  "Handler to display posframe centered near the top."
  (cons (/ (- (plist-get info :parent-frame-width)
              (plist-get info :posframe-width))
           2)
        (round (* 0.02 (noct-default-monitor-height)))))
#+end_src

*** TODO Popup Handling and =display-buffer-alist=
Generally, I have one or two "main" windows open at a time (split horizontally). I like to display "popups" at the top (e.g. help mode windows, magit buffers, etc.). Previously, I used shackle, but for such a simple setup, it's easy enough to use =display-buffer-alist= directly.

**** Popup Helpers
#+begin_src emacs-lisp
;; https://web.archive.org/web/20160409014815/https://www.lunaryorn.com/2015/04/29/the-power-of-display-buffer-alist.html
(defmacro noct-match-major-mode (mode)
  "Create a function that returns whether the current `major-mode' is MODE."
  (let ((name (intern (format "noct-match-%s" mode))))
    `(progn
       (defun ,name (buffer-or-name _action)
         (ignore-errors
           (let ((buffer (get-buffer buffer-or-name)))
             (eq ',mode (buffer-local-value 'major-mode buffer)))))
       #',name)))

(defun noct-display-and-select-buffer (func buffer alist)
  "Call FUNC with BUFFER and ALIST.
Select the window afterwards if possible. This is modified from
`shackle--display-buffer-reuse'. Additionally set the window to be fixed size."
  (let ((window (funcall func buffer alist)))
    (when (and window (window-live-p window))
      (select-window window t))
    ;; TODO this breaks slots; doesn't work for non-side windows
    ;; (with-current-buffer buffer
    ;;   (setq window-size-fixed t))
    window))

(defun noct-display-buffer-reuse-window (buffer alist)
  "Call `display-buffer-reuse-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-reuse-window buffer alist))

(defun noct-display-buffer-in-side-window (buffer alist)
  "Call `display-buffer-in-side-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-in-side-window buffer alist))

(defun noct-display-buffer-in-side-window-no-header (buffer alist)
  "`noct-display-buffer-in-side-window' but don't have a header line.
Having a header line in some buffers will cause text to be cut off at the
bottom (e.g. transient and frog menu)."
  (noct-display-buffer-in-side-window buffer alist)
  (setf (buffer-local-value 'header-line-format buffer) nil))

(defun noct-display-buffer-same-window (buffer alist)
  "Call `display-buffer-same-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-same-window buffer alist))

(defun shackle--split-some-window (frame alist)
  "Return a window if splitting any window was successful.
This function tries using the largest window on FRAME for
splitting, if all windows are the same size, the selected one is
taken, in case this fails, the least recently used window is used
for splitting.  ALIST is passed to `window--try-to-split-window'
internally."
  (or (window--try-to-split-window (get-largest-window frame t) alist)
      (window--try-to-split-window (get-lru-window frame t) alist)))

(defun shackle--display-buffer-popup-window (buffer alist)
  "Display BUFFER in a popped up window.
This is a stripped down version of `shackle--display-buffer-popup-window'.
ALIST is passed to `shackle--window-display-buffer' internally.
If PLIST contains the :other key with t as value, reuse the next
available window if possible."
  (let ((window (if (not (one-window-p))
                    (next-window nil 'nominibuf)
                  (shackle--split-some-window (selected-frame) alist))))
    (window--display-buffer buffer window 'window alist)))

(defun noct-display-buffer-creating-other-window (buffer alist)
  "Call `display-buffer-in-other-window' with BUFFER and ALIST.
If another window does not exist, create it. Select the window afterwards if
possible."
  (noct-display-and-select-buffer #'shackle--display-buffer-popup-window
                                  buffer alist))

(defmacro noct-handle-window (condition &rest body)
  "Display windows matching CONDITION with the settings in BODY."
  (declare (indent 1) (debug t))
  (let ((condition (if (and (symbolp condition)
                            (string-match "-mode$" (symbol-name condition)))
                       `(noct-match-major-mode ,condition)
                     condition)))
    `(cl-pushnew
      (list ,condition ,@body)
      display-buffer-alist
      :test 'equal)))

(defmacro noct-handle-popup (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-in-side-window)
     '(side . top)
     '(slot . ,slot)
     '(window-height . 0.5)))

(defmacro noct-handle-popup-no-header (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
Remove the header line. This handles some buffers where text would be cut off
when there is a header line. When SLOT is non-nil, display popup buffers in that
SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-in-side-window-no-header)
     '(side . top)
     '(slot . ,slot)
     '(window-height . 0.5)))

(defmacro noct-handle-popup-same-window (condition)
  "Display popups matching CONDITION in the current window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-same-window)))

(defmacro noct-handle-popup-other-window (condition)
  "Display popups matching CONDITION in the other window.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-creating-other-window)))

(defmacro noct-handle-popup-other-window-no-select (condition)
  "Display popups matching CONDITION in the other window without selecting it.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     'shackle--display-buffer-popup-window))

(defun noct-side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))
#+end_src

**** Basic =display-buffer-alist= setup
#+begin_src emacs-lisp
(noct-handle-popup (rx "*Warnings*"))

(cl-pushnew
 (list (rx "*Async Shell Command*" (0+ any)) #'display-buffer-no-window)
 display-buffer-alist)
#+end_src

*** Email Info and Variables
#+begin_src emacs-lisp
(when (locate-library "noct-info")
  (require 'noct-info))
#+end_src

*** Debugging
Useful for debugging selectrum or ivy.
#+begin_src emacs-lisp
;; https://github.com/raxod502/prescient.el/issues/56#issuecomment-614094583
(defun raxod502-force-debug (func &rest args)
  (condition-case e
      (apply func args)
    ((debug error) (signal (car e) (cdr e)))))

;; for example
;; (general-add-advice 'ivy--exhibit :around #'raxod502-force-debug)
#+end_src

*** Custom Declares
See [[https://old.reddit.com/r/emacs/comments/gi70ye/weekly_tipstricketc_thread/fqg7qys/][here]]. Can't currently think of a good use case but will probably use at some point.

** =package.el=
Currently, I only use =package.el= if I want to use the package list buffer. I generally don't use it for installing anything.
#+begin_src emacs-lisp
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))
#+end_src

** =straight.el= and =use-package.el=
When I first tried Emacs, I thought the idea of using centralized package repositories was interesting but was annoyed when packages I wanted to use weren't (yet) in any package archive. Alternatives like =el-get= and =quelpa= weren't quite what I wanted. =straight.el= is nice in that it fully replaces =package.el= for me while still making use of recipes from elpa, melpa, and emacsmirror. This means that while you can specify your own recipe, it's usually not necessary.

I use straight to compile/autoload my personal local packages (=straight.el= makes this easy since they are treated the same way as other packages). I also occasionally use it to contribute to packages (by directly working with the downloaded repo). Even if I didn't use it for development, having the git repos available locally is useful for many reasons. It's great to have READMEs and other files available locally, to be able to use git blame, and to be able to switch to or lock any commit.

Since ~setq~, ~add-hook~, and ~evil-define-key~ can all be used before the specified settings, hooks, and keymaps exist, I previously preferred to use them outside of ~use-package~. I didn't like nesting these inside of ~use-package~ especially for more complicated packages where my configuration is split across many headings. On the other hand, this can potentially affect startup time. I considered writing my configuration so that headings could be /optionally/ tangled into a previous =:config= section or to optionally tangle headings into a new ~with-eval-after-load~ call (specifically ~general-with-package~ provided by general.el). I decided this would be too convoluted/misleading and am now just using ~general-with-package~ manually. I've stopped being bothered with the nesting.

Here are the guidelines I follow for using ~use-package~ keywords and the order I use them in.

Package installation:
- =:straight= to specify recipes for custom or local packages

Package loading:
- =:disabled= for disabled packages (e.g. unused themes)
- =:if=, =:when=, and =:unless= for conditionally loading/configuring the package
- =:after= when it only makes sense to load one package after another (not used for "core" packages like =evil= that are loaded immediately) (usually not necessary)
- =:demand t= for packages that should be loaded immediately (e.g. =evil=)
- =:defer number= for packages whose functionality should be quickly available but is not necessary immediately (use sparingly)
- =:defer-incrementally= for packages with lots of dependencies (functionality from doom)
- =:ghook= to add to hooks that will later run and load the package
- =:mode= as a temporary solution for major modes that don't add to =auto-mode-alist=
- =:commands= as a temporary solution for packages that don't have autoload cookies
- =:general= for any keybindings meant to load the package (and not others; I use this keyword only to make it very clear how the package will be loaded)
- =:init= for any settings that need to be set before loading the package (e.g. =evil-want-keybinding=) and for function calls meant to load the package (e.g. enabling a global minor mode, setting another package's variable to a function from this package, etc.)

Note that using =:after= will put the rest of the non-installation configuration in an ~eval-after-load~ (including the =:init= section, the =(require package)= statement generated from =:demand t=, etc.). Also note that by default only =:init= can fail if the package isn't successfully installed (see ~use-package-check-before-init~); specifying =:demand=, for example, will cause an error if the package fails to install.

As a workaround, I'm setting a default value for =:when= in ~use-package-defaults~ (that is used even when =:when= is explicitly specified) to prevent package configuration if package installation fails. See [[https://github.com/jwiegley/use-package/issues/693][issue 693]] and [[https://github.com/jwiegley/use-package/issues/739][issue 739]].

Package configuration:
- =:blackout= (or =:diminish= or =:delight=) for diminishing minor mode names
- =:gfhook= for any setup configuration for a mode (e.g. set local variables or enable/disable minor modes)
- =:config= for any basic package setup; more complicated setup should go in specific subheadings

In the =:config= section, I generally put settings (~setq~ then any face configuration then ~add-hook~), then keybindings, then enabling any modes, and then any other configuration.

*** Straight
Install, load, and configure =straight.el=:
#+begin_src emacs-lisp
(setq straight-repository-branch "develop"
      ;; default
      straight-enable-use-package-integration t
      ;; check for modifications (to determine whether a package needs to be
      ;; rebuilt) using `after-save-hook' instead of during startup or always
      ;; rebuilding packages (https://github.com/raxod502/straight.el/issues/41)
      ;; drops loading straight from ~0.88s to ~0.05s for me; needs to be set
      ;; before loading straight
      straight-check-for-modifications '(check-on-save find-when-checking)
      ;; install packages by default (like use-package's `use-package-always-ensure')
      straight-use-package-by-default t
      ;; store all autoloads in one file; default t
      ;; doesn't significantly affect init time for me
      straight-cache-autoloads t
      ;; used for :fork so don't need to specify settings
      straight-host-usernames '((github . "noctuid")
                                (gitlab . "noctuid")))

;; Install and load straight.el
;; https://github.com/raxod502/straight.el#getting-started
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el"
                         user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  ;; (benchmark 1 `(load ,bootstrap-file nil 'nomessage))
  (load bootstrap-file nil 'nomessage))

(defvar noct-straight-packages nil
  "List of packages `straight-use-package' is successful for.")

(defun noct-straight-use-package (orig-fun &rest args)
  "Store a package in `noct-straight-packages' on success."
  (when (apply orig-fun args)
    (push (if (listp (car args))
              (caar args)
            (car args))
          noct-straight-packages)))
(advice-add 'straight-use-package :around #'noct-straight-use-package)
#+end_src

*** Use-package
Install =use-package.el= with optional dependencies and configure:
#+begin_src emacs-lisp
;; install use-package
(straight-use-package 'use-package)

;; don't require `use-package' when loading compiled file; saves a millisecond
;; or 2; compiling now saves ~0.1s overall (maybe another 0.1s after general
;; rewrite)
(eval-when-compile
  (require 'use-package)

  ;; don't actually need `eval-when-compile' for rest since currently loading
  ;; entire init file before compiling already
  (setq use-package-always-defer t)

  ;; don't do anything if installation fails; like
  ;; `use-package-check-before-init' but works for :config and other keywords;
  ;; recording `straight-use-package' return values instead of using
  ;; `locate-library' since it was adding an extra 0.15 seconds to init
  (cl-pushnew '(:when
                (lambda (package &rest _)
                  `(memq ',package noct-straight-packages))
                t)
              use-package-defaults
              :test #'equal))

;; demote installation errors to messages
;; this variable is no longer changed by straight
;; (advice-add use-package-ensure-function :around #'noct-use-package-ensure)
(when (bound-and-true-p noct-with-demoted-errors)
  (advice-add 'straight-use-package :around #'noct-inhibit-error-advice))
;; can test with something like this:
;; (use-package does-not-exist)

(use-package blackout
  :straight (blackout :host github :repo "raxod502/blackout")
  :demand t)
#+end_src

** Async Init Tangling
See =./init.el=. This is installed as a dependency by other packages, but I'm installing it here to be explicit.
#+begin_src emacs-lisp
(use-package async)
#+end_src

** =general.el=
Principles:
- Prefer using ~general-def~ or a more specific wrapper for all keybindings (more concise than ~define-key~, consistent interface to all keybindings, syntax is mostly interchangeable with builtin and evil definers, records keybindings, etc.).
- Prefer using general hook and setting wrappers (e.g. ~general-setq~ instead of ~setq~ and ~general-pushnew~ instead of ~cl-pushnew~ or ~add-to-list~; they allow recording settings/hooks and call ~defcustom~ :set functions unlike ~setq~).
- Use =:general= and =:ghook= keywords for keybindings and hooks meant to load packages.
- Use ~general-with-package~ instead of ~use-package~ if the ~use-package~ statement would only have =:config= and not install the package (like ~with-eval-after-load~ but allows automatically recording the package name with keybindings and settings). All general functions should appear in either a ~general-with-package~ or a ~use-package~ statement if there is a specific, corresponding package.
#+begin_src emacs-lisp
(use-package annalist
  :straight (annalist
             :protocol ssh
             :local-repo "~/src/emacs/annalist")
  :demand t
  :config
  (with-eval-after-load 'general
    (general-add-hook 'annalist-describe-hook #'noct-bind-q-to-quit)))

(use-package general
  :straight (general
             :protocol ssh
             :local-repo "~/src/emacs/general")
  :demand t)

(general-add-hook 'annalist-describe-hook
                  (lambda () (visual-fill-column-mode -1)))

(general-auto-unbind-keys)

(eval-and-compile
  (defalias 'gsetq #'general-setq)
  (defalias 'gsetq-local #'general-setq-local)
  (defalias 'gsetq-default #'general-setq-default))

;; NOTE may rename these based on purpose and do find and replace if ever decide
;; to change the keybindings
(general-create-definer general-spc
  :states 'normal
  :keymaps 'override
  :prefix "SPC")

(general-create-definer general-t
  :states 'normal
  :keymaps 'override
  :prefix "t")

(general-create-definer general-r
  :states 'motion
  :prefix "r")

(general-create-definer general-rr
  :states 'motion
  :prefix "rr")

(general-create-definer general-s
  :keymaps 'normal
  :prefix "s")

(general-create-definer general-m
  :states 'normal
  :prefix "m")

(general-create-definer general-comma
  :states 'normal
  :keymaps 'override
  :prefix ",")
#+end_src

** Doom Helpers
*** Switch Buffer Hook
#+begin_src emacs-lisp
(defvar doom-switch-buffer-hook nil
  "A list of hooks run after changing the current buffer.")

(defvar doom-inhibit-switch-buffer-hooks nil
  "Letvar for inhibiting `doom-switch-buffer-hook'. Do not set this directly.")

(defun doom-run-switch-buffer-hooks-a (orig-fn buffer-or-name &rest args)
  "Run hooks from `doom-switch-buffer-hook' in buffer if it has changed."
  (let ((gc-cons-threshold most-positive-fixnum))
    (if (or doom-inhibit-switch-buffer-hooks
            (eq (current-buffer) (get-buffer buffer-or-name))
            ;; norecord
            (and (eq orig-fn #'switch-to-buffer) (car args)))
        (apply orig-fn buffer-or-name args)
      (let ((doom-inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn buffer-or-name args))
          (with-current-buffer (if (windowp buffer)
                                   (window-buffer buffer)
                                 buffer)
            (run-hooks 'doom-switch-buffer-hook))
          buffer)))))

(defun doom-run-switch-to-next-prev-buffer-hooks-a (orig-fn &rest args)
  "Run hooks from `doom-switch-buffer-hook' in new buffer."
  (let ((gc-cons-threshold most-positive-fixnum))
    (if doom-inhibit-switch-buffer-hooks
        (apply orig-fn args)
      (let ((doom-inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn args))
          (with-current-buffer buffer
            (run-hooks 'doom-switch-buffer-hook))
          buffer)))))

(general-add-advice '(switch-to-buffer display-buffer)
                    :around #'doom-run-switch-buffer-hooks-a)

(general-add-advice '(switch-to-next-buffer switch-to-prev-buffer)
                    :around #'doom-run-switch-to-next-prev-buffer-hooks-a)

;; (defun noct-call-after-buffer (fun)
;;   (general-add-hook 'doom-switch-window-hook fun)
;;   (general-add-advice 'after-find-file :before (lambda (&rest _) (funcall fun))))

(defvar noct-elisp-scratch-hook nil
  "Hook run when scratch buffer switches from fundamental to emacs-lisp mode.
Can't use `after-change-major-mode-hook' hook since that triggers during init.")

;; TODO remove other after one is called
(defmacro noct-after-buffer (&rest body)
  "Run BODY once after switching buffers or when finding a file.
Doom uses a lot. Additionally run once in `noct-elisp-scratch-hook', so
BODY run if I switch the scratch buffer to elisp."
  (declare (indent defun))
  `(let ((fun (lambda (&rest _)
                ,@body)))
     (general-add-hook '(doom-switch-buffer-hook
                         noct-elisp-scratch-hook) fun nil nil t)
     (general-add-advice 'after-find-file :before fun nil t)))

(defmacro noct-after-window (&rest body)
  "Run BODY once after switching windows or when finding a file."
  (declare (indent defun))
  `(let ((fun (lambda (&rest _)
                ,@body)))
     (general-add-hook 'doom-switch-window-hook fun nil nil t)
     (general-add-advice 'after-find-file :before fun nil t)))

(defmacro noct-pre-command-or-post-file (&rest body)
  "Run BODY once in `pre-command-hook' or when finding a file."
  (declare (indent defun))
  `(let ((fun (lambda (&rest _)
                ,@body)))
     (general-add-hook 'pre-command-hook fun nil nil t)
     (general-add-advice 'after-find-file :before fun nil t)))

(defmacro noct-post-insert-and-writable (&rest body)
  "Run BODY in `evil-insert-state-entry-hook' for the first writable buffer."
  (declare (indent defun))
  `(progn
     (general-add-hook 'evil-insert-state-entry-hook
                       (lambda ()
                         (unless buffer-read-only
                           ,@body
                           t))
                       nil
                       nil
                       #'identity)))
#+end_src

*** Switch Window Hook
#+begin_src emacs-lisp
(defvar doom-switch-window-hook nil
  "A list of hooks run after changing the focused windows.")

(defvar doom-inhibit-switch-window-hooks nil
  "Letvar for inhibiting `doom-switch-window-hook'. Do not set this directly.")

(defvar doom--last-window nil)

(defun doom-run-switch-window-hooks-h ()
  (let ((gc-cons-threshold most-positive-fixnum))
    (unless (or doom-inhibit-switch-window-hooks
                (eq doom--last-window (selected-window))
                (minibufferp))
      (let ((doom-inhibit-switch-window-hooks t))
        (run-hooks 'doom-switch-window-hook)
        (setq doom--last-window (selected-window))))))

(general-add-hook 'buffer-list-update-hook #'doom-run-switch-window-hooks-h)
#+end_src

*** Switch Frame Hook
#+begin_src emacs-lisp
(defvar doom-switch-frame-hook nil
  "A list of hooks run after changing the focused frame.")

(defvar doom-inhibit-switch-frame-hooks nil
  "Letvar for inhibiting `doom-switch-frame-hook'. Do not set this directly.")

(defvar doom--last-frame nil)

(defun doom-run-switch-frame-hooks-h (&rest _)
  (unless (or doom-inhibit-switch-frame-hooks
              (eq doom--last-frame (selected-frame))
              (frame-parameter nil 'parent-frame))
    (let ((doom-inhibit-switch-frame-hooks t))
      (run-hooks 'doom-switch-frame-hook)
      (setq doom--last-frame (selected-frame)))))

(general-add-hook 'focus-in-hook #'doom-run-switch-frame-hooks-h)
#+end_src

*** Large File Handling
#+begin_src emacs-lisp
(defvar-local doom-large-file-p nil)
(put 'doom-large-file-p 'permanent-local t)

(defvar doom-large-file-size-alist '(("." . 3.0))
  "An alist mapping regexps (like `auto-mode-alist') to filesize thresholds.

If a file is opened and discovered to be larger than the threshold, Doom
performs emergency optimizations to prevent Emacs from hanging, crashing or
becoming unusably slow.

These thresholds are in MB, and is used by `doom--optimize-for-large-files-a'.")

(defvar doom-large-file-excluded-modes
  '(so-long-mode
    special-mode archive-mode tar-mode jka-compr
    git-commit-mode image-mode doc-view-mode doc-view-mode-maybe
    ebrowse-tree-mode pdf-view-mode tags-table-mode)
  "Major modes that `doom-check-large-file-h' will ignore.")

(defun doom--optimize-for-large-files-a (orig-fn &rest args)
  "Set `doom-large-file-p' if the file is too large.

Uses `doom-large-file-size-alist' to determine when a file is too large. When
`doom-large-file-p' is set, other plugins can detect this and reduce their
runtime costs (or disable themselves) to ensure the buffer is as fast as
possible."
  (if (setq doom-large-file-p
            (and buffer-file-name
                 (not doom-large-file-p)
                 (file-exists-p buffer-file-name)
                 (ignore-errors
                   (> (nth 7 (file-attributes buffer-file-name))
                      (* 1024 1024
                         (assoc-default buffer-file-name
                                        doom-large-file-size-alist
                                        #'string-match-p))))))
      (prog1 (apply orig-fn args)
        (if (memq major-mode doom-large-file-excluded-modes)
            (setq doom-large-file-p nil)
          (when (fboundp 'so-long-minor-mode) ; in case the user disabled it
            (so-long-minor-mode))
          (message "Large file! Cutting corners to improve performance")))
    (apply orig-fn args)))

(general-add-advice 'after-find-file :around #'doom--optimize-for-large-files-a)
#+end_src


*** Defer Incrementally
TODO Put this in a package.
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/42a21dffddeee57d84e82a9f0b65d1b0cba2b2af/core/core.el#L353
(defvar doom-incremental-packages '(t)
  "A list of packages to load incrementally after startup. Any large packages
here may cause noticeable pauses, so it's recommended you break them up into
sub-packages. For example, `org' is comprised of many packages, and can be
broken up into:
  (doom-load-packages-incrementally
   '(calendar find-func format-spec org-macs org-compat
     org-faces org-entities org-list org-pcomplete org-src
     org-footnote org-macro ob org org-clock org-agenda
     org-capture))
This is already done by the lang/org module, however.
If you want to disable incremental loading altogether, either remove
`doom-load-packages-incrementally-h' from `emacs-startup-hook' or set
`doom-incremental-first-idle-timer' to nil.")

(defvar doom-incremental-first-idle-timer 2.0
  "How long (in idle seconds) until incremental loading starts.
Set this to nil to disable incremental loading.")

(defvar doom-incremental-idle-timer 0.75
  "How long (in idle seconds) in between incrementally loading packages.")

(defvar doom-incremental-load-immediately nil
  ;; (daemonp)
  "If non-nil, load all incrementally deferred packages immediately at startup.")

(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defun doom-load-packages-incrementally (packages &optional now)
  "Registers PACKAGES to be loaded incrementally.
If NOW is non-nil, load PACKAGES incrementally, in `doom-incremental-idle-timer'
intervals."
  (if (not now)
      (appendq! doom-incremental-packages packages)
    (while packages
      (let ((req (pop packages)))
        (unless (featurep req)
          (message "Incrementally loading %s" req)
          (condition-case e
              (or (while-no-input
                    ;; If `default-directory' is a directory that doesn't exist
                    ;; or is unreadable, Emacs throws up file-missing errors, so
                    ;; we set it to a directory we know exists and is readable.
                    (let ((default-directory user-emacs-directory)
                          (gc-cons-threshold most-positive-fixnum)
                          file-name-handler-alist)
                      (require req nil t))
                    t)
                  (push req packages))
            ((error debug)
             (message "Failed to load '%s' package incrementally, because: %s"
                      req e)))
          (if (not packages)
              (message "Finished incremental loading")
            (run-with-idle-timer doom-incremental-idle-timer
                                 nil #'doom-load-packages-incrementally
                                 packages t)
            (setq packages nil)))))))

(defun doom-load-packages-incrementally-h ()
  "Begin incrementally loading packages in `doom-incremental-packages'.
If this is a daemon session, load them all immediately instead."
  (if doom-incremental-load-immediately
      (mapc #'require (cdr doom-incremental-packages))
    (when (numberp doom-incremental-first-idle-timer)
      (run-with-idle-timer doom-incremental-first-idle-timer
                           nil #'doom-load-packages-incrementally
                           (cdr doom-incremental-packages) t))))

(add-hook 'emacs-startup-hook #'doom-load-packages-incrementally-h)

;; Adds two keywords to `use-package' to expand its lazy-loading capabilities:
;;
;;   :after-call SYMBOL|LIST
;;   :defer-incrementally SYMBOL|LIST|t
;;
;; Check out `use-package!'s documentation for more about these two.
(eval-when-compile
  (dolist (keyword '(:defer-incrementally :after-call))
    (push keyword use-package-deferring-keywords)
    (setq use-package-keywords
          (use-package-list-insert keyword use-package-keywords :after)))

  (defalias 'use-package-normalize/:defer-incrementally #'use-package-normalize-symlist)
  (defun use-package-handler/:defer-incrementally (name _keyword targets rest state)
    (use-package-concat
     `((doom-load-packages-incrementally
        ',(if (equal targets '(t))
              (list name)
            (append targets (list name)))))
     (use-package-process-keywords name rest state))))
#+end_src

** Memoize
#+begin_src emacs-lisp
(use-package memoize)
#+end_src

** No Littering
Consistently sets the paths for various configuration, history, temporary, etc. files created by Emacs packages (e.g. =savehist-file=).
#+begin_src emacs-lisp
(use-package no-littering
  :demand t)
#+end_src

** Evil and Evil Collection
*** Setup
#+begin_src emacs-lisp
(use-package evil
  :init
  (gsetq evil-overriding-maps nil
         evil-intercept-maps nil
         evil-insert-state-bindings nil
         ;; must be set before loading evil no matter what
         evil-want-keybinding nil
         ;; required for gn
         evil-search-module 'evil-search
         evil-ex-search-persistent-highlight nil
         ;; Y like D
         evil-want-Y-yank-to-eol t)
  ;; prevent undo-tree from loading (not yet a variable to disable)
  ;; also flyspell (don't need immediately)
  (general-add-advice
   'require :around
   (noct-defun noct-prevent-evil-requires (orig-fun &rest args)
     (unless (memq (car args) '(undo-tree flyspell shell))
       (apply orig-fun args))))
  (evil-mode)
  (general-remove-advice 'require #'noct-prevent-evil-requires)
  :config
  ;; use `general-key-dispatch' for "c" (e.g. to bind cx to `evil-exchange')
  (general-def :prefix-map 'noct-c-map
    "c" (general-simulate-key (#'evil-change "c")))
  (general-def 'normal
    "c" (general-key-dispatch #'evil-change
          :inherit-keymap noct-c-map))
  (general-def 'visual "c" #'evil-change)
  ;; add back wanted insert state keybindings
  (general-def 'insert
    "C-o" #'evil-execute-in-normal-state
    "C-r" #'evil-paste-from-register
    "C-w" #'evil-delete-backward-word
    ;; trying out since don't normally use `universal-argument' in insert
    "C-u" #'evil-delete-back-to-indentation
    "¸" #'evil-delete-backward-word))

(general-def :keymaps noct-minibuffer-maps
  "¸" #'evil-delete-backward-word)

(use-package evil-collection
  :straight (evil-collection
             :local-repo "~/src/forks/evil-collection"
             :protocol ssh
             :fork t)
  :config
  (defun noct-make-evil-collection-translations (mode mode-keymaps &rest _rest)
    (when mode-keymaps
      (general-with mode
        (general-translate-key 'normal mode-keymaps
          "C-n" "C-j"
          "C-e" "C-k"))))

  (general-add-hook 'evil-collection-setup-hook
                    #'noct-make-evil-collection-translations))
#+end_src

*** Settings
**** Improvements from Vim
#+begin_src emacs-lisp
(general-with 'evil
  ;; I always disliked this behavior in vim
  (gsetq evil-move-cursor-back nil
         ;; this doesn't matter as much with above setting
         evil-move-beyond-eol t
         ;; default to inserting `<,`> when run `evil-ex' in visual char state;
         ;; unlike vim, ex commands will only apply to the selected region instead
         ;; of the selected lines when `<,`> is used
         evil-ex-visual-char-range t))
#+end_src

**** Normal State Everywhere
Use normal state as the default state for all modes.
#+begin_src emacs-lisp
;; not necessary to set `evil-normal-state-modes' (since normal is the default
;; state) but it's more explicit
(general-with 'evil
  (gsetq evil-normal-state-modes (append evil-emacs-state-modes
                                         evil-normal-state-modes)
         evil-emacs-state-modes nil
         evil-motion-state-modes nil))
#+end_src

**** Appearance
I prefer to distinguish mode by cursor color/shape instead of having to look at some indicator on the mode line.
#+begin_src emacs-lisp
(general-with 'evil
  (gsetq evil-mode-line-format nil
         evil-normal-state-cursor '(box "orchid")
         evil-normal-state-cursor '(box "dark gray")
         evil-motion-state-cursor '(box "YellowGreen")
         evil-insert-state-cursor '(bar "Blue")
         evil-emacs-state-cursor '(bar "Red")
         evil-visual-state-cursor '(box "#F86155")))
#+end_src

**** Undo Granularity
#+begin_src emacs-lisp
;; insert is one change, even if use <left>, <right>, etc.

;; the problem with `evil-want-fine-undo' non-nil is that a lot of things that
;; end up being just self-insertion become undo points (e.g. `lispy-space')
;; (gsetq evil-want-fine-undo t)
#+end_src

*** Advice
#+begin_src emacs-lisp
(general-with 'evil
  ;; TODO move this stuff to some dedicated non-package-specific heading
  (defun noct-nop-kill-new (orig-func &rest args)
    "Run ORIG-FUNC with ARGS preventing any `kill-new's from running."
    ;; http://endlessparentheses.com/understanding-letf-and-how-it-replaces-flet.html
    (cl-letf (((symbol-function 'kill-new) #'ignore))
      (apply orig-func args)))

  ;; don't copy for C-w or visually selected text
  (general-add-advice '(evil-visual-paste
                        evil-delete-backward-word
                        lispyville-delete-backward-word)
                      :around #'noct-nop-kill-new))
#+end_src

*** Remaps
**** General Swaps/Changes
#+begin_src emacs-lisp
(general-with 'evil
  ;; make home and end act on visual lines
  ;; also note `evil-respect-visual-line-mode'
  ;; don't know if I like the changes to d, p, y, and it seems they need work:
  ;; https://github.com/emacs-evil/evil/issues/188
  (general-def '(insert normal)
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line)

  (defun noct-evil-insert-visual-line (count &optional vcount)
    (interactive "p")
    (let ((evil-respect-visual-line-mode t))
      (evil-insert-line count vcount)))

  (general-def 'normal "I" #'noct-evil-insert-visual-line)

  (defun noct-evil-append-visual-line (count &optional vcount)
    (interactive "p")
    (let ((evil-respect-visual-line-mode t))
      (evil-append-line count vcount)))

  (general-def 'normal
    ;; just "@q" won't work in insert state (if recorded in insert state), but
    ;; that doesn't seem efficient
    "Q" "@q"
    "t." #'evil-ex-repeat
    "tv" #'evil-visual-block
    ;; swap a and A
    "a" #'noct-evil-append-visual-line
    "A" #'evil-append)

  (general-def 'motion ";" nil)
  (general-def 'normal
    ";" #'evil-ex)
  (general-r ";" #'evil-repeat-find-char)

  (defun noct-norm@q ()
    "Apply macro in q register on selected lines."
    (interactive)
    (evil-ex-normal (region-beginning) (region-end) "@q"))

  ;; comparable to "xnoremap Q :norm @q<cr>" in vim
  (general-def 'visual "Q" #'noct-norm@q)

  ;; since using m as prefix
  (general-def 'normal "M" #'evil-set-marker)

  ;; exit emacs state with ESC (in GUI emacs)
  (general-def 'emacs "<escape>" #'evil-normal-state)

  ;; change xall
  (evil-ex-define-cmd "xa[ll]" #'save-buffers-kill-terminal)

  ;; overwriting these keys later
  (general-rr
    "/" #'evil-ex-search-forward
    "?" #'evil-ex-search-backward))

;; camelCase word (not a remap but affects word keybindings)
(global-subword-mode)
(blackout 'subword-mode)
#+end_src

**** Colemak Swaps
#+begin_src emacs-lisp
(general-with 'evil
  (evil-redirect-digit-argument evil-motion-state-map
                                "0" #'evil-beginning-of-visual-line)

  ;; swap visual and real line movement commands
  (general-def 'motion
    "n" #'evil-next-visual-line
    "e" #'evil-previous-visual-line
    "^" #'evil-first-non-blank-of-visual-line
    "$" #'evil-end-of-visual-line
    "gn" #'evil-next-line
    "ge" #'evil-previous-line
    "g0" #'evil-beginning-of-line
    "g$" #'evil-end-of-line
    "g^" #'evil-first-non-black)

  ;; add back lost keys
  (general-def 'motion
    "j" #'evil-forward-word-end
    "gj" #'evil-backward-WORD-end
    "k" #'evil-ex-search-next
    "K" #'evil-ex-search-previous
    "gk" #'evil-next-match)

  ;; l for "[l]ast"
  (general-def 'motion
    "l" #'evil-jump-backward
    "L" #'evil-jump-forward)

  (general-def '(normal insert)
    "C-l" #'evil-switch-to-windows-last-buffer))
#+end_src

**** Escape Everywhere
Escape should be bound to ~keyboard-quit~ or ~keyboard-escape-quit~ in various minibuffer keymaps.
#+begin_src emacs-lisp
(general-def :keymaps noct-minibuffer-maps
  "<escape>" #'keyboard-escape-quit)
#+end_src

*** Repeat in Visual State
https://github.com/emacs-evil/evil/issues/742
#+begin_src emacs-lisp
(general-with 'evil
  ;; make v, V, and C-v start recording
  (evil-set-command-property 'evil-visual-char :repeat t)
  (evil-set-command-property 'evil-visual-line :repeat t)
  (evil-set-command-property 'evil-visual-block :repeat t)

  (defun noct-evil-repeat-motion (flag)
    "Repeation for motions. Motions are recorded by keystroke but only in insert state."
    ;; also record motions in visual state
    (when (memq evil-state '(insert replace visual))
      (evil-repeat-keystrokes flag)))
  (general-add-advice 'evil-repeat-motion :override #'noct-evil-repeat-motion)

  (defun noct-evil-repeat-start ()
    "Start recording a new repeat into `evil-repeat-info'."
    ;; don't stop recording in visual state
    (unless (evil-visual-state-p)
      (evil-repeat-reset t)
      (evil-repeat-record-buffer)))
  (general-add-advice 'evil-repeat-start :override #'noct-evil-repeat-start)

  (defun noct-evil-repeat-stop ()
    "Stop recording a repeat.
Update `evil-repeat-ring' with the accumulated changes
in `evil-repeat-info' and clear variables."
    ;; don't stop recording in visual state
    (unless (evil-visual-state-p)
      (unwind-protect
          (when (and (evil-repeat-recording-p))
            (setq evil-repeat-info
                  (evil-normalize-repeat-info evil-repeat-info))
            (when (and evil-repeat-info evil-repeat-ring)
              (ring-insert evil-repeat-ring evil-repeat-info)))
        (evil-repeat-reset nil))))

  (general-add-advice 'evil-repeat-stop :override #'noct-evil-repeat-stop))
#+end_src

** =straight.el= Keybindings
Now that =general.el= and =evil= are installed, I set up some keybindings for interactive usage of =straight.el=.
#+begin_src emacs-lisp
(general-s :infix "s"
  "p" #'straight-pull-package-and-deps
  "P" #'straight-pull-recipe-repositories
  "a" #'straight-pull-all
  "r" #'straight-rebuild-package
  "c" #'straight-check-all
  "f" #'straight-freeze-versions
  "t" #'straight-thaw-versions
  "u" #'straight-use-package)
#+end_src

** Hydra
I generally avoid =:exit t= hydras; =which-key= is automatic and good enough already. I've removed a lot of my hydras. I am planning on adding more back when I get a chance, but I probably won't use ~defhydra~ during initialization.
#+begin_src emacs-lisp
(use-package hydra
  :config
  (gsetq hydra-is-helpful t
         ;; prevents message from disappearing
         hydra-lv t))
#+end_src

** Computer Local Setup
#+begin_src emacs-lisp
(let ((local-file (expand-file-name "lisp/local.el" user-emacs-directory)))
  (when (file-exists-p local-file)
    (load-file local-file)))
#+end_src

* Basic and Builtin Functionality
** General Settings
#+begin_src emacs-lisp
;; split horizontally on right (i.e. split line going from top to bottom)
;; http://stackoverflow.com/questions/2081577/setting-emacs-split-to-horizontal
(gsetq split-height-threshold nil
       split-width-threshold 0)

(gsetq
 ;; like scrolloff in vim
 scroll-margin 5
 ;; recenter the point if it goes >20 lines past what is visible
 ;; the default (0) is kind of annyoying because it recenters even if you just
 ;; go one line down from the window bottom, but a higher value is nice to
 ;; automatically recenter after any bigger jump
 scroll-conservatively 20
 ;; scroll-preserve-screen-position t
 )

(gsetq sentence-end-double-space nil)

;; don't ask; follow symlinks to file under version control
(gsetq find-file-visit-truename t
       vc-follow-symlinks t)

;; put path before buffer name when uniquifying a buffer (instead of after)
(gsetq uniquify-buffer-name-style 'forward)

;; use system trash for file deletion (includes dired and backups)
(gsetq delete-by-moving-to-trash t)

;; quickly display current incomplete keystrokes in echo area
(gsetq echo-keystrokes 0.1)

;; save clipboard to kill ring before replacing
(gsetq save-interprogram-paste-before-kill t)

;; a lot of unix tools expect this; it's required for the crontab, for example
(gsetq require-final-newline t)

;; new in emacs 26; kill running processes without confirmation on Emacs exit
(gsetq confirm-kill-processes nil)

;; I don't use bidirectional text; improves speed for long lines (even when no
;; bidirectional text)
(gsetq bidi-inhibit-bpa t)
(gsetq-default bidi-display-reordering 'left-to-right
               bidi-paragraph-direction 'left-to-right)

;; NOTE it is pretty much never necessary to set these; Emacs sets them
;; correctly based on platform already
;; (terminal-coding-system) already defaults to utf-8-unix (linux)
;; (set-terminal-coding-system 'utf-8)
;; (keyboard-coding-system) already defaults to utf-8-unix (linux)
;; (set-keyboard-coding-system 'utf-8)
;; same for `default-file-name-coding-system'
;; (set-file-name-coding-system 'utf-8)
;; this is mainly just a combination of the past three
;; (prefer-coding-system 'utf-8)

;; defaults to "English"
;; (set-language-environment 'utf-8)

;; increase number of messages
(gsetq message-log-max 10000)

(gsetq kill-do-not-save-duplicates t)

(gsetq adaptive-fill-mode t)
#+end_src

** General Keybindings
#+begin_src emacs-lisp
;; worse keybinding but sometimes I use on OSX
(general-def "C-v" #'yank)

(general-def '(normal visual)
  ":" #'eval-expression)

(general-def '(insert normal)
  "C-;" #'eval-expression)

(general-t ";" #'execute-extended-command)

(general-spc "F" #'find-file)
#+end_src

** Appearance/GUI
*** Settings
#+begin_src emacs-lisp
(gsetq x-gtk-use-system-tooltips nil
       pos-tip-internal-border-width (noct-border-width))

;; looks better
(gsetq x-underline-at-descent-line t)

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395
(gsetq window-resize-pixelwise t
       frame-resize-pixelwise t)

;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core.el#L177
(setq idle-update-delay 1)

;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core.el#L228
;; "Reduce rendering/line scan work for Emacs by not rendering cursors or
;; regions in non-focused windows."
(gsetq-default cursor-in-non-selected-windows nil)
(gsetq highlight-nonselected-windows nil)

;; "More performant rapid scrolling over unfontified regions. May cause brief
;; spells of inaccurate fontification immediately after scrolling."
(gsetq fast-but-imprecise-scrolling t)
#+end_src

*** Font
#+begin_src emacs-lisp
(defun noct-set-font (&rest _)
  "Set the font."
  (interactive)
  ;; `set-face-attribute' has more convenient syntax than `set-frame-font'

  ;; no
  ;; - iosevka - don't need a thin font (and a lot taller than others)
  ;; - 3270
  ;; - anonymous pro
  ;; - aurulent
  ;; - bitstream
  ;; - code new roman
  ;; - daddytimemono (a little too weird)
  ;; - gohu (looks like a bitmap font)
  ;; - hasklig (don't like how wide it is)
  ;; - heavy data - unreadable
  ;; - lekton
  ;; - monofur (a little too weird)
  ;; - monoid
  ;; - m+ - too tall
  ;; - open dyslexic - too weird
  ;; - overpass
  ;; - proggy (blurry)
  ;; - source code pro (office code pro looks much better to me)
  ;; - share tech mono
  ;; - space mono (don't like parens and really wide)
  ;; - tinos - monospace version is broken?

  ;; Evaluate further
  (set-face-attribute 'default nil :font "BlexMono Nerd Font-11")
  (set-face-attribute 'default nil :font "FantasqueSansMono Nerd Font-12")
  (set-face-attribute 'default nil :font "Hack Nerd Font-11")
  (set-face-attribute 'default nil :font "Hurmit Nerd Font-11")
  (set-face-attribute 'default nil :font "iMWritingMonoS Nerd Font-11")
  (set-face-attribute 'default nil :font "iMWritingDuoS Nerd Font-11")
  (set-face-attribute 'default nil :font "iMWritingQuattroS Nerd Font-11")
  (set-face-attribute 'default nil :font "Inconsolata Nerd Font-12")
  (set-face-attribute 'default nil :font "InconsolataGo Nerd Font-12")
  (set-face-attribute 'default nil :font "InconsolataLGC Nerd Font-11")
  (set-face-attribute 'default nil :font "LiterationMono Nerd Font-11")
  (set-face-attribute 'default nil :font "MesloLGS Nerd Font-11")
  ;; TODO try others
  (set-face-attribute 'default nil :font "MesloLGL Nerd Font-11")
  (set-face-attribute 'default nil :font "mononoki Nerd Font-12")
  ;; TODO try others
  (set-face-attribute 'default nil :font "Migu 1M-12")
  (set-face-attribute 'default nil :font "NotoMono Nerd Font-11")
  (set-face-attribute 'default nil :font "ProFontWindows Nerd Font-12")
  (set-face-attribute 'default nil :font "ProFontIIx Nerd Font-10")
  (set-face-attribute 'default nil :font "RobotoMono Nerd Font-10")
  (set-face-attribute 'default nil :font "Iosevka-11")
  ;; actually looks okay
  (set-face-attribute 'default nil :font "TerminessTTF Nerd Font-12")
  (set-face-attribute 'default nil :font "Ubuntu Mono-12")
  (set-face-attribute 'default nil :font "VictorMono Nerd Font-11")
  (set-face-attribute 'default nil :font "Recursive Mono Linear Static-10")
  (set-face-attribute 'default nil :font "Recursive Mono Casual Static-10")
  (set-face-attribute 'default nil :font "Sarasa Mono J-10")

  ;; Fine
  (set-face-attribute 'default nil :font "DroidSansMono Nerd Font-11")
  ;; not too far off from droid sans; like slightly better
  (set-face-attribute 'default nil :font "Cousine Nerd Font-11")
  ;; like better than both cousine and droid sans
  (set-face-attribute 'default nil :font "DejaVu Sans Mono-11")
  ;; cool asterisk
  (set-face-attribute 'default nil :font "GoMono Nerd Font-10")

  ;; previously used
  ;; - inconsolata, inconsolataLGC, etc.
  ;; - fira mono

  ;; TODO pragmata
  ;; (set-face-attribute 'default nil :font "-10")
  ;; (set-face-attribute 'default nil :font "-10")
  ;; TODO cousine
  ;; ttf-apple-fonts
  ;; input mono
  ;; monaco
  ;; cousine
  ;; cmu typewriter
  ;; pt mono
  ;; lucida console
  ;; jula mono
  ;; comic mono

  ;; favorites
  ;; (set-face-attribute 'default nil :font "Fira Mono-10")
  ;; Fira Mono and Code don't have italic; add a font with italic
  ;; (set-face-attribute 'italic nil :family "Office Code Pro")
  (set-face-attribute 'default nil :font "CaskaydiaCove Nerd Font-10")
  (set-face-attribute 'default nil :font "agave Nerd Font Mono-12")
  (set-face-attribute 'default nil :font "JetBrainsMono Nerd Font-11")
  (set-face-attribute 'default nil :font "Office Code Pro D-10"))

;; this is slow on the first run even if set only one font (0.01-0.05 seconds)
;; (noct-set-font)
;; instead set the default font in ./early-init.el; works with daemon as well

;; https://www.djcbsoftware.nl/code/mu/mu4e/Fancy-characters.html#Fancy-characters
(use-package unicode-fonts
  :disabled t
  :init
  ;; TODO somewhat slow; worth it?
  ;; TODO when running when starting the server, ends up invalidating the cache and
  ;; doing everything again
  (noct-after-gui
    (unicode-fonts-setup)))
#+end_src

** Auth Source
#+begin_src emacs-lisp
(general-with-package 'auth-source
  ;; use encrypted authinfo file by default
  (gsetq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc"))
  (when (featurep 'noct-info)
    ;; use asymmetric encryption for authinfo.gpg
    (gsetq auth-source-gpg-encrypt-to (list user-mail-address))))
#+end_src

** Auto Compression
Automatically uncompress (for editing) and recompress (when saving) compressed files (e.g. =.gz= files).
#+begin_src emacs-lisp
(use-package jka-compr
  :init (auto-compression-mode))
#+end_src

** Auto Revert
#+begin_src emacs-lisp
(blackout 'auto-revert-mode)
#+end_src

** Auto Saving
#+begin_src emacs-lisp
(gsetq auto-save-interval 30
       auto-save-timeout 5
       ;; don't create auto-save ~ files
       auto-save-default nil)

(auto-save-visited-mode)

(defun noct-save ()
  "If in a file buffer and not executing/recording a macro, save."
  (when (and (or (buffer-file-name)
                 (bound-and-true-p org-src-source-file-name))
             (not (or executing-kbd-macro defining-kbd-macro)))
    (noct-silently
      (save-buffer))))

(defun noct-toggle-save-on-insert-exit ()
  "Enable or disable saving on insert state exit."
  (interactive)
  (if (and (boundp 'evil-insert-state-exit-hook)
           (memq #'noct-save evil-insert-state-exit-hook ))
      (general-remove-hook 'evil-insert-state-exit-hook #'noct-save)
    (general-add-hook 'evil-insert-state-exit-hook #'noct-save)))

;; not for now
;; (noct-toggle-save-on-insert-exit)

(general-def noct-toggle-map "S" #'noct-toggle-save-on-insert-exit)

(general-t "s" #'evil-write)
#+end_src

** Backup
#+begin_src emacs-lisp
(defun noct-backup-predicate (file)
  "Return whether to backup FILE.
Don't backup remote directories or encrypted files."
  (not (or (file-remote-p file)
           (string-match-p (car epa-file-handler) file))))

(gsetq backup-enable-predicate #'noct-backup-predicate
       ;; don't delink hardlinks
       backup-by-copying t
       ;; add version numbers to backups
       version-control t
       ;; automatically delete old versions
       delete-old-versions t
       kept-new-versions 30
       kept-old-versions 20
       ;; backup files under version control too
       vc-make-backup-files t)
#+end_src

** Bookmarks
#+begin_src emacs-lisp
(general-s
  "m" #'bookmark-set
  "'" #'bookmark-jump)
#+end_src

** Disabling Defaults
#+begin_src emacs-lisp
;; disable startup messages
(gsetq inhibit-startup-message t
       ;; ...
       ;; inhibit-startup-echo-area-message (user-login-name)
       inhibit-splash-screen t)

(general-add-advice 'startup-echo-area-message :override #'ignore)

;; don't flash screen (e.g. when at end of buffer and use `evil-next-line')
;; this is the default
;; (gsetq visible-bell nil)

;; no tool bar, scroll bar, or menu
;; NOTE these combined add 0.2~0.3 seconds to init according to
;; `emacs-init-time' and `profile-dotemacs'; it is now possible to prevent them
;; ever displaying in ~/.emacs.d/early-init.el
;; https://github.com/raxod502/radian/issues/180
;; (tool-bar-mode -1)
;; (scroll-bar-mode -1)
;; (menu-bar-mode -1)

;; no tooltip popups (use echo area instead)
(tooltip-mode -1)

;; don't blink cursor (infuriating)
(blink-cursor-mode -1)
#+end_src

** Executable
#+begin_src emacs-lisp
;; insert "/usr/bin/env interpreter" for shebangs
(gsetq executable-prefix-env t)
#+end_src

** Fill Column
Also see [[#whitespace][Whitespace Mode]].
#+begin_src emacs-lisp
(gsetq-default fill-column 80)
#+end_src

** Garbage Collection
Testing.
#+begin_src emacs-lisp
(use-package gcmh
  :ghook ('pre-command-hook nil nil nil t)
  :config
  ;; settings used by doom; default infinite threshold causes Emacs to
  ;; completely freeze after working for a while; maybe this will be better
  (gsetq gcmh-idle-delay 10
         gcmh-high-cons-threshold 16777216)
  (general-add-hook 'focus-out-hook #'gcmh-idle-garbage-collect))
#+end_src

** History/Savehist
Persist minibuffer and search history.
#+begin_src emacs-lisp
(gsetq kill-ring-max 300)

(gsetq history-length 3000
       history-delete-duplicates t)

(use-package savehist
  ;; doesn't actually seem to be necessary for savehist?
  :straight (:type built-in)
  :defer-incrementally custom
  :init
  ;; this and :defer-incrementally is how doom loads it
  ;; using `post-command-hook' is enough to trigger for `evil-ex',
  ;; `eval-expression', etc.
  (general-add-hook 'post-command-hook
                    (lambda () (require 'savehist))
                    nil nil t)
  :config
  ;; default
  ;; savehist-save-minibuffer-history t
  (gsetq savehist-additional-variables '(mark-ring
                                         global-mark-ring
                                         search-ring
                                         regexp-search-ring
                                         extended-command-history)
         savehist-autosave-interval 60)

  (savehist-mode))
#+end_src

** H Prefix/Help Mode
Some keys in =help-mode-map= that are worth noting:
- =P=: ~describe-package~
- =S=: ~info-lookup-symbol~
- =b=: ~describe-bindings~
- =e=: ~view-echo-area-messages~ (pulls up messages buffer)
- =l=: ~view-lossage~
- =r=: ~info-emacs-manual~
- =s=: ~describe-syntax~
- =n=: ~view-emacs-news~

Obvious ones:
- =f=: ~describe-function~
- =i=: ~info-mode~
- =k=: ~describe-key~
- =m=: ~describe-mode~
- =v=: ~describe-variable~

#+begin_src emacs-lisp
(general-with-package 'help-mode
  (general-def 'normal "h" #'help-command)

  (general-def help-map
    ;; swap c and C
    "c" #'describe-coding-system
    "C" #'describe-key-briefly
    ;; [p]ackage
    "p" #'apropos-library
    ;; very useful (binding over `view-lossage')
    "l" #'find-library
    "h" #'find-function
    "V" #'find-variable
    "e" #'elisp-index-search)

  (general-def 'normal help-mode-map
    "q" #'quit-window
    "ESC" #'quit-window)

  (noct-handle-popup help-mode))
#+end_src

** Indentation
#+begin_src emacs-lisp
;; don't use tabs for indenting by default
(gsetq-default indent-tabs-mode nil
               tab-width 4)
#+end_src

** Minibuffer
#+begin_src emacs-lisp
(gsetq enable-recursive-minibuffers t)

(minibuffer-depth-indicate-mode)

;; don't allow moving the cursor left into the minibuffer promt
;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core-ui.el#L368
(gsetq minibuffer-prompt-properties
       '(read-only t face minibuffer-prompt intangible t cursor-intangible t))
(general-add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

;; https://www.reddit.com/r/emacs/comments/4d8gvt/how_do_i_automatically_close_the_minibuffer_after/
(defun helper:kill-minibuffer ()
  "Exit the minibuffer if it is active."
  (when (and (>= (recursion-depth) 1)
             (active-minibuffer-window))
    (abort-recursive-edit)))

(general-add-hook 'mouse-leave-buffer-hook #'helper:kill-minibuffer)

;; equality checks don't work (or are run too soon)
;; TODO finds some way to tell if the minibuffer is the selected window
;; (defun noct-kill-minibuffer ()
;;   "Kill the minibuffer if it is not the active window."
;;   (unless (and (>= (recursion-depth) 1)
;;                (or (not (windowp (active-minibuffer-window)))
;;                    (equal (active-minibuffer-window)
;;                           (selected-window))
;;                    (minibuffer-window-active-p (selected-window))))
;;     (abort-recursive-edit)))
;; (add-hook 'window-configuration-change-hook #'noct-kill-minibuffer)
#+end_src

** Native Compilation
#+begin_src emacs-lisp
;; don't continuously popup warning buffer
(gsetq native-comp-async-report-warnings-errors nil)
#+end_src

** OSX
#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  ;; use command as control
  (gsetq mac-command-modifier 'control
         mac-option-modifier 'meta)
  ;; fix home and end
  (general-def
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line))
#+end_src

** Profiling
#+begin_src emacs-lisp
(use-package profiler
  :straight (:type built-in)
  :general (general-s
             :infix "p"
             "p" #'profiler-start
             "r" #'profiler-report
             "s" #'profiler-stop))
#+end_src

** Recentf
#+begin_src emacs-lisp
;; ivy also automatically enables recentf-mode
(use-package recentf
  :defer-incrementally (easymenu tree-widget timer)
  :init
  (general-add-advice '(after-find-file consult-buffer)
                      :before
                      (lambda (&rest _)
                        (recentf-mode))
                      nil
                      t)
  :config
  (gsetq recentf-max-saved-items 1000)

  (defun doom--recent-file-truename (file)
    (if (or (file-remote-p file nil t)
            (not (file-remote-p file)))
        (file-truename file)
      file))

  ;; settings from doom
  (setq recentf-filename-handlers
        '(;; Text properties inflate the size of recentf's files, and there is
          ;; no purpose in persisting them, so we strip them out.
          substring-no-properties
          ;; Resolve symlinks of local files. Otherwise we get duplicate
          ;; entries opening symlinks.
          doom--recent-file-truename
          ;; Replace $HOME with ~, which is more portable, and reduces how much
          ;; horizontal space the recentf listing uses to list recent files.
          abbreviate-file-name)
        recentf-auto-cleanup 'never)
  (general-add-hook 'kill-emacs-hook #'recentf-cleanup)
  (general-add-hook
   '(doom-switch-window-hook write-file-functions)
   (progn (defun doom--recentf-touch-buffer-h ()
            "Bump file in recent file list when it is switched or written to."
            (when buffer-file-name
              (recentf-add-file buffer-file-name))
            ;; Return nil for `write-file-functions'
            nil)
          #'doom--recentf-touch-buffer-h))

  (general-add-advice 'recentf-load-list :around #'noct-silence-advice)

  ;; I haven't had many issues with unwanted files getting in the way
  ;; https://www.reddit.com/r/emacs/comments/3g468d/stop_recent_files_showing_elpa_packages/
  ;; (gsetq recentf-exclude '("^/var/folders\\.*" "COMMIT_EDITMSG\\'" ".*-autoloads\\.el\\'" "[/\\]\\.elpa/" ))

  ;; save recent after 10 seconds of idle time
  ;; if not idle, save every 5 minutes
  (noct-run-at-active-interval (* 5 60) 10
    (noct-silently
      (when recentf-mode
        (recentf-save-list)))))
#+end_src

** Reveal
#+begin_src emacs-lisp
(use-package reveal
  :init
  (noct-after-buffer (global-reveal-mode)))
#+end_src

** Save Place
#+begin_src emacs-lisp
(noct-after-buffer
  (save-place-mode))
#+end_src

** So Long
#+begin_src emacs-lisp
(use-package so-long
  :general (noct-toggle-map "s" #'so-long-mode))
#+end_src

** Scratch Buffer
Suggested [[https://www.reddit.com/r/emacs/comments/4agorq/got_bored_of_the_initial_scratch_message_so/][here]].
#+begin_src emacs-lisp
;; put fortune in scratch buffer
(defun noct-cached-fortune ()
  "Return a cached fortune message."
  (prog1 (when (file-exists-p "~/.cache/fortune")
           (with-temp-buffer
             (insert-file-contents "~/.cache/fortune")
             (delete-trailing-whitespace)
             (buffer-string)))
    ;; generate a new message for next time
    (start-process-shell-command
     "new-fortune"
     nil
     (concat "cowthink -b -W 77 \"$(fortune lambda)\""
             " | sed 's/^/;; /'"
             "  > ~/.cache/fortune"))))

(gsetq initial-scratch-message (noct-cached-fortune))

;; improve startup time (packages enabled for emacs-lisp-mode not
;; loaded immediately)
(gsetq initial-major-mode 'fundamental-mode)

(use-package persistent-scratch
  :general (general-comma "S" #'noct-goto-scratch)
  :config
  (gsetq persistent-scratch-autosave-interval 60)

  (defun noct-goto-scratch ()
    "Open the scratch buffer and set it up if it hasn't been set up.
Enable `persistent-scratch-auto-save-mode' and `emacs-lisp-mode'."
    (interactive)
    (switch-to-buffer "*scratch*")
    (unless persistent-scratch-autosave-mode
      (persistent-scratch-setup-default)
      (emacs-lisp-mode)
      (run-hooks 'noct-elisp-scratch-hook))))
#+end_src

** Sudo Editing
This configuration allows automatically editing root owned files (as opposed to opening them in read only mode). Alternatively, if you usually edit root files from the terminal, emacsclient works fine with sudoedit.

I've switched away from putting this function in a hook because it can be jarring and because there are some situations where I only want to read these files.
#+begin_src emacs-lisp
;; function modified from comment here:
;; http://emacsredux.com/blog/2013/04/21/edit-files-as-root/
;; Additionally:
;; - Support file creation
;; - Support remote connection
;; - Support dired
;; TODO test with remote files again (lost some changes)
(defun noct-maybe-sudo-edit ()
  "If the current file is exists and is unwritable, edit it as root with sudo."
  (interactive)
  (let* ((file (or buffer-file-name
                   (when (derived-mode-p 'dired-mode 'wdired-mode)
                     default-directory)))
         (parent (file-name-directory file))
         ;; don't try to lookup password with auth-source
         auth-sources)
    (when (and file
               (not (file-writable-p file))
               (or (file-exists-p file)
                   ;; might want to create a file
                   (and (file-exists-p parent)
                        (not (file-writable-p parent))))
               ;; don't want to edit Emacs source files as root
               (not (string-match "/usr/share/emacs/.*" file)))
      (let ((method (file-remote-p default-directory 'method))
            (user (file-remote-p default-directory 'user))
            (host (file-remote-p default-directory 'host))
            (localname (file-remote-p file 'localname)))
        (find-file (if method
                       (concat "/" method ":" user "@" host
                               "|sudo:" host ":" localname)
                     (concat "/sudo:root@localhost:" file)))))))

;; [S]u[d]o or [S]udo e[d]it
(general-s "d" #'noct-maybe-sudo-edit)
#+end_src

** Text Scaling Keybindings
#+begin_src emacs-lisp
;; (general-def 'normal
;;   "C-=" #'text-scale-increase
;;   "C--" #'text-scale-decrease)

;; change text scale everywhere
(use-package default-text-scale
  :general
  ('normal
   "C-=" #'default-text-scale-increase
   "C--" #'default-text-scale-decrease))
#+end_src

** Toggle Settings Keybindings
#+begin_src emacs-lisp
(general-def
  :prefix-command 'noct-toggle
  :prefix-map 'noct-toggle-map
  "d" #'toggle-debug-on-error
  "q" #'toggle-debug-on-quit
  "R" #'read-only-mode
  "A" #'auto-fill-mode
  "t" #'toggle-truncate-lines)

(general-t "o" #'noct-toggle)
#+end_src

** TRAMP
#+begin_src emacs-lisp
;; NOTE remote backups disabled in backup section
;; backing up locally instead with `backup-each-save'
;; https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html
(gsetq vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                    vc-ignore-dir-regexp
                                    tramp-file-name-regexp))
#+end_src

** Undo Granularity
#+begin_src emacs-lisp
(noct-add-undo-bounds 'yank)
(noct-add-undo-bounds 'fill-paragraph)
#+end_src

** Which Function Mode
#+begin_src emacs-lisp
;; show current function (or heading) name in modeline
(which-function-mode)
#+end_src

* Completion, Selection, and Matching/Sorting
** Affe
#+begin_src emacs-lisp
(use-package affe
  :general
  (general-spc "?" #'affe-grep)
  :config
  (require 'orderless)
  (gsetq affe-regexp-function #'orderless-pattern-compiler
         affe-highlight-function #'orderless--highlight
         affe-grep-command (concat "rg "
                                   "--null "
                                   "--color=never "
                                   "--max-columns=1000 "
                                   "--no-heading "
                                   "--line-number "
                                   "-v ^$ "
                                   ;; adding these to default
                                   "--hidden "
                                   "--max-columns-preview "
                                   ;; defaults
                                   ".")))
#+end_src

** Avy
#+begin_src emacs-lisp
(use-package avy
  :config
  (gsetq avy-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o ?w ?f ?p ?l ?u ?y)
         avy-all-windows nil
         ;; decrease timeout
         avy-timeout-seconds 0.2)

  (general-def '(normal insert)
    "C-." #'avy-resume)

  (general-r "." #'avy-resume)

  (general-after 'evil
    (evil-define-motion noct-goto-char-timer-or-swiper-isearch (_count)
      :type inclusive
      :jump t
      :repat abort
      (evil-without-repeat
        (evil-enclose-avy-for-motion
          (when (eq (avy-goto-char-timer) t)
            (let ((swiper-goto-start-of-match (not evil-this-operator)))
              (swiper-isearch avy-text))))))

    (general-r "/" #'noct-goto-char-timer-or-swiper-isearch)

    (general-add-advice 'avy-resume :after #'evil-normal-state)))
#+end_src

** Company
*** Setup
#+begin_src emacs-lisp
(use-package company
  :init
  ;; (noct-pre-command-or-post-file
  ;;   (global-company-mode))
  (noct-post-insert-and-writable
    (global-company-mode))
  :blackout t
  :config
  (general-def '(company-active-map company-search-map)
    "M-n" nil)
  ;; setting idle delay too low can cause a lot of lag depending on the backend
  (gsetq company-idle-delay 0.15
         company-minimum-prefix-length 1
         ;; company-tooltip-limit 15
         ;; e.g.for yasnippet annotations
         ;; company-tooltip-align-annotations t
         company-show-quick-access t
         company-quick-access-keys '("a" "r" "s" "t" "d" "h" "n" "e" "i" "o")
         company-abort-on-unique-match nil
         ;; more space between icon and completion text
         company-icon-margin 3)

  (general-add-hook 'evil-normal-state-entry-hook
                    (noct-defun doom-company-abort-h ()
                      (when company-candidates
                        (company-abort))))

  (defun trishume:company-backend-with-yas (backends)
    "Add :with company-yasnippet to company BACKENDS.
Taken from https://github.com/syl20bnr/spacemacs/pull/179."
    (if (and (listp backends) (memq 'company-yasnippet backends))
        backends
      (append (if (consp backends)
                  backends
                (list backends))
              '(:with company-yasnippet))))

  ;; add yasnippet to all backends
  (gsetq company-backends
         (mapcar #'trishume:company-backend-with-yas company-backends))

  (general-def noct-toggle-map "c" #'company-mode)

  (general-def 'insert "C-t" #'company-yasnippet)

  ;; tab more similar to vim (tab tabs through completions)
  (require 'company-tng)

  (company-tng-configure-default)

  (general-def company-active-map
    ;; don't take over these keys
    "C-h" nil
    "C-w" nil)

  ;; can use for snippet expansion (if take too long to hit tab; shouldn't
  ;; happen normally)
  (general-def company-active-map
    :predicate '(company-explicit-action-p)
    "RET" #'company-complete)

  ;; TODO messes up company-posframe
  ;; (popup will dissappear when quickhelp pops up.. presumably because evil is
  ;; enabled in it?)
  ;; (general-add-hook 'evil-normal-state-entry-hook #'company-abort)
  )
#+end_src

*** Company in Minibuffer
#+begin_src emacs-lisp :tangle no
;; https://github.com/company-mode/company-mode/issues/42
;; modified from https://gist.github.com/Bad-ptr/7787596
;; TODO needs work
;; also would be nice to setup `eval-expression' in childframe
(general-with-package 'company
  (defvar noct-eval-expression-commands
    (list
     ;; #'execute-extended-command
     #'eval-expression
     #'eldoc-eval-expression)
    "Commands for evaluating emacs lisp in the minibuffer.")

  (defvar company-minibuffer-mode)

  (defun company-elisp-minibuffer (command &optional arg &rest ignored)
    "`company-mode' completion back-end for Emacs Lisp in the minibuffer."
    (interactive (list 'interactive))
    (cl-case command
      ('prefix (and (minibufferp)
                    (cl-case company-minibuffer-mode
                      ('execute-extended-command (company-grab-symbol))
                      (t (company-capf `prefix)))))
      ('candidates
       (cl-case company-minibuffer-mode
         ('execute-extended-command (all-completions arg obarray 'commandp))
         (t nil)))))

  (defun minibuffer-company ()
    (unless company-mode
      (when (and global-company-mode (memq this-command noct-eval-expression-commands))

        (setq-local company-minibuffer-mode this-command)

        (setq-local completion-at-point-functions
                    (list (if (fboundp 'elisp-completion-at-point)
                              #'elisp-completion-at-point
                            #'lisp-completion-at-point) t))

        (setq-local company-backends '((company-elisp-minibuffer company-capf)))

        (company-mode 1)

        (when (eq this-command #'execute-extended-command)
          (company-complete)))))

  (general-add-hook 'minibuffer-setup-hook #'minibuffer-company))
#+end_src

*** Org Mode Fix
https://github.com/company-mode/company-mode/issues/50
#+begin_src emacs-lisp
(general-with-package 'company
  ;; something is removing this for some reason
  (general-pushnew #'org-self-insert-command company-begin-commands))
#+end_src

*** Company Try Hard
I haven't run into a case yet where I would need this but am leaving this placeholder for now.

*** Company Box (child frame frontend)
Looks nice and replaces =company-quickhelp= as well. The default company frontend is faster though.
#+begin_src emacs-lisp
(use-package company-box
  ;; :ghook 'company-mode-hook
  :general
  (general-def noct-toggle-map "b" #'company-box-mode)
  :blackout t
  :config
  (gsetq company-box-icons-alist 'company-box-icons-all-the-icons))
#+end_src

*** Company Posframe (child frame frontend)
#+begin_src emacs-lisp
(use-package company-posframe
  :ghook 'company-mode-hook
  :blackout t
  :config
  (general-def noct-toggle-map "C" #'company-posframe-mode))
#+end_src

** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :disabled t
  :ghook 'minibuffer-setup-hook
  :config
  (gsetq corfu-auto t
         corfu-auto-delay 0.15
         corfu-auto-prefix 1)

  (general-def corfu-map
    [tab] #'corfu-next))
#+end_src

** Completion
#+begin_src emacs-lisp
(gsetq completion-ignore-case t)
#+end_src

** FLX
Helper library for fuzzy matching/finding (used by ivy, for example).
#+begin_src emacs-lisp
(use-package flx
  :disabled t)
#+end_src

** Frog Menu
#+begin_src emacs-lisp
(use-package frog-menu
  :straight (:host github :repo "clemera/frog-menu" :fork t :protocol ssh)
  :config
  (general-after 'avy
    (gsetq frog-menu-avy-keys avy-keys))
  (general-after-gui
    (gsetq frog-menu-posframe-border-width (noct-border-width)))
  (setf (alist-get 'avy-posframe frog-menu-display-option-alist)
        #'noct-posframe-poshandler-frame-near-top-center)
  ;; readable background color
  (set-face-background 'frog-menu-posframe-background-face "black")
  ;; for now don't use posframe
  (gsetq frog-menu-type-function (lambda () 'avy-side-window))
  ;; show at top instead of bottom
  (map-put
   frog-menu-display-option-alist
   'avy-side-window
   '(noct-display-bufer-in-side-window-no-header
     (side . top))))
#+end_src

** Helm
TODO Try more helm.
*** Setup
#+begin_src emacs-lisp
(use-package helm
  :config
  ;; altered helm-mini (similar to helm-for-files)
  (gsetq helm-mini-default-sources
         '(helm-source-buffers-list
           helm-source-recentf
           helm-source-files-in-current-dir
           helm-source-locate
           helm-source-buffer-not-found))

  ;; can always cancel out of fuzzy with a space
  (gsetq helm-buffers-fuzzy-matching t
         helm-recentf-fuzzy-match t
         helm-locate-fuzzy-match t
         helm-semantic-fuzzy-match t
         helm-imenu-fuzzy-match t)

  ;; settings for helm-find-files
  (gsetq helm-ff-search-library-in-sexp t
         helm-ff-file-name-history-use-recentf t
         helm-ff-skip-boring-files t)

  (general-def 'helm-map
    "<tab>" #'helm-execute-persistent-action
    "¸" #'evil-delete-backward-word)

  (helm-autoresize-mode))

;; Filtering:
;; - ^<text> (to start with)
;; - *<major mode>, e.g. *dired or *!dired
;; - /<dir> or !/<dir>
;; @<text> for filtering by buffer contents

;; ./ to reach default dir quickly; ~/ for home or / for root or ../ for back
#+end_src

*** Helm FLX
#+begin_src emacs-lisp
(use-package helm-flx
  :after helm
  :demand t
  :config
  (helm-flx-mode))
#+end_src

*** Helm Posframe
#+begin_src emacs-lisp
(use-package helm-posframe
  :disabled t
  :after helm
  :demand t
  :config
  (gsetq helm-posframe-poshandler
         #'noct-posframe-poshandler-frame-near-top-center)
  ;; TODO no border setting currently; make issue
  ;; (when (display-graphic-p)
  ;;   (gsetq helm-posframe-border-width (round (* 0.001 (x-display-pixel-width)))
  ;;          ;; this is in columns (i.e. character width) not pixels
  ;;          helm-posframe-width 120))
  (helm-posframe-enable))
#+end_src

** Headlong
Select candidate as soon as there is only one (like the headlong package but for ivy and selectrum). This is used for cases where you know there is a correct match in the candidates and there aren't too many candidates. Right now, I'm using it mainly for dired (like ranger's =f=), but this could be used elsewhere.
#+begin_src emacs-lisp
;; TODO consider making a PR with a better implementation
(defvar noct-ivy-command nil)
(defvar noct-ivy-major-mode nil)

(defun noct-set-ivy-info (&rest _)
  (setq noct-ivy-command this-command
        noct-ivy-major-mode major-mode))

(general-add-advice 'ivy-read :before #'noct-set-ivy-info)

(defun noct-wait-for-user (seconds)
  "Wait for user to stop typing for SECONDS."
  (while (not (sit-for seconds t))
    (discard-input)))

(defun noct-premature-select ()
  (cond ((or (and (memq noct-ivy-command '(counsel-find-file dired-goto-file))
                  (memq noct-ivy-major-mode '(ranger-mode dired-mode)))
             (eq noct-ivy-command #'projectile-find-test-file))
         (cond ((= ivy--length 0)
                (backward-delete-char-untabify 1))
               ((= ivy--length 1)
                (noct-wait-for-user 0.2)
                (ignore-errors (ivy-done)))))))

(general-add-advice 'ivy--exhibit :after #'noct-premature-select)

;; (defvar noct-block-input nil)
;; (defun noct-maybe-block-input ()
;;   (when noct-block-input
;;     (setq noct-block-input nil)
;;     (sleep-for 2)
;;     (discard-input)))

;; (general-add-hook 'post-command-hook #'noct-maybe-block-input)


(defvar noct-selectrum-command nil)
(defvar noct-selectrum-major-mode nil)
(defun noct-set-selectrum-info (&rest _)
  (setq noct-selectrum-command this-command
        noct-selectrum-major-mode major-mode))
(general-add-advice 'selectrum--read :before #'noct-set-selectrum-info)

(defun noct-selectrum-premature-select (&rest _)
  (cond ((or (and (memq current-minibuffer-command '(find-file
                                                 dired-goto-file))
                  (memq noct-selectrum-major-mode '(ranger-mode dired-mode)))
             (eq noct-selectrum-command #'projectile-find-test-file))
         (cond ((= selectrum--actual-num-candidates-displayed 0)
                (backward-delete-char-untabify 1))
               ((= selectrum--actual-num-candidates-displayed 1)
                (noct-wait-for-user 0.2)
                (ignore-errors (selectrum-select-current-candidate)))))))

(general-add-advice 'selectrum--update :after #'noct-selectrum-premature-select)
#+end_src

** Ivy
*** Setup
#+begin_src emacs-lisp
(use-package ivy
  :blackout t
  :config
  (gsetq ivy-height 25
         ivy-wrap t
         ;; wait for user to stop typing for this long before refreshing dynamic
         ;; collections
         ivy-dynamic-exhibit-delay-ms 50
         ivy-use-selectable-prompt t
         ivy-count-format "%d/%d ")
  ;; ivy-sort-functions-alist
  ;; ivy-initial-inputs-alist

  (general-def ivy-minibuffer-map
    "<escape>" #'minibuffer-keyboard-quit
    "C-w" #'evil-delete-backward-word
    "¸" #'evil-delete-backward-word
    "<next>" #'ivy-scroll-up-command
    "<prior>" #'ivy-scroll-down-command
    "C-e" #'previous-history-element
    "C-n" #'next-history-element
    "M-a" #'ivy-avy
    "M-d" #'ivy-dispatching-done
    "M-c" #'ivy-occur)

  (general-def 'normal "?" #'ivy-resume)

  (ivy-set-actions
   t
   `(("h" (lambda (x) (helpful-command (intern x))) "helpful")
     (,(kbd "RET") xref-find-definitions "follow")
     ("f" xref-find-definitions "follow"))))

;; TODO bind for more functions (e.g. not locate)
;; "<up>" #'ivy-previous-line-and-call
;; "<down>" #'ivy-next-line-and-call

;; TODO consider adding better keybindings for these:
;; ivy-call
;; ivy-dispatching-call
#+end_src

*** Ivy Occur
TODO evil bindings stop working after wgrep finish edit
#+begin_src emacs-lisp
(general-with-package 'ivy
  (general-def 'normal '(ivy-occur-mode-map ivy-occur-grep-mode-map)
    "n" #'ivy-occur-next-line
    "e" #'ivy-occur-previous-line
    "w" #'ivy-wgrep-change-to-wgrep-mode
    "RET" #'ivy-occur-press-and-switch
    ;; TODO ivy-occur-revert-buffer
    ;; ivy-occur-press
    "a" #'ivy-occur-read-action
    "o" #'ivy-occur-dispatch
    "c" #'ivy-occur-toggle-calling
    "d" #'ivy-occur-delete-candidate)

  (noct-handle-window ivy-occur-grep-mode
    '(display-buffer-same-window)))
#+end_src

*** Ivy Hydra
#+begin_src emacs-lisp
(use-package ivy-hydra
  :after ivy
  :demand t
  :config
  (general-def hydra-ivy/keymap
    "j" nil
    "k" nil
    "n" #'hydra-ivy/ivy-next-line
    "e" #'hydra-ivy/ivy-previous-line
    "<escape>" #'hydra-ivy/keyboard-escape-quit-and-exit))
#+end_src

*** Ivy Rich
#+begin_src emacs-lisp
(use-package ivy-rich
  ;; requires counsel when enabling `ivy-rich-mode'
  :after counsel
  :demand t
  :config
  ;; default `ivy-switch-buffer' is good enough; remove transformer before
  ;; enabling `ivy-rich-mode'
  (cl-remf ivy-rich-display-transformers-list 'ivy-switch-buffer)
  (ivy-rich-mode))
#+end_src

*** Ivy Posframe
#+begin_src emacs-lisp
(use-package ivy-posframe
  :disabled t
  :after ivy
  :init
  (general-after-gui
    (ivy-posframe-mode))
  (general-def noct-toggle-map "p" #'ivy-posframe-mode)
  :blackout t
  :config
  (gsetq ivy-posframe-border-width (noct-border-width)
         ;; prevent resizing as type (may need to adjust these)
         ivy-posframe-min-width 150
         ivy-posframe-width 150
         ivy-posframe-height 30
         ivy-posframe-min-height 30)

  ;; default border color
  (custom-set-faces
   '(internal-border ((t (:weight bold
                          :background "#FFFFFF")))))

  ;; TODO posframe currently requires this naming
  (defun ivy-posframe-display-at-frame-top-center (str)
    (ivy-posframe--display
     str
     #'noct-posframe-poshandler-frame-near-top-center))

  (setf (alist-get t ivy-posframe-display-functions-alist)
        #'ivy-posframe-display-at-frame-top-center)

  ;; still put swiper(-isearch) in minibuffer so buffer is visible
  ;; `counsel-fzf' because there is a ton of input if use posfame
  (dolist (cmd '(counsel-fzf
                 counsel-grep
                 lsp-find-references
                 swiper
                 swiper-isearch
                 ivy-xref-show-xrefs))
    (general-pushnew (list cmd)
                     ivy-posframe-display-functions-alist
                     :test 'equal)))
#+end_src

*** Ivy All the Icons
Add icons to ivy/counsel commands.
#+begin_src emacs-lisp
(use-package all-the-icons-ivy
  :init
  (general-after-gui
    (general-after 'ivy
      (all-the-icons-ivy-setup)))
  :config
  (general-after 'counsel-projectile
    (let ((all-the-icons-ivy-file-commands
           '(counsel-projectile
             counsel-projectile-find-file
             counsel-projectile-find-dir)))
      (all-the-icons-ivy-setup))))
#+end_src

*** Dynamically Switch Between Matching Methods
Unlike helm, ivy can't automatically do fuzzy and space as =.*= matching at the same time (see [[https://github.com/abo-abo/swiper/issues/360][this issue]]). Here is an expiremental hack for automatically switching between the two. I am not currently using this (not tangled).
#+begin_src emacs-lisp :tangle no
(general-with-package 'ivy
  ;; dosen't work
  ;; (defun ivy--regex-fuzzy-ignore-space (oldfun str)
  ;;   (funcall oldfun (replace-regexp-in-string " " "" str)))

  ;; (general-add-advice 'ivy--regex-fuzzy :around #'ivy--regex-fuzzy-ignore-space)

  (defvar noct--initial-ivy-regex-function nil)

  (defun noct-ivy-space-switch-to-regex ()
    (interactive)
    (unless (eq ivy--regex-function 'ivy--regex-ignore-order)
      (setq ivy--old-re nil)
      (setq noct--initial-ivy-regex-function ivy--regex-function)
      (setq ivy--regex-function 'ivy--regex-ignore-order))
    (self-insert-command 1))

  (general-def ivy-minibuffer-map
    "SPC" #'noct-ivy-space-switch-to-regex)

  (defun noct-ivy-maybe-reset-regex-function ()
    (interactive)
    (when (active-minibuffer-window)
      (let ((input (replace-regexp-in-string "\n.*" "" (minibuffer-contents))))
        (when (and noct--initial-ivy-regex-function
                   (not (string-match " " input)))
          (setq ivy--old-re nil)
          (setq ivy--regex-function noct--initial-ivy-regex-function)
          (setq noct--initial-ivy-regex-function nil)))))

  (general-add-advice '(ivy-backward-delete-char
                        ivy-delete-char)
                      :after #'noct-ivy-maybe-reset-regex-function))
#+end_src

*** Counsel
#+begin_src emacs-lisp
(use-package counsel
  :general
  ;; (general-t
  ;;   ;; looks nicer than helm-show-kill-ring to me
  ;;   ;; sticking with over `consult-yank' since it supports showing multi-line
  ;;   ;; text
  ;;   "p" #'counsel-yank-pop)

  ;; (general-def help-map "a" #'counsel-apropos)

  ;; (general-spc "y" #'counsel-semantic-or-imenu)

  ((insert normal) "C-:" #'counsel-minibuffer-history)

  ;; extra counsel/[i]vy commands
  (general-s :infix "i"
    "a" #'counsel-linux-app
    "o" #'counsel-outline
    "i" #'counsel-imenu
    "v" #'counsel-set-variable
    "p" #'counsel-list-processes
    "b" #'counsel-descbinds
    "d" #'counsel-dash
    ;; "l" #'counsel-load-theme
    "u" #'counsel-unicode-char
    "g" #'counsel-git-log
    "s" #'counsel-git-stash)

  ;; replace `company-search'
  (general-def company-active-map
    "C-s" #'counsel-company)

  :blackout t
  :config
  (general-after 'helpful
    ;; using this instead of binding them directly allows taking an alternate
    ;; action without also opening the helpful buffer
    (gsetq counsel-describe-function-function #'helpful-callable
           counsel-describe-variable-function #'helpful-variable)))
#+end_src

*** Counsel Buku
This is a really basic ~counsel-buku~. =buku_run= has various issues for me. I may use rofi in the future or may stick with this (see sxhkdrc for binding).
#+begin_src emacs-lisp
(defun counsel-buku-action (cand)
  "Run \"buku --open\" on CAND."
  (let ((db-index (car (split-string cand "\t"))))
    (counsel--run "buku" "--open" db-index)))

(defun counsel-buku ()
  "Open a buku bookmark."
  (interactive)
  (counsel-require-program "buku")
  (let ((cands
         (split-string
          (shell-command-to-string "buku --print --format 5")
          "\n" t)))
    (ivy-read "open bookmark: " cands
              :action #'counsel-buku-action
              :caller 'counsel-buku)))
#+end_src

** Manual Completion
#+begin_src emacs-lisp
;; used for completion in vim
(general-def 'insert "C-n" #'complete-symbol)

(general-def
  :keymaps noct-minibuffer-maps
  "C-n" #'complete-symbol)
#+end_src

** Orderless
One notable difference between using orderless (or prescient) and some older fuzzy matchers/plugins is that space does not act as =.*=. Spaces (by default) separate components, all of which must match. You can still use space the same way as before (type different parts of a file path separated by space, for example), but now order does not matter. This allows you to refine your query as needed without having to delete and re-enter a more specific query.

Unlike traditional fuzzy matchers (e.g. flx, fzf, etc.), =orderless= does no sorting. This means you can't do something like rank initials as a better match than characters in the middle of the word for a fuzzy query. However, sorting this way takes extra time, and I've never really liked fuzzy matching. When I used to use fuzzy matching, I never used to know what to type. Instead of ranking initials as higher, why not only use initials? Matching based on initials is more precise, and for me, it's actually easier for me to construct a query for a function's initials or file path's initials than to try to construct a fuzzy query in some other way.

With a more restrictive/specific query, ranking matches surprisingly isn't necessary in my experience. Combined with frecency sorting, initialism is good enough. Initialism is incredible for completing file paths, heading names, and function/variable names (~describe-variable~, ~describe-function~, ~find-function~, ~find-library~, company, etc.). With prescient or orderless, if the initialism doesn't get the candidate you want in sight, you can just hit space and add another query (regexp, fuzzy, or whatever you want) to further refine. As soon as the candidate is visible, you can use a keybinding to select it based on its index (or with something like ~ivy-avy~ or ~selectrum-quick-select~).

Of course, initialism isn't great for everything, but I've found it's often still possible to quickly create queries that are more specific than fuzzy queries but still short. For example, if I want to pull up a help buffer for a variable in =orderless= but don't remember the specific name, I can start by limiting the query to variables prefixed with =orderless=. Instead of typing that out exactly, I can get a good approximation by typing something like =o,s= (still undecided on best syntax; might use =o..s=) to match words that start with =o= and end with =s=. For commands like ~describe-function~, I normally use ~orderless-strict-leading-initialism~ since I always type the first initial first. I'm relaxing this to ~orderless-strict-initialism~ for queries after the second, so I could type something like =o..s cs= to match =orderless-component-separator=.

This can also work well for other query types where initialism is fairly useless (e.g. text search), and you can always add multiple full word queries as needed.

Even simpler is to just mash out words or partial words separated by spaces (more precise than fuzzy) in cases where initialism or orderless-prefixes can't be used. Again, if you can't quickly construct a query, then it doesn't matter how great the matching is. Dumb queries can often get you the result you want faster.

I'm keeping fuzzy out of my default styles, but I've configured things so that I can switch to it if needed by prefixing a query with =f;= or suffixing a query with =;f=. If you want fuzzy matching, orderless may not be the best choice though. I've found it can get slow quickly once queries get longer.

=orderless= is infinitely customizable, so you can choose better default query styles for different commands. If you wanted, you could remove initialism from ~swiper-isearch~ completely, for example. I'm still experimenting with how restrictive I can make things without harming usability (e.g. can I remove ~orderless-regexp~ entirely as a default style for the first component for commands like ~describe-function~?). So far it seems like I don't need to go this far and I don't need any sorting/ranking to get amazing matching.
#+begin_src emacs-lisp
(use-package orderless
  :init
  (gsetq completion-styles '(orderless)
         completion-category-defaults nil)

  (general-with 'ivy
    (setf (alist-get t ivy-re-builders-alist)
          #'orderless-ivy-re-builder)
    ;; doesn't work with `counsel-rg'
    (setf (alist-get 'counsel-rg ivy-re-builders-alist)
          #'ivy--regex-plus))

  :config
  ;; necessary at the time of writing for index-based rules to work
  (defun noct-split-orderless-component (str)
    (let ((components (split-string str "[ &]")))
      (when (remove "" components)
        components)))

  (gsetq orderless-matching-styles
         '(orderless-strict-initialism orderless-regexp)
         ;; & for company-capf
         ;; orderless-component-separator "[ &]"
         orderless-component-separator #'noct-split-orderless-component)

  (defun orderless--use-completions-common-part (fn &rest args)
    (let ((orderless-match-faces [completions-common-part]))
      (apply fn args)))

  (advice-add 'company-capf--candidates
              :around #'orderless--use-completions-common-part)

  ;; style dispatchers
  (defconst noct-regexp-to-styles-alist
    `((,(rx (or (and bol "r;")
                (and bol "regexp;")))
       orderless-regexp)
      (,(rx (or (and bol "f;")
                (and ";f" eol)))
       orderless-flex))
    "Alist of regexp to list of styles to use for an orderless component.")

  (cl-defun noct-orderless-specified-styles (pattern)
    "Return a list of styles and a PATTERN without the style specifier."
    (dolist (style-specifier noct-regexp-to-styles-alist)
      (let ((re (car style-specifier))
            (styles (cdr style-specifier)))
        (when (string-match re pattern)
          (cl-return-from noct-orderless-specified-styles
            (cons styles
                  (let ((start (match-beginning 0))
                        (end (match-end 0)))
                    (concat (substring pattern 0 start)
                            (substring pattern end)))))))))

  (defun noct-orderless-style-dispatcher (pattern &rest _)
    "Set style for PATTERN if it matches `noct-regexp-to-styles-alist'."
    (noct-orderless-specified-styles pattern))

  (defconst noct-word-dispatch-pattern (rx ",")
    "Pattern to mark a full word starting/ending with the surrounding letters.")

  (defun noct-orderless-word-dispatcher (pattern &rest _)
    "Replace `noct-word-dispatch-pattern' with regexp to pass a full word.)
The character before, if there is one, is the first character in the word. The
character after, if there is one, marks the final character in the word. For
example, if `noct-dispatch-pattern' is \"..\" then \"o..s\" would match
\"orderless\"."
    (pcase-let ((`(,styles . ,styless-pattern)
                 (noct-orderless-specified-styles pattern)))
      (setq pattern (or styless-pattern pattern))
      (when (and (or (not styles) (memq 'orderless-regexp styles))
                 (string-match noct-word-dispatch-pattern pattern))
        (let* ((start (match-beginning 0))
               (end (match-end 0))
               (left-anchor (unless (= start 0)
                              (substring pattern (1- start) start)))
               (right-anchor (unless (= end (length pattern))
                               (substring pattern end (1+ end)))))
          (cons 'orderless-regexp
                (concat
                 ;; "regexp;"
                 (if left-anchor
                     (substring pattern 0 (1- start))
                   "")
                 (rx word-start)
                 (or left-anchor "")
                 (rx (0+ word))
                 (or right-anchor "")
                 (rx word-end)
                 (if right-anchor
                     (substring pattern (1+ end))
                   "")))))))

  ;; https://github.com/oantolin/emacs-config/blob/da6b98a3343d68c02af7c05153f50cc194d46888/disabled.el#L46
  (defun oantolin-not-containing-dispatcher (literal _index &rest _)
    (when (string-prefix-p "!" literal)
      (cons
       'orderless-regexp
       (rx-to-string
        `(seq
          (group string-start)
          (zero-or-more
           (or ,@(cl-loop for i from 1 below (length literal)
                          collect `(seq ,(substring literal 1 i)
                                        (or (not ,(aref literal i))
                                            string-end)))))
          string-end)))))

  (defconst noct-strict-leading-initialism-commands
    '(apropos-library
      consult-theme
      counsel-set-variable
      describe-command
      describe-face
      describe-function
      describe-keymap
      describe-package
      describe-theme
      describe-variable
      execute-extended-command
      embark-prefix-help-command
      find-function
      find-library
      helpful-callable
      helpful-symbol
      helpful-variable
      Info-goto-emacs-command-node
      info-lookup-symbol
      noct-xref-find-definition
      straight-pull-package
      straight-pull-package-and-deps
      straight-rebuild-package
      straight-use-package
      where-is
      woman)
    "Commands to use `orderless-strict-leading-initialism' for at index 0.")

  ;; TODO re-evaluate what index-based rules would be useful
  (defun noct-orderless-command-and-index-dispatcher (pattern index &rest _)
    "Change the default styles for PATTERN based on `this-command' and INDEX.
Increase strictness to `orderless-strict-leading-initialism' at index 0 for
certain commands (help commands like `describe-function' but not for
file-finding commands)."
    (when (and (= index 0)
               (memq current-minibuffer-command
                     noct-strict-leading-initialism-commands))
      (cons '(orderless-strict-leading-initialism orderless-regexp)
            pattern)))

  (gsetq orderless-style-dispatchers
         (list #'noct-orderless-word-dispatcher
               ;; #'noct-orderless-style-dispatcher
               #'oantolin-not-containing-dispatcher
               #'noct-orderless-command-and-index-dispatcher)))
#+end_src

** Prescient
#+begin_src emacs-lisp
(use-package prescient
  :config
  ;; increase from 100
  (gsetq prescient-history-length 500)

  ;; persist usage statistics
  (prescient-persist-mode))

(use-package company-prescient
  :after company
  :demand t
  :config
  ;; use prescient sorting for company
  (company-prescient-mode))

(use-package ivy-prescient
  :after ivy
  :demand t
  :config
  ;; use prescient only for sorting
  (gsetq ivy-prescient-enable-filtering nil
         ivy-prescient-sort-commands
         ;; add `counsel-grep', `counsel-yank-pop', etc.
         '(:not swiper swiper-isearch counsel-yank-pop
           counsel-grep counsel-outline worf-goto counsel-org-goto
           counsel-semantic-or-imenu counsel-rg
           consult-line consult-imenu consult-yank-from-kill-ring
           consult-ripgrep consult-org-heading consult-compile-error
           consult-flycheck affe-grep))
  (ivy-prescient-mode))
#+end_src

** Restricto
#+begin_src emacs-lisp
(use-package restricto
  :straight (restricto :host github :repo "oantolin/restricto")
  :general ('insert minibuffer-completion-map "S-SPC" #'restricto-narrow))
#+end_src

** Selectrum
#+begin_src emacs-lisp
(use-package selectrum
  :init
  ;; this doesn't actually load selectrum (definition is in autoload file)
  (selectrum-mode)
  :config
  (gsetq selectrum-show-indices t
         selectrum-num-candidates-displayed 20
         ;; TODO async consult commands don't show full candidates without
         selectrum-max-window-height 30
         ;; TODO this doesn't seem necessary anymore to prevent height from
         ;; changing?!
         ;; selectrum-fix-vertical-window-height t
         ;; selectrum-multiline-display-settings
         selectrum-count-style 'current/matches)

  ;; only highlight visible candidates; performance improvement (both settings
  ;; required)
  (gsetq selectrum-highlight-candidates-function #'orderless-highlight-matches)
  (general-with 'orderless
    (gsetq orderless-skip-highlighting (lambda () selectrum-is-active)))

  (general-s "." #'selectrum-repeat)

  (general-def selectrum-minibuffer-map
    "<prior>" #'selectrum-previous-page
    "<next>" #'selectrum-next-page
    "C-s" #'selectrum-select-from-history
    ;; all of these are useless or superseded by other keybindings except for
    ;; maybe M-s and M-r
    "M-a" (general-l (selectrum-select-current-candidate 1))
    "M-r" (general-l (selectrum-select-current-candidate 2))
    "M-s" (general-l (selectrum-select-current-candidate 3))
    "M-t" (general-l (selectrum-select-current-candidate 4))
    "M-d" (general-l (selectrum-select-current-candidate 5))
    "M-h" (general-l (selectrum-select-current-candidate 6))
    "M-n" (general-l (selectrum-select-current-candidate 7))
    "M-e" (general-l (selectrum-select-current-candidate 8))
    "M-i" (general-l (selectrum-select-current-candidate 9))
    "M-o" (general-l (selectrum-select-current-candidate 10)))

  (defun clemera--selectrum-selectable-prompt-p ()
    (not (and (selectrum--match-strictly-required-p)
              (cond (minibuffer-completing-file-name
                     (not (selectrum--at-existing-prompt-path-p))
                     (t
                      (not (string-empty-p selectrum--virtual-input))))))))

  (defun clemera-selectrum-next-candidate (&optional arg)
    "`selectrum-next-candidate' but with wrapping.
https://github.com/raxod502/selectrum/issues/131#issuecomment-817191700"
    (interactive "p")
    (when selectrum--current-candidate-index
      (let ((selectable-prompt
             (clemera--selectrum-selectable-prompt-p))
            (index (+ selectrum--current-candidate-index (or arg 1)))
            (max (1- (length selectrum--refined-candidates))))
        (setq selectrum--current-candidate-index
              (cond ((< index (if selectable-prompt -1 0))
                     max)
                    ((> index max)
                     (if selectable-prompt -1 0))
                    (t
                     index))))))

  (general-add-advice 'selectrum-next-candidate
                      :override #'clemera-selectrum-next-candidate)

  ;; TODO some way to not use for specific commands (e.g. `consult-line') or use
  ;; `mini-frame' if it becomes less glitchy
  ;; would be better to keep everything in minibuffer but have it at top instead
  ;; of bottom
  ;; (gsetq selectrum-display-action '(display-buffer-show-in-posframe))

  ;; (defun display-buffer-show-in-posframe (buffer _alist)
  ;;   (frame-root-window
  ;;    (posframe-show buffer
  ;;                   :min-height selectrum-num-candidates-displayed
  ;;                   :min-width (round (* 0.6 (frame-width)))
  ;;                   :internal-border-width 1
  ;;                   :left-fringe 8
  ;;                   :right-fringe 8
  ;;                   :poshandler 'noct-posframe-poshandler-frame-near-top-center)))

  ;; (general-add-hook 'minibuffer-exit-hook #'posframe-delete-all)

  ;; show in top window
  ;; minibuffer just looks better
  ;; (gsetq selectrum-display-action
  ;;        '((noct-display-buffer-reuse-window
  ;;           noct-display-buffer-in-side-window)
  ;;          (side . top)
  ;;          (slot)
  ;;          (window-height . 0.5)))
  )

(use-package selectrum-prescient
  :after selectrum
  :demand t
  :config
  (gsetq selectrum-prescient-enable-filtering nil)
  (selectrum-prescient-mode))
#+end_src

** Vertico
#+begin_src emacs-lisp
(use-package vertico
  ;; specify to get extensions
  :straight (vertico-extensions
             :host github
             :repo "minad/vertico"
             :files ("*.el" "extensions/*.el"))
  :config
  (vertico-mode)

  (gsetq vertico-count 20
         vertico-cycle t)
  ;; necessary for tramp hostname completion when using orderless
  (gsetq completion-category-overrides
         '((file (styles basic partial-completion))))

  ;; Use `consult-completion-in-region' if Vertico is enabled.
  ;; Otherwise use the default `completion--in-region' function.
  (setq completion-in-region-function
        (noct-defun minad-completion-in-region-function (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))

  (general-s "." #'vertico-repeat)

  (vertico-indexed-mode))
#+end_src

** Consult
#+begin_src emacs-lisp
(use-package consult
  :general
  (general-spc
    "f" #'consult-buffer
    ;; generally `projectile-find-file' is a better option
    "k" #'noct-consult-find-fd
    "l" #'consult-locate
    "u" (list :def #'consult-outline :jump t)
    "y" (general-predicate-dispatch #'consult-imenu
          (eq major-mode 'org-mode) #'consult-org-heading)
    ;; works inside or outside project already
    "/" #'consult-ripgrep)
  (general-t "p" #'consult-yank-from-kill-ring)
  (general-s :infix "i" "l" #'consult-theme)
  (general-m "C" #'consult-compile-error)
  (help-map "a" #'consult-apropos)
  ('normal "/" (list :def (if (or (not (boundp 'no-native-compile))
                                  (not no-native-compile))
                              #'consult-line
                            #'noct-consult-ripgrep-or-line)
                     :jump t))
  :config
  ;; TODO move this somewhere else
  (gsetq org-imenu-depth 10)

  (gsetq consult-buffer-sources
         (remove 'consult--source-bookmark consult-buffer-sources)
         consult-preview-key '(:debounce 0.1 any))

  (general-after 'projectile
    ;; will cause `consult-ripgrep' and similar to use project root
    (gsetq consult-project-root-function #'projectile-project-root))

  (gsetq xref-show-xrefs-function #'consult-xref
         xref-show-definitions-function #'consult-xref)

  (evil-add-command-properties #'consult-imenu :jump t)
  (evil-add-command-properties #'consult-org-heading :jump t)

  (defconst noct-ripgrep-args
    (concat "rg "
            ;; defaults
            "--line-buffered "
            "--color=never "
            "--max-columns=1000 "
            "--path-separator / `"
            "--smart-case "
            "--no-heading "
            "--line-number "
            ;; adding these to default
            "--hidden "
            "--no-ignore "
            "--max-columns-preview "))
  (gsetq consult-ripgrep-args (concat noct-ripgrep-args "."))

  (defun noct-consult-find-fd (&optional dir initial)
    "Run `consult-find' using fd."
    (interactive "P")
    (let ((consult-find-command
           (concat "fd --hidden --no-ignore --exclude .git --color=never "
                   "--full-path ARG OPTS")))
      (consult-find dir initial)))

  (defcustom noct-consult-ripgrep-or-line-limit 1000000
    "Buffer size threshold for `noct-consult-ripgrep-or-line'.
When the number of characters in a buffer exceeds this threshold,
`consult-ripgrep' will be used instead of `consult-line'."
    :type 'integer)

  (defun noct-consult-ripgrep-or-line ()
    "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
    (interactive)
    (if (or (not buffer-file-name)
            (buffer-narrowed-p)
            (ignore-errors
              (file-remote-p buffer-file-name))
            (jka-compr-get-compression-info buffer-file-name)
            (<= (buffer-size)
                (/ noct-consult-ripgrep-or-line-limit
                   (if (eq major-mode 'org-mode) 4 1))))
        (consult-line)
      (when (file-writable-p buffer-file-name)
        (save-buffer))
      (let ((consult-ripgrep-command
             (concat noct-ripgrep-args
                     ;; add back filename to get parsing to work
                     "--with-filename "
                     ".")))
        (consult-ripgrep))))

  (general-advice-add #'completing-read-multiple
                      :override #'consult-completing-read-multiple)

  (defun noct-consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (let ((pattern (car (orderless-pattern-compiler
                           (car consult--line-history)))))
        (add-to-history 'evil-ex-search-history pattern)
        (setq evil-ex-search-pattern (list pattern t t))
        (setq evil-ex-search-direction 'forward)
        (when evil-ex-search-persistent-highlight
          (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

  (general-add-advice #'consult-line :after #'noct-consult-line-evil-history))

(use-package consult-flycheck
  :general
  (general-m "f" #'consult-flycheck))
#+end_src

** Embark
#+begin_src emacs-lisp
(use-package embark
  :general
  (:keymaps noct-minibuffer-maps
   "M-x" #'embark-export
   "M-c" #'embark-act
   "C-l" #'embark-become)
  :config
  ;; after prefix, press `C-h' to get completing read interface for keybindings
  ;; for that prefix
  (gsetq prefix-help-command #'embark-prefix-help-command)

  (gsetq embark-cycle-key (kbd "C-n"))

  (general-after 'selectrum
    ;; refresh candidate list after action
    (defun embark-wiki-refresh-selectrum ()
      (setq selectrum--previous-input-string nil))

    (general-add-hook 'embark-pre-action-hook #'embark-wiki-refresh-selectrum))

  (general-def embark-general-map "y" #'kill-new)

  (general-def embark-identifier-map "f" #'xref-find-definitions)

  (general-def embark-symbol-map "h" #'helpful-symbol)

  (general-def embark-command-map "h" #'helpful-command)

  (general-def embark-variable-map "h" #'helpful-variable)

  (general-def 'normal embark-collect-mode-map
    "w" #'wgrep-change-to-wgrep-mode
    "RET" #'embark-act)

  (general-def embark-become-file+buffer-map
    "c" #'projectile-switch-project
    "l" #'consult-locate
    "f" #'noct-consult-find-fd
    "p" #'projectile-find-file-in-known-projects
    ;; probably would have used first so giving worse keybinding
    "P" #'projectile-find-file
    ;; so detected
    "b" #'consult-buffer)

  (noct-handle-popup (rx "*Embark Actions*"))
  ;; automatically show available actions with which-key
  ;; (general-after 'which-key
  ;;   (gsetq embark-action-indicator
  ;;          (lambda (map &rest _)
  ;;            (which-key--show-keymap "Embark" map nil nil 'no-paging)
  ;;            #'which-key--hide-popup-ignore-command)
  ;;          embark-become-indicator embark-action-indicator))

  (noct-handle-window (rx "*Embark Collect" (0+ any))
    '(display-buffer-same-window)))

;; (use-package embark-consult
;;   :after (embark consult)
;;   :demand t
;;   ;; if you want to have consult previews as you move around an
;;   ;; auto-updating embark collect buffer
;;   :ghook
;;   ('embark-collect-mode-hook #'embark-consult-preview-minor-mode))
#+end_src

** Marginalia
Sets missing metadata for completions (pairs well with embark even if not using ~marginalia-mode~).

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :straight (all-the-icons-completion
             :host github
             :repo "iyefrat/all-the-icons-completion")
  :ghook
  ('marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))

(use-package marginalia
  :after selectrum
  :demand t
  :config
  (marginalia-mode)
  (general-pushnew '(projectile-find-file . project-file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-find-file-in-known-projects . file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-find-dir . file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-switch-project . file)
                   marginalia-command-categories)
  (general-pushnew '(noct-projectile-switch-and-vc . file)
                   marginalia-command-categories)
  ;; needed for `projectile-find-file' after `projectile-switch-project' to work
  (general-pushnew '("Find file:" . file)
                   marginalia-prompt-categories))
#+end_src

** Wgrep
#+begin_src emacs-lisp
(use-package wgrep
  ;; necessary to create autoload
  :general
  (general-def grep-mode-map "w" #'wgrep-change-to-wgrep-mode)
  :config
  (general-def 'normal wgrep-mode-map
    "RET" #'wgrep-finish-edit))
#+end_src

* Group/Session Management/Navigation
** Framegroups
#+begin_src emacs-lisp
(use-package framegroups
  :straight (framegroups
             :host github
             :repo "noctuid/framegroups.el"
             :protocol ssh
             :local-repo "~/src/emacs/framegroups")
  :general
  ;; TODO bind globally on middle mouse on primary computer
  (general-spc
    "," #'noct-framegroup-setup
    ;; "l" #'fg-switch-to-last-frame
    "a" (noct-c (fg-switch-to-frame "emacs"))
    "r" (noct-c (fg-switch-to-frame "log"))
    "s" (noct-c (fg-switch-to-frame "notes"))
    "t" (noct-c (fg-switch-to-frame "prog"))
    "d" (noct-c (fg-switch-to-frame "config"))
    "h" (noct-c (fg-switch-to-frame "blog"))
    "n" (noct-c (fg-switch-to-frame "wr"))
    "e" (noct-c (fg-switch-to-frame "cons"))
    "i" (noct-c (fg-switch-to-frame "mail"))
    "o" (noct-c (fg-switch-to-frame "music")))
  :config
  (defun noct-framegroup-setup (name &rest _)
    "Set up main framegroups."
    (interactive)
    (pcase name
      ;; emacs configuration
      ("emacs"
       (find-file (expand-file-name "awaken.org"  user-emacs-directory)))
      ;; org agenda/todo
      ("log"
       (find-file "~/ag-sys/notes/log.org"))
      ;; programming and personal notes
      ("notes"
       (find-file "~/ag-sys/notes/life.org"))
      ;; programming projects
      ("prog"
       (find-file "~/src"))
      ;; dotfiles
      ("config"
       (find-file "~/.profile"))
      ;; blog
      ("blog"
       (find-file (getenv "BLOG")))
      ;; writing
      ("wr"
       (find-file "~/ag-sys/else/scrawl/prose/tr/"))
      ;; ebooks and more notes
      ("cons"
       (find-file "~/ag-sys/else/consume/books.org"))
      ("mail"
       (mu4e))
      ("music"
       (mingus))))

  (general-add-hook 'fg-create-hook #'noct-framegroup-setup))
#+end_src

** TODO Tab Bar Mode
- ~tab-bar-history-mode~ as replacement for ~winner~?
- need to add helpers for naming; not very usable out of the box

** TODO Desktop.el
start recentf desktop-after-read-hook
#+begin_src emacs-lisp
;; TODO desktop isn't a package; this is in loaddefs
(use-package destkop
  :disabled t
  :straight (:type built-in)
  :init (desktop-save-mode)
  :config
  (gsetq desktop-restore-frames nil)

  (general-pushnew 'evil-markers-alist desktop-locals-to-save)

  (desktop-auto-save-set-timer))
#+end_src

** Navigation Quickmarks
*** Quickmark Helpers
#+begin_src emacs-lisp
(defmacro noct-find-file (filename)
  "Create and return named function to visit FILENAME."
  `(noct-defun ,(intern (format "noct-quickmark-find-%s"
                                (if (stringp filename)
                                    filename
                                  (cl-gensym)))) ()
     ,(format "Call `find-file' on %s." filename)
     (interactive)
     (find-file ,filename)))


(defun noct-goto-fuzzy (name)
  "Goto the shortest filename in the root of the project that starts with NAME.
NAME should be lowercase as the uppercase version will also be checked."
  (interactive)
  (require 'projectile nil t)
  (let* ((project-root (or (ignore-errors (projectile-project-root))
                           default-directory))
         (files (or (file-expand-wildcards (concat project-root name "*"))
                    (file-expand-wildcards (concat project-root (upcase name)
                                                   "*")))))
    (when files
      (find-file (car (sort files
                            (lambda (x y)
                              (< (length x) (length y)))))))))

(defun noct-goto-makefile ()
  (interactive)
  (noct-goto-fuzzy "makefile"))

(defun noct-goto-todo ()
  (interactive)
  (noct-goto-fuzzy "todo"))

(defun noct-goto-readme ()
  (interactive)
  (noct-goto-fuzzy "readme"))

;; `view-echo-area-messages' but in current buffer
(defun noct-goto-messages ()
  (interactive)
  (switch-to-buffer "*Messages*"))

(defun noct-goto-backtrace ()
  (interactive)
  (switch-to-buffer "*Backtrace*"))

(defun noct-goto-main ()
  "Go to the shortest filename named the same as the project root dirname.
If projectile is not installed, the current directory's name is used instead.
Globbing is used to find a matching file."
  (interactive)
  (require 'projectile nil t)
  (let ((dir-name
         (file-name-nondirectory
          (directory-file-name
           (file-name-directory
            (or (ignore-errors (projectile-project-root))
                default-directory))))))
    (noct-goto-fuzzy dir-name)))
#+end_src

*** General Quickmarks
#+begin_src emacs-lisp
(defun noct-bind-general-quickmarks (&rest _)
  (general-comma
    "e" (noct-find-file (expand-file-name "awaken.org" user-emacs-directory))
    "v" (noct-find-file "~/.config/mpv/history.log")
    "V" (noct-find-file "~/.config/nvim/init.vim")
    "2" (noct-find-file "~/ag-sys/notes/20xx.org")))

(noct-bind-general-quickmarks)
#+end_src

*** Group-specific Quickmarks
#+begin_src emacs-lisp
;; TODO consider removing this pattern
;; [f]irst, [s]econd, [t]hird for most used files
(defun noct-bind-group-quickmarks (name &rest _)
  (pcase name
    ("emacs"
     (general-comma
       "," (noct-find-file (expand-file-name "init.el" user-emacs-directory))
       "f" (noct-find-file (expand-file-name "awaken.org" user-emacs-directory))
       "s" (noct-find-file (expand-file-name "unclean.org" user-emacs-directory))
       "t" (noct-find-file (expand-file-name "todo.org" user-emacs-directory))
       "T" (noct-find-file "~/test-emacs/.emacs.d/init.el")))
    ;; "log"
    ("notes"
     (general-comma
       "," (noct-find-file "~/ag-sys/notes/20xx.org")
       "f" (noct-find-file "~/ag-sys/notes/20xx.org")
       "s" (noct-find-file "~/ag-sys/else/interaction.org")
       "t" (noct-find-file "~/ag-sys/else/workflow.org")))
    ("prog"
     (general-comma
       "," #'noct-goto-main
       "r" #'noct-goto-readme
       "t" #'noct-goto-todo
       "T" #'projectile-find-test-file
       "m" #'noct-goto-makefile
       "p" (general-l
             (eww-open-file
              "~/database/library/programming/common_lisp/pcl_html/index.html"))
       "l"
       (general-l
         (eww-open-file
          "~/database/library/programming/common_lisp/minispec/html/index.html"))))
    ("config"
     (general-comma
       "," (noct-find-file "~/dotfiles/README.org")
       "r" (noct-find-file "~/dotfiles/remap/README.org")
       ;; TODO
       ;; "e" (noct-find-file "~/dotfiles/editing.org")
       "b" (noct-find-file "~/dotfiles/browsing/README.org")))
    ("blog"
     (general-comma
       ;; create post
       "," (noct-defun noct-create-blog-post ()
             (interactive)
             (find-file
              (expand-file-name
               (format "content-org/%s"
                       (read-from-minibuffer "Post file name: "))
               (getenv "BLOG"))))))
    ("wr"
     (general-comma
       "," (noct-find-file "~/ag-sys/else/scrawl/prose/notes/standards+procedure.org")
       "p" (noct-find-file "plot.org")
       "f" (noct-find-file "~/ag-sys/else/scrawl/prose/tr/")
       "t" (noct-find-file "~/ag-sys/else/scrawl/prose/pots/misc.org")
       "w" (noct-find-file "world.org")
       "m" (noct-find-file "misc.org")
       "b" (noct-find-file "bio.org")
       "d" (noct-find-file "draft.org")
       "i" (noct-find-file "~/ag-sys/else/scrawl/general/ideas.org")
       "c" (noct-find-file "~/ag-sys/else/scrawl/prose/lndn/landon.org")
       "g" (noct-find-file "~/ag-sys/else/scrawl/prose/gen_misc.org")))
    ("cons"
     (general-comma
       "f" (noct-find-file "~/ag-sys/else/consume/books.org")
       "s" (noct-find-file "~/ag-sys/else/consume/nim.org")
       "t" (noct-find-file "~/ag-sys/else/consume/movies.org")
       "m" (noct-find-file "~/ag-sys/else/consume/music.org")))))
#+end_src

*** Hook
#+begin_src emacs-lisp
(when noct-personal-computer-p
  (general-with-package 'framegroups
    (general-add-hook '(fg-create-hook fg-after-switch-hook)
                      (list #'noct-bind-general-quickmarks
                            #'noct-bind-group-quickmarks)
                      t)))
#+end_src

* Window Management/Navigation
** Ace Window
I generally only use two windows in a frame, but once I start pulling up help buffers, magit status, etc., this can be useful. It also replaces ~other-window~, so it's nice for two windows as well.
#+begin_src emacs-lisp
(use-package ace-window
  :general (general-t "w" #'ace-window)
  :config
  (gsetq aw-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o)
         aw-scope 'frame))
#+end_src

** Window Splitting/Movement Keybindings
#+begin_src emacs-lisp
(defun noct-kill-buffer-delete-window ()
  "Kill the current buffer and then delete the current window."
  (interactive)
  (noct-kill-this-buffer)
  (delete-window))

(defun noct-vsplit ()
  "Vertically split window and switch to new window."
  (interactive)
  (split-window-vertically)
  (other-window 1))

(defun noct-hsplit ()
  "Horizontally split window and switch to new window."
  (interactive)
  (split-window-horizontally)
  (other-window 1))

(general-t
  "q" #'delete-window
  "d" #'delete-window
  "k" #'noct-kill-this-buffer
  "D" #'noct-kill-buffer-delete-window
  "-" #'noct-vsplit
  "'" #'noct-hsplit)

(defun noct-zoom-win ()
  "Toggle making the current window the only one."
  (interactive)
  (if (= (count-windows) 1)
      (winner-undo)
    (delete-other-windows)))

(general-t
  "h" #'windmove-left
  "n" #'windmove-down
  "e" #'windmove-up
  "i" #'windmove-right
  "z" #'noct-zoom-win)
#+end_src

** Window Too Small For Splitting Fix
See [[https://github.com/rnkn/olivetti/issues/12][here]].
#+begin_src emacs-lisp
(defun rnkn-split-window-right-ignore (&optional size)
  (if (car size) size (list (/ (window-total-width) 2))))

(general-add-advice 'split-window-right
                    :filter-args #'rnkn-split-window-right-ignore)
#+end_src

** Winner
#+begin_src emacs-lisp
(use-package winner
  :init
  (noct-after-window (winner-mode))
  :config
  (general-t
    "l" #'winner-undo
    "L" #'winner-redo))
#+end_src

** Zoom
I still need to work on my configuration for this. See [[https://github.com/cyrus-and/zoom/issues/17][this issue]] for information on using fixed-sized windows with zoom (there is no perfect solution, and it looks like it would be very difficult to support).
#+begin_src emacs-lisp
(use-package zoom
  :general
  (noct-toggle-map "z" #'zoom-mode)
  (general-t
    "t" #'zoom
    "a" #'balance-windows)
  ;; :init
  ;; (zoom-mode)
  :blackout " ⊞"
  :config
  (gsetq zoom-size '(0.618 . 0.618)))
#+end_src

* Buffer Management/Navigation
** Counsel/Swiper/Ivy
It's a bit hard to decide how to organize counsel, ivy, and swiper since they're all intertwined. I previously had all counsel and ivy configuration together, but I've split them into multiple use-package expression and put the buffer/file related configuration here.

*** Setup
#+begin_src emacs-lisp
(use-package ivy
  ;; it would make more sense for this to be in counsel
  ;; :general (general-spc "f" #'ivy-switch-buffer)
  :config
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’
  (gsetq ivy-use-virtual-buffers t
         ivy-virtual-abbreviate 'full))

(use-package swiper
  :general
  (general-def "C-s" #'swiper-isearch)
  :config
  (gsetq swiper-goto-start-of-match t))

;; `counsel-mode' is enabled in previous counsel use-package expression
;; (use-package counsel
;;   :general
;;   ('normal "/" #'counsel-grep-or-swiper)
;;   (general-spc "l" #'counsel-locate))
#+end_src

*** Locate/Find/FD/FZF
#+begin_src emacs-lisp
(use-package counsel
  :general
  (general-spc
    "z" #'noct-ripgrep-fzf
    "Z" #'noct-fd-fzf)
  :config
  (defun noct-fd-fzf (&optional initial-input)
    "Run `counsel-fzf' using fd as fzf's default command."
    (interactive)
    (noct-letenv (("FZF_DEFAULT_COMMAND"
                   "fd --hidden --no-ignore --exclude .git"))
      (counsel-fzf initial-input)))

  ;; have heard some people say ripgrep is faster than fd for files; haven't
  ;; really tried enough to compare
  (defun noct-ripgrep-fzf (&optional initial-input)
    "Run `counsel-fzf' using ripgrep as fzf's default command."
    (interactive)
    (noct-letenv (("FZF_DEFAULT_COMMAND"
                   "rg --files --no-ignore --hidden --follow --glob '!.git'"))
      (counsel-fzf initial-input)))

  (defun noct-ivy-switch-to-locate ()
    "Switch to using locate, preserving the current input.
Requires lexical binding."
    (interactive)
    (let ((input (ivy--input)))
      (ivy-quit-and-run (counsel-locate input))))

  (defun noct-ivy-switch-to-fzf ()
    "Switch to using fzf, preserving the current input."
    (interactive)
    (let ((input (ivy--input)))
      (ivy-quit-and-run (noct-ripgrep-fzf input))))

  (general-def ivy-switch-buffer-map
    "C-l" #'noct-ivy-switch-to-locate
    "C-f" #'noct-ivy-switch-to-fzf))
#+end_src

*** TODO Counsel Grep
Configure ~counsel-grep~ to go to the end of matches and integrate with evil.

TODO: This should be in counsel (variable to jump to match end and evil integration that's already done for swiper).
#+begin_src emacs-lisp
(general-with-package 'counsel
  (let ((rg-flags (concat
                   "--max-columns 200 "
                   "--max-columns-preview "
                   "--hidden "
                   "--no-heading "
                   "--smart-case "
                   "--line-number "
                   "--color never ")))
    (gsetq counsel-grep-base-command (concat "rg " rg-flags "%s %s")
           ;; TODO it would be way better if ripgrep supported trimming the line
           ;; don't quote %s (breaks regex)
           counsel-rg-base-command (concat "rg " rg-flags "%s .")))

  (defun noct-match-beginning ()
    "Go to the beginning of the last match."
    (when-let ((beg (match-beginning 0)))
      (goto-char beg)))

  ;; swiper does these but counsel-grep doesn't
  (defun noct-add-ivy-text-to-history ()
    "Add the last ivy search to `regexp-search-ring'."
    (add-to-history
     'regexp-search-ring
     (ivy--regex ivy-text)
     regexp-search-ring-max))

  (defun noct-evil-search-action ()
    "Update evil search information based on last ivy search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (add-to-history 'evil-ex-search-history ivy-text)
      (setq evil-ex-search-pattern (list ivy-text t t))
      (setq evil-ex-search-direction 'forward)
      (when evil-ex-search-persistent-highlight
        (evil-ex-search-activate-highlight evil-ex-search-pattern))))


  (general-add-hook 'counsel-grep-post-action-hook (list
                                                    #'noct-match-beginning
                                                    #'noct-add-ivy-text-to-history
                                                    #'noct-evil-search-action)))
#+end_src

** Better Jumper
I prefer to have a buffer-local jumplist and use a separate key for ~winner-undo~ to switch between previously displayed windows/buffers.
#+begin_src emacs-lisp
(use-package better-jumper
  :ghook ('pre-command-hook nil nil nil t)
  :general
  (general-def
    [remap evil-jump-forward] #'better-jumper-jump-forward
    [remap evil-jump-backward] #'better-jumper-jump-backward)
  :config
  (gsetq better-jumper-context 'buffer))
#+end_src


** Deadgrep
#+begin_src emacs-lisp
(use-package deadgrep
  :general (general-t "/" #'deadgrep)
  :init
  (gsetq smart-jump-find-references-fallback-function
         #'noct-deadgrep-current)
  :config
  (defun noct-deadgrep-current ()
    "Run `deadgrep' with the current selection or symbol at point."
    (interactive)
    (deadgrep (cond ((use-region-p)
                     (buffer-substring-no-properties (region-beginning)
                                                     (region-end)))
                    ((symbol-at-point)
                     (substring-no-properties
                      (symbol-name (symbol-at-point)))))))

  ;; ~/src/forks/evil-collection/evil-collection-deadgrep.el
  (evil-collection-init 'deadgrep))
#+end_src

** Frog Jump Buffer
Useful if constantly switching between only a few files in a project. I don't normally don't keep more than 2 file-visiting buffers open in a frame, so this is useful if I'm working in a project where I'm switching between 5 or so buffers (more than that and it becomes less useful). It can be slightly faster (and definitely less keystrokes) than projectile.
#+begin_src emacs-lisp
(use-package frog-jump-buffer
  :general (general-spc "g" #'frog-jump-buffer)
  :config
  (gsetq frog-jump-buffer-include-current-buffer nil
         frog-jump-buffer-posframe-handler
         #'noct-posframe-poshandler-frame-near-top-center))
#+end_src

** Ibuffer
*** Setup
#+begin_src emacs-lisp
(use-package ibuffer
  :general
  (general-s "b" #'ibuffer))
#+end_src

*** All the Icons Ibuffer
#+begin_src emacs-lisp
(use-package all-the-icons-ibuffer
  :ghook ('ibuffer-mode-hook nil nil nil t))
#+end_src

** Outline/Outshine
#+begin_src emacs-lisp
(use-package outline
  :ghook ('(prog-mode-hook conf-mode-hook) #'outline-minor-mode)
  :blackout outline-minor-mode
  :config
  (general-def 'normal outline-minor-mode-map
    "H" (general-l (outline-back-to-heading))
    "TAB" #'outline-toggle-children))

(use-package outshine
  :blackout t
  :ghook 'outline-minor-mode-hook)
#+end_src

** Projectile
Alternatively, there is the builtin ~project-find-file~, [[https://github.com/technomancy/find-file-in-project][find-file-in-project]], and [[https://github.com/h/find-file-in-repository][find-file-in-repository]]. Projectile has a lot of other useful commands though.

#+begin_src emacs-lisp
(use-package projectile
  :general
  (general-spc
    "p" #'projectile-find-file
    "P" #'projectile-find-file-in-known-projects
    "c" #'projectile-switch-project
    "C" #'noct-switch-to-project-root
    "v" #'noct-projectile-switch-and-vc
    "-" #'projectile-dired
    "D" #'projectile-find-dir
    "RET" #'projectile-find-tag)
  (general-t
    "S" #'projectile-replace
    "T" #'projectile-test-project)
  :init
  ;; this allows using `xref-find-references' without typing directory
  (defun noct-projectile-try (dir)
    "Function for `project-find-functions' using projectile."
    (when (require 'projectile nil t)
      (when-let ((root (projectile-project-root dir)))
        (cons 'transient root))))

  (general-with 'project
    (general-pushnew #'noct-projectile-try project-find-functions))
  :blackout t
  :config
  (gsetq projectile-enable-caching t
         projectile-project-test-cmd "make test"
         projectile-completion-system 'default
         projectile-project-search-path '("~/src"))

  (defun noct-switch-to-project-root ()
    (interactive)
    (let ((projectile-switch-project-action 'projectile-dired))
      (call-interactively #'projectile-switch-project)))

  (defun noct-projectile-switch-and-vc ()
    "Switch project and run `projectile-vc'"
    (interactive)
    (let ((projectile-switch-project-action 'projectile-vc))
      (call-interactively #'projectile-switch-project)))

  (projectile-mode)

  (projectile-cleanup-known-projects)

  (projectile-register-project-type
   'emacs '("Cask")
   :compile "make compile"
   :test "make test"
   :test-prefix "test-"
   :test-suffix ".el"))
#+end_src

* UI/Appearance/Visual/Formatting
** Adaptive Wrap
This package, for example, will visually indent soft-wrapped lines that are bullet points.
#+begin_src emacs-lisp
(use-package adaptive-wrap
  :ghook ('text-mode-hook #'adaptive-wrap-prefix-mode)
  :general (general-def noct-toggle-map "A" #'adaptive-wrap-prefix-mode))
#+end_src

** All the Icons
A helper library for inserting icons (used by other packages in my config).
#+begin_src emacs-lisp
(use-package all-the-icons
  :init
  (defun all-the-icons-maybe-install-fonts ()
    "Install fonts for all the icons if they have not been installed."
    ;; workaround for this functionality not being included by default
    ;; https://github.com/domtronn/all-the-icons.el/issues/120
    (when (and (display-graphic-p)
               (not (find-font (font-spec :name "all-the-icons"))))
      (all-the-icons-install-fonts t)))
  (general-after-gui
    (all-the-icons-maybe-install-fonts))
  :config
  ;; prevent breakage in tty
  ;; https://github.com/hlissner/doom-emacs/blob/29e4719a7d3c9991445be63e755e0cb31fd4fd00/core/core-ui.el#L479
  (cond
   ((daemonp)
    (defun doom--conditionally-disable-all-the-icons-in-tty-a
        (orig-fn &rest args)
      "Return a blank string in tty Emacs which doesn't support multiple fonts."
      (if (or (not after-init-time) (display-multi-font-p))
          (apply orig-fn args)
        ""))
    (general-add-advice
     '(all-the-icons-octicon
       all-the-icons-material
       all-the-icons-faicon all-the-icons-fileicon
       all-the-icons-wicon all-the-icons-alltheicon)
     :around #'doom--conditionally-disable-all-the-icons-in-tty-a))
   ((not (display-graphic-p))
    (defun doom--disable-all-the-icons-in-tty-a (&rest _)
      "Return a blank string for tty users."
      "")
    (general-add-advice
     '(all-the-icons-octicon
       all-the-icons-material
       all-the-icons-faicon all-the-icons-fileicon
       all-the-icons-wicon all-the-icons-alltheicon)
     :override #'doom--disable-all-the-icons-in-tty-a))))
#+end_src

** Builtin Line Numbers
#+begin_src emacs-lisp
(gsetq-default display-line-numbers 'visual
               display-line-numbers-widen t
               ;; this is the minimum
               display-line-numbers-width 3
               ;; default
               display-line-numbers-current-absolute t)

;; (defun noct-maybe-disable-absolute-current ()
;;   (when (> (count-lines (point-min) (point-max)) 9999)
;;     (setq-local display-line-numbers-current-absolute nil)))
;; (general-add-hook 'find-file-hook #'noct-maybe-disable-absolute-current)

(defun noct-relative ()
  "If `display-line-numbers' is non-nil, switch to relative numbering"
  (when display-line-numbers
    (setq-local display-line-numbers 'visual)))

(defun noct-absolute ()
  "If `display-line-numbers' is non-nil, switch to absolute numbering"
  (when display-line-numbers
    (setq-local display-line-numbers t)))

(general-add-hook 'evil-insert-state-entry-hook #'noct-absolute)
(general-add-hook 'evil-insert-state-exit-hook #'noct-relative)
#+end_src

** Mode Line
*** Any Mode Line
#+begin_src emacs-lisp
(general-after-init
  (column-number-mode)
  (size-indication-mode))
#+end_src

*** Doom Modeline
#+begin_src emacs-lisp
;; (defun noct-set-modeline (setter symbol newval)
;;   (if (eq symbol 'mode-line-format)
;;       (funcall setter 'header-line-format newval)
;;     (funcall setter symbol newval)))

;; doesn't work
;; (defun noct-set-modeline-advice (orig-fun &rest args)
;;   (cl-letf* ((old-set (symbol-function 'set))
;;              (old-set-default (symbol-function 'set-default))
;;              ((symbol-function 'set)
;;               (lambda (symbol newval)
;;                 (funcall #'noct-set-modeline old-set symbol newval)))
;;              ((symbol-function 'set-default)
;;               (lambda (symbol newval)
;;                 (funcall #'noct-set-modeline old-set-default symbol newval))))
;;     (apply orig-fun args)))

(defun noct-set-doom-modeline-advice (key &optional default)
  "Advice for `doom-modeline-set-modeline' to use the header line instead."
  (when-let ((line (doom-modeline key)))
    (setf (if default
              (default-value 'header-line-format)
            (buffer-local-value 'header-line-format (current-buffer)))
          (list "%e" line))))

(use-package doom-modeline
  :init
  (general-after-init
    (general-add-advice
     'doom-modeline-set-modeline
     :override #'noct-set-doom-modeline-advice)
    (doom-modeline-mode))
  :config
  (gsetq doom-modeline-buffer-encoding 'nondefault)
  (general-after-gui
    (gsetq doom-modeline-height
           ;; 35 on 4k
           (round (* 0.00911458333333333 (noct-default-monitor-width))))
    ;; TODO why does the `buffer-live-p' check fail for Messages?
    (dolist (bname '(
                     ;; "*scratch*"
                     "*Messages*"))
      (with-current-buffer bname
        (setq header-line-format (doom-modeline 'main)))))

  ;; TODO pushes things off to the side (even if plenty of space)
  ;; (gsetq doom-modeline-minor-modes t)

  ;; (doom-modeline-def-segment iconic-emacs-modeline-starter
  ;;   (list
  ;;    ;; space on left (or - if term)
  ;;    mode-line-front-space
  ;;    ;; report multilingual input; e.g. U: for utf-8
  ;;    mode-line-mule-info
  ;;    ;; for emacsclient frame identification
  ;;    mode-line-client
  ;;    ;; ** if modified, -- if not, %% if RO, %- if RO and modified
  ;;    mode-line-modified
  ;;    ;; indicates a remote buffer
  ;;    mode-line-remote
  ;;    mode-line-frame-identification))

  ;; replace modals section; not really a good alternative without defining a
  ;; completely new modeline
  ;; (doom-modeline-def-segment modals
  ;;   (doom-modeline-segment--iconic-emacs-modeline-starter))

  (gsetq global-mode-string
         (list
          ;; current group
          '(:eval (when (fboundp 'fg--name)
                    (let ((name (fg--name)))
                      (when name
                        (list :propertize (format "[%s] " (fg--name))
                              :face 'bold)
                        (format "[%s] "
                                (propertize (fg--name)
                                            'face 'bold))))))
          '(:eval (bound-and-true-p noct-heading-day-word-count))
          ;; show if clocked in to a heading
          '(:eval (when (and (bound-and-true-p org-mode-line-string)
                             (not (string= org-mode-line-string "")))
                    (concat "Clock: <"
                            (string-trim-left org-mode-line-string)
                            "> ")))))

  ;; https://github.com/seagle0128/doom-modeline/issues/271
  (when (string-match "--with-x-toolkit=lucid" system-configuration-options)
    (defun noct-doom-modeline--font-height (orig-fun &rest args)
      (round (* 0.5 (apply orig-fun args))))
    (general-add-advice 'doom-modeline--font-height
                        :around #'noct-doom-modeline--font-height)))
#+end_src

*** Fallback Mode Line
Default modeline if doom-modeline is not installed.
#+begin_src emacs-lisp
(unless (memq 'doom-modeline noct-straight-packages)
  ;; http://emacs-fu.blogspot.com/2011/08/customizing-mode-line.html
  (gsetq-default mode-line-format
                 (list
                  ;; error message about full memory
                  "%e"
                  ;; space on left (or - if term)
                  mode-line-front-space
                  ;; report multilingual input; e.g. U: for utf-8
                  mode-line-mule-info
                  ;; for emacsclient frame identification
                  mode-line-client
                  ;; ** if modified, -- if not, %% if RO, %- if RO and modified
                  mode-line-modified
                  ;; indicates a remote buffer
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "   "
                  ;; current group
                  '(:eval (when (fboundp 'fg-mode-line-string)
                            (fg-mode-line-string)))
                  ;; line and column
                  "(" ;; '%02' to set to 2 chars at least; prevents flickering
                  (propertize "%02l" 'face 'font-lock-type-face) ","
                  (propertize "%02c" 'face 'font-lock-type-face)
                  ") "

                  ;; relative position, size of file
                  "["
                  (propertize "%p" 'face 'font-lock-constant-face)
                  "/"
                  (propertize "%I" 'face 'font-lock-constant-face)
                  "] "

                  ;; the current major mode for the buffer.
                  "["
                  '(:eval (propertize "%m" 'face 'font-lock-string-face
                                      'help-echo buffer-file-coding-system))
                  "] "

                  '(:eval (when (bound-and-true-p org-mode-line-string)
                            (concat "Clock: <"
                                    (string-trim-left org-mode-line-string)
                                    "> ")))

                  '(:eval (when (bound-and-true-p auto-compile-mode)
                            (mode-line-auto-compile-control)))

                  ;; instead of mode-line-modes; eval is necessary for it to be
                  ;; up-to-date
                  '(:eval minor-mode-alist)

                  ;; fill with ' '
                  "% "))

  (force-mode-line-update))
#+end_src

** Evil Visual Mark Mode
Display an overlay for evil marks in normal state.
#+begin_src emacs-lisp
(use-package evil-visual-mark-mode
  :defer 3
  :config
  (evil-visual-mark-mode)
  ;; TODO how to render after restoring marks with desktop?
  ;; this doesn't work
  ;; (general-add-hook 'desktop-after-read-hook
  ;;                   (lambda ()
  ;;                     (dolist (buffer (buffer-list))
  ;;                       (with-current-buffer buffer
  ;;                         (evil-visual-mark-render)))))
  )
#+end_src

** Highlight Escape Sequences
Highlights escaped characters.
#+begin_src emacs-lisp
(use-package highlight-escape-sequences
  :init (hes-mode))
#+end_src

** Mini Frame and Maple Minibuffer
#+begin_src emacs-lisp
;; glitchy; both sometimes disappear (when messages in echo area); sometimes
;; slow; not using for now
(use-package mini-frame
  :config
  ;; TODO border color
  (gsetq mini-frame-color-shift-step 0
         mini-frame-show-parameters
         `((top . ,(round (* 0.02 (noct-default-monitor-height))))
           (width . 0.7)
           (height . 1)
           (left . 0.5))))

(use-package maple-minibuffer
  :straight (maple-minibuffer
             :host github
             :repo "honmaple/emacs-maple-minibuffer")
  :config
  (setq maple-minibuffer:position-type 'frame-top-center
        maple-minibuffer:border-color
        (or (ignore-errors (ewal-get-color 'foreground) "gray50"))
        maple-minibuffer:height nil
        maple-minibuffer:width 0.7
        maple-minibuffer:cache t))
#+end_src

** Posframe
A helper library for child frames (e.g. used with company and ivy).
#+begin_src emacs-lisp
(use-package posframe)
#+end_src

** Rainbow Mode
This will colorize something like #F3A111. I am enabling this locally in files with colors.
#+begin_src emacs-lisp
(use-package rainbow-mode)
#+end_src

** Show Paren
Smartparens' version is unfortunately too slow.
#+begin_src emacs-lisp
(use-package paren
  :init
  (noct-after-buffer (show-paren-mode))
  :config (gsetq show-paren-delay 0))
#+end_src

** Stripe Buffer
#+begin_src emacs-lisp
;; can cause input lag
(use-package stripe-buffer
  ;; :ghook ('org-mode-hook #'turn-on-stripe-table-mode)
  )
#+end_src

** Themes
*** Disable Old Theme When Switching
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/3112/how-to-reset-color-theme
;; undo old theme before switching to new theme
;; circadian does this too when switching themes
(defun noct-undo-themes (&rest _)
  (mapc #'disable-theme custom-enabled-themes))

(general-add-advice 'load-theme :before #'noct-undo-themes)
#+end_src

*** Installed Themes
#+begin_src emacs-lisp
(use-package twilight-bright-theme)

(use-package nord-theme)

(use-package gruvbox-theme
  :config
  (general-after 'ace-window
    (set-face-attribute 'aw-leading-char-face nil :height 1.0)))

;; dead
;; (use-package gruvbox-dark-theme
;;   :straight (gruvbox-dark-theme
;;              :host github
;;              :repo "d125q/gruvbox-dark-emacs")
;;   :init (load-theme 'gruvbox-dark t))

(use-package lenlen-theme
  :disabled t
  :ghook ('after-init-hook (lambda () (require 'lenlen-theme))))

(use-package solarized-theme)

(use-package jazz-theme)

(use-package ujelly-theme)

(use-package warm-night-theme)

(use-package flatui-theme)

(use-package labburn-theme)

(use-package tao-theme)

(use-package doom-themes
  :config
  (general-with 'org
    (set-face-attribute 'org-level-1 nil :height 1.0 :weight 'semi-bold
                        :background nil)
    (set-face-attribute 'org-block nil :background nil)
    (set-face-attribute 'org-block-begin-line nil :background nil)
    (set-face-attribute 'org-ellipsis nil :background nil)))
;; doom-spacegrey

(use-package kaolin-themes)
;; these are nice:
;; kaolin-eclipse
;; kaolin-valley-dark

(use-package timu-spacegrey-theme)

(use-package shades-of-purple-theme)

(use-package rose-pine-emacs
  :straight (rose-pine-emacs
             :host github
             :repo "thongpv87/rose-pine-emacs"))
#+end_src

*** Pywal
**** Ewal
#+begin_src emacs-lisp
(use-package ewal)

(use-package ewal-evil-cursors)

(use-package ewal-spacemacs-themes)

(use-package ewal-doom-themes)

(defun noct-ewal-load-spacemacs-theme ()
  "Load ewal's spacemacs theme with some adjustments."
  (interactive)
  (setq spacemacs-theme-org-height nil)
  (load-theme 'ewal-spacemacs-modern t)
  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'spacemacs-dark
     `(org-block ((t (:background ,(ewal-get-color 'background)))))
     `(org-block-begin-line ((t (:background ,(ewal-get-color 'background)))))
     `(org-block-end-line ((t (:background ,(ewal-get-color 'background)))))
     `(ivy-posframe-border ((t (:weight bold
                                :background
                                ,(ewal-get-color 'foreground)))))
     `(frog-menu-posframe-background-face
       ((t (:background ,(ewal-get-color 'background))))))))

(defun noct-ewal ()
  "Set theme for the current pywal colors."
  (interactive)
  (ewal-evil-cursors-get-colors
   :apply t)
  (setq evil-insert-state-cursor (list (ewal-get-color 'cursor) 'bar))

  (load-theme 'ewal-doom-one t)

  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'ewal-doom-one
     `(line-number ((t (:foreground ,(ewal-get-color 'blue)))))
     `(ivy-posframe-border ((t (:weight bold
                                :background
                                ,(ewal-get-color 'foreground)))))
     `(frog-menu-posframe-background-face
       ((t (:background ,(ewal-get-color 'background))))))))

;; takes 0.02-0.03 seconds; not that much but only do for daemon
;; also happens to be a good way to distinguish the two
(when (and (daemonp)
           (ignore-errors (ewal-load-colors)))
  (noct-ewal))
#+end_src

**** Xresources
#+begin_src emacs-lisp
(use-package xresources-theme)
#+end_src

*** Circadian
#+begin_src emacs-lisp
(use-package circadian
  :disabled t
  :init
  (gsetq circadian-themes '(
                            ;; ("8:00" . twilight-bright)
                            ;; ("20:00" . nord)
                            ("20:00" . gruvbox-dark-soft)))
  (unless (bound-and-true-p ewal-base-palette)
    (circadian-setup)))
;; can implement something similar enough tocircadian with just `run-at-time'
;; https://old.reddit.com/r/emacs/comments/gdtqov/weekly_tipstricketc_thread/fq9186h/
#+end_src

*** Default Theme
#+begin_src emacs-lisp
(unless (or (featurep 'circadian)
            (bound-and-true-p ewal-base-palette))
  ;; 0.2 seconds
  ;; (load-theme 'doom-spacegrey t)
  (if (daemonp)
      ;; faster even though it pulls in dash
      (load-theme 'gruvbox-dark-soft t)
    ;; fastest
    ;; (load-theme 'tao-yin t)
    (load-theme 'doom-opera t)))
#+end_src

** Visual Fill Column
Soft wrap lines at =fill-column=.
#+begin_src emacs-lisp
(use-package visual-fill-column
  :ghook 'text-mode-hook
  :general (noct-toggle-map "V" #'visual-fill-column-mode))
#+end_src

** Visual Line mode
#+begin_src emacs-lisp
;; https://github.com/abo-abo/swiper/issues/925
;; (global-visual-line-mode)
;; soft-wrap lines
(general-add-hook 'text-mode-hook #'visual-line-mode)
(blackout 'visual-line-mode)

;; show right-curly arrow on right of wrapped lines
(gsetq visual-line-fringe-indicators '(nil right-curly-arrow))

(general-def noct-toggle-map "v" #'visual-line-mode)
#+end_src

** Whitespace
#+begin_src emacs-lisp
;; http://ergoemacs.org/emacs/whitespace-mode.html
;; http://www.emacswiki.org/emacs/WhiteSpace
(use-package whitespace
  :defer-incrementally t
  :general (noct-toggle-map "w" #'whitespace-mode)
  :blackout t
  :config
  (gsetq whitespace-style
         (list 'face 'trailing 'space-before-tab::tab 'tabs 'tab-mark)
         ;; use `fill-column' value
         whitespace-line-column nil
         whitespace-display-mappings
         ;; would prefer not to use this, but not all themes make the tabs face
         ;; clear
         ;; TODO maybe pick a face
         '((tab-mark ?\t [?› ?\t])
           ;; (newline-mark ?\n [?¬ ?\n])
           ;; (space-mark ?\  [?·] [?.])
           ))

  (defun noct-add-lines-tail ()
    "Add lines-tail to `whitespace-style' and refresh `whitespace-mode'."
    (setq-local whitespace-style (cons 'lines-tail whitespace-style))
    (whitespace-mode))

  (general-add-hook 'prog-mode-hook #'noct-add-lines-tail)

  (global-whitespace-mode))
#+end_src

* Text Editing/Interaction
** =rect-ext.el=
#+begin_src emacs-lisp
;; TODO eventualy switch to more generic narrowing solution
(use-package rect-ext
  :disabled t
  :straight (rect-ext
             :host github
             :repo "noctuid/rect-ext.el"
             :protocol ssh
             :local-repo "~/src/emacs/rectangle-ext/")
  :general
  ('normal
   [remap evil-ex] #'rect-ext-evil-ex))
#+end_src

** TODO Aggressive Fill Paragraph
Too aggressive, but I like the idea. Will come back to.
#+begin_src emacs-lisp
(use-package aggressive-fill-paragraph
  :disabled t
  :ghook 'prog-mode-hook)
#+end_src

** Alignment (evil-lion and align)
Don't really use.
#+begin_src emacs-lisp
(use-package evil-lion
  :general ('normal
            "gl" #'evil-lion-left
            "gL" #'evil-lion-right))

(general-def 'visual "ta" #'align)
#+end_src

** Commenting
Automatic integration with org source blocks is nice. Evilnc jumps to the beginning of the block currently. Evil-commentary moves the point to the next line and scrolls the window, which is even worse. With polymode, any commenting command should work fine in a source block.

Evilnc also has comment text objects, but they were fairly broken last time I tried them, and I've implemented my own comment text object. Evilnc is definitely more actively maintained and has tests, which is why I'm currently using it.
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :general
  (general-t 'normal 'override "c" #'evilnc-comment-or-uncomment-lines)
  ('normal "gc" #'evilnc-comment-operator)
  ('visual "/" #'evilnc-comment-operator))

(use-package evil-commentary
  :disabled t
  :general
  (general-t (normal visual) 'override "c" #'evil-commentary-line)
  ('normal "gc" #'evil-commentary))

;; interesting idea, but it doesn't actually list all comments
;; (defun counsel-imenu-comments ()
;;   (interactive)
;;   (let* ((imenu-create-index-function #'evilnc-imenu-create-index-function))
;;     (unless (featurep 'counsel) (require 'counsel))
;;     (counsel-imenu)))
#+end_src

** Crux
TODO just use evil?
Some extra basic utilities.
#+begin_src emacs-lisp
(use-package crux
  :general
  (general-def 'insert
    [(shift return)] #'crux-smart-open-line
    [(control shift return)] #'crux-smart-open-line-above
    ;; crux-indent-defun
    ))
#+end_src

** File Templates
TODO look into replacing with https://github.com/mineo/yatemplate

*** Doom Helpers
Would be nice if this was a package. Nice over autoinsert.
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/b0978a4526cfd78bb18e5279909c19bee97e9878/modules/editor/file-templates/autoload.el
(defun doom-+file-templates--set (pred plist)
  (if (null (car-safe plist))
      (setq doom-+file-templates-alist
            (delq (assoc pred doom-+file-templates-alist)
                  doom-+file-templates-alist))
    (push `(,pred ,@plist) doom-+file-templates-alist)))

(defun doom-set-file-template! (pred &rest plist)
  "Register a file template.
PRED can either be a regexp string or a major mode symbol. PLIST may contain
these properties:
  :when FUNCTION
    Provides a secondary predicate. This function takes no arguments and is
    executed from within the target buffer. If it returns nil, this rule will be
    skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to trigger the
      target snippet.
    If a function, this function will be run in the context of the buffer to
      insert a file template into. It is given no arguments and must insert text
      into the current buffer manually.
    If omitted, `doom-+file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted, either PRED (if
    it's a major-mode symbol) or the mode of the buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't test any other
    file template rule against this buffer.
\(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)"
  (declare (indent defun))
  (doom-+file-templates--set pred plist))

(defun doom-set-file-templates! (&rest templates)
  "Like `doom-set-file-template!', but can register multiple file templates at once.
\(fn &rest (PRED &key WHEN TRIGGER MODE PROJECT IGNORE))"
  (dolist (template templates)
    (doom-+file-templates--set (car template) (cdr template))))

;;
;;; Library

(cl-defun doom-+file-templates--expand (pred &key project mode trigger ignore _when)
  "Auto insert a yasnippet snippet into current file and enter insert mode (if
evil is loaded and enabled)."
  (when (and pred (not ignore))
    (when (if project (projectile-project-p) t)
      (unless mode
        (setq mode (if (symbolp pred) pred major-mode)))
      (unless mode
        (user-error "Couldn't determine mode for %s file template" pred))
      (unless trigger
        (setq trigger doom-+file-templates-default-trigger))
      (if (functionp trigger)
          (funcall trigger)
        (require 'yasnippet)
        (unless yas-minor-mode
          (yas-minor-mode-on))
        (when (and yas-minor-mode
                   (when-let
                       (template (cl-find trigger (yas--all-templates (yas--get-snippet-tables mode))
                                          :key #'yas--template-key :test #'equal))
                     (yas-expand-snippet (yas--template-content template)))
                   (and (featurep 'evil) evil-local-mode)
                   (and yas--active-field-overlay
                        (overlay-buffer yas--active-field-overlay)
                        (overlay-get yas--active-field-overlay 'yas--field)))
          (evil-initialize-state 'insert))))))

(defun doom-+file-templates-get-short-path ()
  "Fetches a short file path for the header in Doom module templates."
  (let ((path (file-truename (or buffer-file-name default-directory))))
    (save-match-data
      (cond ((string-match "/modules/\\(.+\\)$" path)
             (match-string 1 path))
            ((file-in-directory-p path user-emacs-directory)
             (file-relative-name path user-emacs-directory))
            ((abbreviate-file-name path))))))

;;
;;; Commands

(defun doom-+file-templates/insert-license ()
  "Insert a license file template into the current file."
  (interactive)
  (require 'yasnippet)
  (let ((templates
         (let (yas-choose-tables-first ; avoid prompts
               yas-choose-keys-first)
           (cl-loop for tpl in (yas--all-templates (yas--get-snippet-tables 'text-mode))
                    for uuid = (yas--template-uuid tpl)
                    if (string-prefix-p "__license-" uuid)
                    collect (cons (string-remove-prefix "__license-" uuid) tpl)))))
    (when-let (uuid (yas-choose-value (mapcar #'car templates)))
      (yas-expand-snippet (cdr (assoc uuid templates))))))

(defun doom+file-templates/debug ()
  "Tests the current buffer and outputs the file template rule most appropriate
for it. This is used for testing."
  (interactive)
  (message "Found %s" (cl-find-if #'+file-template-p +file-templates-alist)))


;; https://github.com/hlissner/doom-emacs/blob/b0978a4526cfd78bb18e5279909c19bee97e9878/modules/editor/file-templates/config.el
(defvar doom-+file-templates-dir
  (expand-file-name "etc/yasnippet/templates/" user-emacs-directory)
  "The path to a directory of yasnippet folders to use for file templates.")

(defvar doom-+file-templates-default-trigger "__"
  "The default yasnippet trigger key (a string) for file template rules that
don't have a :trigger property in `doom-+file-templates-alist'.")

(defvar doom-+file-templates-alist nil
  "An alist of file template rules. The CAR of each rule is either a major mode
symbol or regexp string. The CDR is a plist. See `doom-set-file-template!' for more
information.")

;;
;;; Library

(defun doom-+file-template-p (rule)
  "Return t if RULE applies to the current buffer."
  (let ((pred (car rule))
        (plist (cdr rule)))
    (and (or (and (symbolp pred)
                  (eq major-mode pred))
             (and (stringp pred)
                  (stringp buffer-file-name)
                  (string-match-p pred buffer-file-name)
                  (or (not (plist-member plist :when))
                      (funcall (plist-get plist :when)
                               buffer-file-name))))
         rule)))

(defun doom-+file-templates-check-h ()
  "Check if the current buffer is a candidate for file template expansion. It
must be non-read-only, empty, and there must be a rule in
`doom-+file-templates-alist' that applies to it."
  (and buffer-file-name
       (not buffer-read-only)
       (bobp) (eobp)
       (not (member (substring (buffer-name) 0 1) '("*" " ")))
       (not (file-exists-p buffer-file-name))
       ;; Prevent file-templates from breaking org-capture when target file
       ;; doesn't exist and has a file template.
       (or (not (fboundp 'org-capture-get))
           (not (org-capture-get :new-buffer)))
       (when-let (rule (cl-find-if #'doom-+file-template-p doom-+file-templates-alist))
         (apply #'doom-+file-templates--expand rule))))


;;
;;; Bootstrap

(general-with 'yasnippet
  (general-pushnew doom-+file-templates-dir yas-snippet-dirs)
  ;; Ensure file templates in `+file-templates-dir' are visible
  (yas-reload-all))

;;
(general-add-hook 'find-file-hook #'doom-+file-templates-check-h)
#+end_src

*** Templates
#+begin_src emacs-lisp
(gsetq doom-+file-templates-alist
       `((,(rx ".org" eol)
          :when noct-blog-dir-p
          :trigger "__post"
          :mode org-mode)
         (emacs-lisp-mode :trigger "__package")
         (python-mode)))
#+end_src

** Smart Parens
[[https://github.com/Fuco1/smartparens/wiki/Permissions#filters][Info on filters]]

[[https://github.com/Fuco1/smartparens/wiki/Permissions#pre-and-post-action-hooks][Info on pre and post action hooks]]

#+begin_src emacs-lisp
(use-package smartparens
  :init
  ;; NOTE could also do evil-insert-entry-hook, but this is okay since I'm not
  ;; using smartparens in the scratch buffer
  (noct-after-buffer
    (smartparens-global-mode))
  :blackout " ⦅⦆"
  :config
  ;; typing closing delimiter always jumps out of expression even if not right
  ;; before closing; causes Emacs to hang in this file
  ;; (gsetq sp-autoskip-closing-pair 'always)

  ;; this also makes Emacs hang in this file
  ;; (show-smartparens-global-mode)

  (require 'smartparens-config)

  (sp-with-modes '(java-mode c-mode sh-mode web-mode typescript-mode)
    (sp-local-pair "{" nil
                   ;; don't currently have any global handlers; still use :add
                   :post-handlers '(:add ("||\n[i]" "RET"))))

  ;; TODO this won't work with `electric-slash' in c-mode
  (sp-with-modes '(java-mode c-mode web-mode typescript-mode)
    (sp-local-pair "/*" "*/"
                   :post-handlers '(:add ("* ||\n[i]" "RET")
                                    ("\n * ||\n[i]" "*")))))
#+end_src

** auto-yasnippet
TODO broken basically
TODO fix tab
TODO bind both in insert only
TODO number incrementing
#+begin_src emacs-lisp
(use-package auto-yasnippet
  :general
  (general-s
    "c" #'aya-create
    "x" #'aya-expand)
  (general-def 'insert
    "<C-tab>" #'aya-expand))
#+end_src

** Yasnippet
*** Setup
#+begin_src emacs-lisp
(use-package yasnippet
  :defer-incrementally (eldoc easymenu help-mode)
  :general
  ;; no mnemonic but next to C-n and default keybinding already on extend layer
  (general-def 'insert "C-e" #'yas-insert-snippet)
  (general-s "y" #'yas-new-snippet)
  (general-def help-map
    ;; unbound by default
    "y" #'yas-describe-tables)
  :blackout yas-minor-mode
  :config
  ;; never expand snippets in normal state
  (general-def 'normal yas-minor-mode-map
    [remap yas-expand] #'ignore)

  (general-def input-decode-map "C-i" [C-i])
  (general-def 'insert yas-minor-mode-map
    "<C-i>" #'yas-expand)

  ;; TODO extra checks may be necessary to prevent re-expanding the snippet in
  ;; undesirable situations
  (defun noct-space-should-expand-snippet-p ()
    "Check if a snippet whose condition returns 'space-expand is at the point."
    (let ((yas-buffer-local-condition
           ''(require-snippet-condition . space-expand)))
      (yas--templates-for-key-at-point)))

  (general-def 'insert yas-minor-mode-map
    "SPC" (list #'yas-expand :predicate '(noct-space-should-expand-snippet-p)))

  (general-def 'normal snippet-mode-map
    "RET" #'yas-load-snippet-buffer-and-close
    "mt" #'yas-tryout-snippet)

  (yas-global-mode)

  (defun yas-try-expand-first (orig-func &rest args)
    "Expand a snippet before the point or call ORIG-FUNC."
    (let ((yas-fallback-behavior nil))
      (unless (and (called-interactively-p 'interactive)
                   (yas-expand))
        (apply orig-func args))))
  (general-add-advice 'noct-org-tab-insert :around #'yas-try-expand-first)

  ;; https://github.com/joaotavora/yasnippet/blob/master/doc/faq.org#why-doesnt-tab-navigation-work-with-flyspell
  (general-add-hook 'flyspell-incorrect-hook
                    (lambda (_0 _1 _2)
                      (and (bound-and-true-p yas-active-field-overlay)
                           (overlay-buffer yas-active-field-overlay)))))
#+end_src

*** Extra Snippets
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :after yasnippet
  :demand t
  :config
  ;; for some reason this is necessary for my personal snippets to override some
  ;; of these
  (yas-reload-all))
#+end_src

** Undo
*** Undohist
Make Emacs undo persistent.
#+begin_src emacs-lisp
(use-package undohist
  :disabled t
  :init (undohist-initialize))
#+end_src

*** Undo Fu
Linear undo while maintaining all history. Not as nice as being able to navigate a tree of undo history (which is sometimes useful), but it works.
#+begin_src emacs-lisp
(use-package undo-fu
  :general
  ('normal
   "u" #'undo-fu-only-undo
   "U" #'undo-fu-only-redo
   "C-r" #'undo-fu-only-redo))

;; ignores encrypted files by default
(use-package undo-fu-session
  :init (global-undo-fu-session-mode))
#+end_src

*** Undo Tree
Undo tree is a great package but is unmaintained and extremely buggy.

[[https://github.com/syl20bnr/spacemacs/issues/774][Issue on spacemacs related to corruption]]

[[https://github.com/emacs-evil/evil/issues/1074][Issue on evil related to corruption]]

#+begin_src emacs-lisp
;; http://ergoemacs.org/emacs/emacs_undo_cult_problem.html
;; "Goddamn motherf�cking emacs undo."
(use-package undo-tree
  :disabled t
  :blackout " 🌴"
  :init (global-undo-tree-mode)
  :config
  (gsetq undo-tree-visualizer-timestamps t
         undo-tree-visualizer-diff t
         ;; buggy
         undo-tree-enable-undo-in-region nil
         ;; don't store undo history in same directory as file
         undo-tree-history-directory-alist '((".*" . "~/ag-sys/.emacs_undo"))
         ;; don't autosave history (corruption)
         undo-tree-history-autosave t)

  (general-def noct-toggle-map "u" #'undo-tree-mode)

  (general-def 'normal
    "u" #'undo-tree-undo
    "U" #'undo-tree-redo)

  (general-t "u" #'undo-tree-visualize))
#+end_src

** Evil Motions and Text objects
*** Things
Still experimental.
#+begin_src emacs-lisp
(use-package things
  :straight (things
             :host github
             :repo "noctuid/things.el"
             :protocol ssh
             :local-repo "~/src/emacs/things"))

(use-package things-evil
  :straight (things-evil
             :host github
             :repo "noctuid/things.el"
             :protocol ssh
             :local-repo "~/src/emacs/things")
  :ghook
  ('(evil-operator-state-entry-hook
     evil-visual-state-entry-hook)
   (lambda ()
     (require 'things-evil))
   nil
   nil
   t)
  :config
  (general-def '(visual operator) "RET" #'things-evil-last-text-object)

  (general-def '(inner outer) "p" nil)
  ;; temporary
  (general-def '(visual operator) "I" nil "A" nil)
  ;; keep I and A with visual block selection
  (general-def 'visual 'override
    :predicate '(eq (evil-visual-type) 'block)
    "I" #'evil-insert
    "A" #'evil-append)

  (things-evil-define aggregated-comment things-aggregated-comment :last-key "p" :keys "c")

  (things-evil-define string things-string :last-key "p" :keys "S")

  (evil-define-text-object evil-a-buffer (count &optional beg end type)
    "Select the entire buffer."
    (evil-range (point-min) (point-max)))

  (general-def '(inner outer) "e" #'evil-a-buffer)

  (things-evil-define line things-line :last-key "p" :keys "l")

  (things-evil-define paragraph paragraph :last-key "p" :keys "g")

  (things-evil-define function things-function :last-key "p" :keys "f")

  (things-define-pair 'things-paren "(" ")")
  (things-evil-define paren things-paren :last-key "p" :keys "(")

  ;; FIXME
  ;; (things-define-pair 'things-bracket (regexp-quote "[") (regexp-quote "]"))
  ;; (things-evil-define bracket things-bracket :last-key "p" :keys "[")

  (things-define-pair 'things-curly "{" "}")
  (things-evil-define curly things-curly :last-key "p" :keys "{")

  (things-define-pair 'things-angle "<" ">")
  (things-evil-define angle things-angle :last-key "p" :keys "<")

  (things-define-separator 'things-comma ",")
  (things-evil-define comma things-comma :last-key "p" :keys ",")

  (things-evil-define anyblock (things-paren
                                ;; things-bracket
                                things-curly)
                      :last-key "p" :keys "d"))
#+end_src

*** Evil Snipe and Easy Motion
Make these bindings:
- =f= and =F= in normal - 2-char sneak (avy)
- =r[fFtT]= in normal/visual/operator - 2-char sneak (avy)
- =rr[fFtT]= in normal/visual/operator - default f/t with snipe improvements (no avy)
- =[fFtT]= in visual/operator - same as above
- =[xXzZ]= in visual/operator - 2-char seek (no avy)

The logic behind these bindings is that I already don't have =t= in normal state and use 2-char seeks much more often than I would 1-char seeks in normal state. However, when using operators, I generally am not looking far ahead (deletion, for example, is normally used with a text object for larger selections and not with a motion to some arbitrary character), so it makes sense to keep the default behavior of =[fFtT]= in the visual and operator states (but with snipe's improvements, e.g. scope increased to visible buffer). If I did want a 2-char seek, I could use =[xXzZ]= (the default snipe keys for this purpose). =r[fFtT]= keys are consistent with other =r= keys (i.e. they remotely move somewhere using avy).

**** Evil Snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :commands (noct-snipe-2-f noct-snipe-2-F noct-snipe-2-t noct-snipe-2-T)
  :general
  ;; if need in normal state instead of 2-letter (usually don't)
  (general-r
    "f" #'evil-snipe-f
    "F" #'evil-snipe-F)
  (general-rr
    "t" #'evil-snipe-t
    "T" #'evil-snipe-T)
  (general-def '(operator visual)
    "t" #'evil-snipe-t
    "T" #'evil-snipe-T
    "z" #'evil-snipe-z
    "Z" #'evil-snipe-Z)
  ;; to keep `lispyville-delete-char-or-splice' for now
  (general-def 'operator
    "x" #'evil-snipe-x
    "X" #'evil-snipe-X)
  (general-r
    ";" #'evil-snipe-repeat
    "," #'evil-snipe-repeat-reverse)
  :blackout t
  :blackout evil-snipe-override-mode
  :blackout evil-snipe-override-local-mode
  :config
  (gsetq evil-snipe-smart-case t
         ;; search visible part of buffer
         evil-snipe-scope 'visible
         ;; include matches behind cursor for repeating
         evil-snipe-repeat-scope 'whole-visible
         ;; tab to refine search (add another char)
         evil-snipe-tab-increment t
         ;; don't automatically bind s and S
         evil-snipe-auto-disable-substitute nil
         ;; don't automatically bind ; and ,
         evil-snipe-override-evil-repeat-keys nil
         ;; the incremental highlight is good enough
         evil-snipe-enable-highlight nil)

  ;; define evil-snipe-(z|Z)
  (evil-snipe-def 2 'inclusive "z" "Z")

  (evil-snipe-def 2 'inclusive "f" "F"
                  :forward-fn noct-snipe-2-f
                  :backward-fn noct-snipe-2-F)

  (evil-snipe-def 2 'exclusive "t" "T"
                  :forward-fn noct-snipe-2-t
                  :backward-fn noct-snipe-2-T)

  (general-add-hook 'evil-snipe-local-mode-hook
                    (lambda () (blackout 'evil-snipe-local-mode)))

  ;; not using evil-snipe-mode, but highlight cleanup depends on it
  ;; remove check
  (defun noct-evil-snipe--cleanup ()
    "Disables overlays and cleans up after evil-snipe."
    (remove-overlays nil nil 'category 'evil-snipe)
    (remove-hook 'pre-command-hook #'evil-snipe--cleanup))

  (general-add-advice 'evil-snipe--cleanup :override #'noct-evil-snipe--cleanup))
#+end_src

**** Evil Easymotion
TODO Use things.el instead.
#+begin_src emacs-lisp
(use-package evil-easymotion
  :general
  (general-def 'motion
    "f" #'noct-sneak-forward-f
    "F" #'noct-sneak-backward-F)

  (general-r
    "t" #'noct-sneak-forward-exclusive-t
    "T" #'noct-sneak-backward-exclusive-T)

  ;; TODO combine next two statements when general supports modifier prefixes
  (general-r
    "n" #'evilem-next-line
    "e" #'evilem-prev-line
    ;; too many candidates to be that useful
    ;; "w" #'evilem-forward-word-begin
    ;; so useful it might even warrant a single letter keybinding (e.g.
    ;; replacing f keybinding)
    "w" #'evil-avy-goto-word-or-subword-1
    "W" #'evilem-forward-WORD-begin
    "b" #'evilem-backward-word-begin
    "B" #'evilem-backward-WORD-begin
    "s" #'evilem-sentence-nav-forward
    "S" #'evilem-sentence-nav-backward
    "p" #'evilem-forward-paragraph
    "P" #'evilem-backward-paragraph)

  ;; can't use control since can't distinguish certain keys (can rebind in
  ;; `input-decode' map to get working, though will only work for GUI)
  (general-def '(insert emacs)
    "M-n" #'evilem-next-line
    "M-e" #'evilem-prev-line
    "M-w" #'evilem-forward-word-begin
    "M-W" #'evilem-forward-WORD-begin
    ;; don't override backward word
    ;; "M-b" #'evilem-backward-word-begin
    "M-B" #'evilem-backward-WORD-begin
    "M-s" #'evilem-sentence-nav-forward
    "M-S" #'evilem-sentence-nav-backward
    "M-p" #'evilem-forward-paragraph
    "M-P" #'evilem-backward-paragraph)

  :config
  (evilem-make-motion noct-sneak-forward-f #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  ;; TODO :bind doesn't work anymore?
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-f))))
  (evilem-make-motion noct-sneak-backward-F #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-F))))
  (evilem-make-motion noct-sneak-forward-exclusive-t #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-t))))
  (evilem-make-motion noct-sneak-backward-exclusive-T #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-T))))

  (defun noct-next-line ()
    (interactive)
    (evil-next-line)
    (beginning-of-line))

  (defun noct-prev-line ()
    (interactive)
    (evil-previous-line)
    (beginning-of-line))

  (evilem-make-motion evilem-next-line
                      #'noct-next-line
                      :pre-hook (setq evil-this-type 'line)
                      :bind ((temporary-goal-column (current-column))
                             (line-move-visual t)))

  (evilem-make-motion evilem-prev-line
                      #'noct-prev-line
                      :pre-hook (setq evil-this-type 'line)
                      :bind ((temporary-goal-column (current-column))
                             (line-move-visual t)))

  (evilem-make-motion evilem-forward-word-begin
                      #'evil-forward-word-begin)
  (evilem-make-motion evilem-forward-WORD-begin
                      #'evil-forward-WORD-begin)
  (evilem-make-motion evilem-backward-word-begin
                      #'evil-backward-word-begin)
  (evilem-make-motion evilem-backward-WORD-begin
                      #'evil-backward-WORD-begin)

  (evilem-make-motion evilem-sentence-nav-forward
                      #'sentence-nav-evil-forward)
  (evilem-make-motion evilem-sentence-nav-backward
                      #'sentence-nav-evil-backward)
  (evilem-make-motion noct-sentence-easymotion
                      (list #'sentence-nav-forward
                            #'sentence-nav-backward))


  (evilem-make-motion evilem-forward-paragraph
                      #'evil-forward-paragraph)
  (evilem-make-motion evilem-backward-paragraph
                      #'evil-backward-paragraph))
#+end_src

*** Sentence Navigation
Needs to be updated to use =things.el= and needs to have more tests.
#+begin_src emacs-lisp
(use-package sentence-navigation
  :disabled t
  :straight (sentence-navigation
             :protocol ssh
             :local-repo "~/src/emacs/sentence-navigation")
  :general
  ;; TODO different keybinding?
  ('normal
   ")" #'sentence-nav-evil-forward
   "(" #'sentence-nav-evil-backward
   "g)" #'sentence-nav-evil-forward-end
   "g(" #'sentence-nav-evil-backward-end)
  ('inner "s" #'sentence-nav-evil-inner-sentence)
  ('a "s" #'sentence-nav-evil-a-sentence)
  :config
  ;; set # as comment character for org mode; TODO shouldn't have to do this
  (modify-syntax-entry ?# "<" text-mode-syntax-table)
  (with-eval-after-load 'org
    (modify-syntax-entry ?# "<" org-mode-syntax-table)))
#+end_src

*** Column Text Object
Needs to be updated to use =things.el= and needs to have more tests.
#+begin_src emacs-lisp
(use-package evil-textobj-column
  :straight (evil-textobj-column
             :host github
             :repo "noctuid/evil-textobj-column"
             :protocol ssh
             :local-repo "~/src/emacs/evil-textobj-column")
  :general ('inner
            "k" #'evil-textobj-column-word
            "K" #'evil-textobj-column-WORD))
#+end_src

** Evil Matchit
#+begin_src emacs-lisp
(use-package evil-matchit
  :general
  ('normal "ro" #'evilmi-jump-items))
#+end_src

** Evil Numbers
TODO now default on melpa
This package is unfortunately unmaintained.
#+begin_src emacs-lisp
(use-package evil-numbers
  ;; use version that supports g C-a
  ;; https://github.com/janpath/evil-numbers/issues/3
  :straight (evil-numbers :host github :repo "janpath/evil-numbers")
  :general ('normal
            "C-a" #'evil-numbers/inc-at-pt
            "C-x" #'evil-numbers/dec-at-pt
            "g C-a" #'evil-numbers/inc-at-pt-incremental
            "g C-x" #'evil-numbers/dec-at-pt-incremental))
#+end_src

** Evil Surround
#+begin_src emacs-lisp
(use-package evil-surround
  :ghook
  ('(evil-operator-state-entry-hook
     evil-visual-state-entry-hook)
   ;; TODO this currently HAS to be a lambda; need to be able to remove for all
   ;; hooks/advice at once
   (lambda ()
     (global-evil-surround-mode))
   nil
   nil
   t)
  ;; https://github.com/timcharper/evil-surround/pull/48
  :config
  (general-def 'visual evil-surround-mode-map
    "s" #'evil-surround-region))
#+end_src

** Evil Exchange
#+begin_src emacs-lisp
(use-package evil-exchange
  :general (noct-c-map "x" #'evil-exchange))
#+end_src

** Evil Replace with Register
#+begin_src emacs-lisp
(use-package evil-replace-with-register
  :general
  (general-defs
    'normal
    "gr" #'evil-replace-with-register
    'visual
    "p" #'evil-replace-with-register))
#+end_src

** Link Hint
#+begin_src emacs-lisp
(use-package link-hint
  :straight (link-hint
             :protocol ssh
             :local-repo  "~/src/emacs/link-hint/")
  :general
  (general-t
    "f" #'link-hint-open-link
    "F" #'link-hint-open-multiple-links)
  (general-r
    "y" #'link-hint-copy-link
    "Y" #'link-hint-copy-multiple-links)
  ('normal "gf" #'link-hint-open-link-at-point)
  :config
  (defun noct-terminal-link-hint-file (file)
    (find-file file)
    (unwind-protect (link-hint-open-link)
      (kill-buffer)
      (start-process-shell-command "xdotool getactivewindow windowunmap")
      ;; (delete-frame)
      )))

(use-package browse-url
  :config
  (gsetq browse-url-generic-program (getenv "BROWSER")
         browse-url-browser-function #'browse-url-generic))
#+end_src

* Version Control
[[https://github.com/tarsius/git-elisp-overview][List of git related packages]]
** Git Major Modes
#+begin_src emacs-lisp
;; https://github.com/magit/git-modes
(use-package gitattributes-mode)

(use-package gitconfig-mode)

(use-package gitignore-mode
  :mode "/.dockerignore\\'")
#+end_src

** Browse at Remote
#+begin_src emacs-lisp
(use-package browse-at-remote
  :general (general-t "RET" #'browse-at-remote))
#+end_src

** Git Link
#+begin_src emacs-lisp
(use-package git-link
  :general ('normal "gy" #'git-link))
#+end_src

** Git Gutter
This is the only package that allows in-buffer hunk staging that I'm aware of. It slows Emacs to a crawl in large files with a lot of unstaged changes (like this one). I plan on eventually switching to diff-hl, which has saner live updating.

Update: Git gutter seems to be faster than previously.
#+begin_src emacs-lisp
(use-package git-gutter
  :ghook ('find-file-hook #'noct-maybe-enable-git-gutter)
  :general
  (general-t
    "gn" (list #'git-gutter:next-hunk :jump t)
    "ge" (list #'git-gutter:previous-hunk :jump t)
    "gh" #'git-gutter:stage-hunk
    "gi" #'git-gutter:revert-hunk)
  :blackout t
  :config
  (gsetq git-gutter:modified-sign "~"
         git-gutter:handled-backends '(git hg)
         ;; hide when no changes
         git-gutter:hide-gutter t
         git-gutter:update-interval 2)

  (gsetq git-gutter:modified-sign " "
         git-gutter:deleted-sign " "
         git-gutter:added-sign " ")

  ;; if switch to diff-hl and only use for hunk commands
  ;; (setq git-gutter:display-p nil)

  ;; stole colors from orderless
  (set-face-background 'git-gutter:modified "#72a4ff")
  (set-face-background 'git-gutter:added "#90d800")
  (set-face-background 'git-gutter:deleted "#ed92f8")

  (general-def noct-toggle-map "g" #'git-gutter-mode)

  (defun noct-maybe-enable-git-gutter ()
    "Enable git gutter except for in org init file."
    (unless (and buffer-file-name
                 (string= (file-name-nondirectory buffer-file-name)
                          "awaken.org"))
      (git-gutter-mode)))

  (noct-handle-popup (rx "*git-gutter:diff*")))
#+end_src

** Diff HL
Diff-hl is nice but currently doesn't support staging hunks. Diff-hl also has a dired mode, but I think that I prefer dired-k.
#+begin_src emacs-lisp
(use-package diff-hl
  :disabled t
  :blackout t
  ;; TODO defer, e.g. `find-file-hook'
  :init
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  :config
  (gsetq diff-hl-show-staged-changes nil)

  (general-def noct-toggle-map "D" #'diff-hl)

  (general-t
    "gn" (list #'diff-hl-next-hunk :jump t)
    "ge" (list #'diff-hl-previous-hunk :jump t))

  (with-eval-after-load 'magit
    (general-add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (general-add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))

  ;; stole colors from orderless
  (set-face-background 'diff-hl-change "#72a4ff")
  (set-face-background 'diff-hl-insert "#90d800")
  (set-face-background 'diff-hl-delete "#ed92f8")

  ;; TODO need a better solution than this
  ;; (defun noct-change-diff-location ()
  ;;   "Put diff markers in the margin or fringe based on (display-graphic-p)."
  ;;   (if (display-graphic-p)
  ;;       (when diff-hl-margin-mode
  ;;         (diff-hl-margin-mode -1))
  ;;     (diff-hl-margin-mode)))

  ;; (general-add-hook 'focus-in-hook #'noct-change-diff-location)
  )
#+end_src

** Magit
*** Setup
#+begin_src emacs-lisp
(use-package magit
  :defer-incrementally
  (dash f s with-editor git-commit package eieio transient)
  :general
  ('normal 'override "S" #'magit-status-here)
  ('normal dired-mode-map "C" #'magit-clone)
  (general-spc
    "." #'magit-find-git-config-file
    "G" #'magit-find-file)
  (general-t
    "ga" #'magit-stage-file
    "gr" #'magit-rebase-interactive
    "gl" #'magit-log-all
    "gL" #'magit-log-buffer-file
    "gc" #'magit-commit
    "gg" #'magit-clone
    "gp" #'magit-push
    ;; "gf" #'magit-file-dispatch
    "gf" #'magit-pull
    "gb" #'magit-blame)
  :config
  (gsetq magit-diff-refine-hunk t
         ;; required for prescient to be used
         magit-completing-read-function #'selectrum-completing-read
         magit-display-buffer-function #'display-buffer
         magit-blame-echo-style '(lines
                                  (show-lines . t)
                                  (show-message . t)))


  (defun noct-fix-magit-header-line (&rest _)
    (interactive)
    (set-face-background 'magit-header-line (face-background 'mode-line))
    (set-face-attribute 'magit-header-line nil :box nil))
  (noct-fix-magit-header-line)
  ;; TODO this doesn't work
  ;; (general-add-advice 'load-theme :after #'noct-fix-magit-header-line)
  )
#+end_src

*** Section Configuration
**** Status Mode Sections
Show staged changes then unstaged changes then untracked files.
#+begin_src emacs-lisp
(general-with-package 'magit
  (gsetq magit-status-sections-hook
         (cl-loop for section in magit-status-sections-hook
                  unless (memq section '(magit-insert-untracked-files
                                         magit-insert-unstaged-changes))
                  collect section
                  and when (eq section 'magit-insert-staged-changes)
                  append (list 'magit-insert-unstaged-changes
                               'magit-insert-untracked-files))))
#+end_src

**** Revision Mode Sections
Show GPG information when examining a commit (see [[https://github.com/magit/magit/issues/2797][this magit issue]]).
#+begin_src emacs-lisp
(general-with-package 'magit
  ;; https://gist.github.com/fice-t/c84c3bc7007d0d4bcacfeb2c0e42ac27
  (defun magit-rev-format-items (format &optional rev args)
    (with-temp-buffer
      (magit-rev-insert-format format rev args)
      (split-string (buffer-string) "\0")))

  (defun magit-insert-revision-gpg ()
    (let* ((rev (car magit-refresh-args))
           (res (magit-rev-format-items "%G?%x00%GS%x00%GK%x00%GG" rev))
           (type (aref (car res) 0)))
      (unless (eq type ?N)
        (let* ((signer (cl-second res))
               (key (cl-third res))
               (raw (string-trim-right (cl-fourth res) "\n+"))
               face
               status)
          (pcase type
            (?G (setq face 'magit-signature-good)
                (setq status "VALID"))
            (?B (setq face 'magit-signature-bad)
                (setq status "BAD"))
            (?U (setq face 'magit-signature-untrusted)
                (setq status "UNKNOWN"))
            (?X (setq face 'magit-signature-expired)
                (setq status "EXPIRED"))
            (?Y (setq face 'magit-signature-expired-key)
                (setq status "EXPIRED KEY"))
            (?R (setq face 'magit-signature-revoked)
                (setq status "REVOKED"))
            (?E (setq face 'magit-signature-error)
                (setq status "ERROR")))
          (magit-insert-section (gpg status (not (eq type ?E)))
            (insert "GPG Status: "
                    (propertize (or status "") 'face face)
                    " (press "
                    (substitute-command-keys "\\[magit-section-toggle]")
                    " to toggle raw output)\n")
            (unless (string= signer "")
              (magit-insert-section (gpg signer)
                (insert "GPG Signer: "
                        (propertize signer 'face face)
                        "\n")))
            (unless (string= key "")
              (magit-insert-section (gpg key)
                (insert "GPG Key:    "
                        (propertize key 'face face)
                        "\n")))
            (insert "\n")
            (magit-insert-heading)
            (magit-insert-section (gpg raw)
              (insert (propertize raw 'face face)
                      "\n\n")))))))

  ;; https://github.com/magit/magit/issues/2797#issuecomment-338388572
  (magit-add-section-hook 'magit-revision-sections-hook
                          #'magit-insert-revision-gpg
                          #'magit-insert-revision-headers
                          t))
#+end_src

*** Window Positioning
#+begin_src emacs-lisp
(noct-handle-popup-same-window magit-status-mode)
(noct-handle-popup-same-window magit-log-mode)
(noct-handle-popup-same-window magit-cherry-mode)
(noct-handle-popup-other-window magit-revision-mode)
(noct-handle-popup-other-window-no-select magit-diff-mode)
#+end_src

*** Keybindings
#+begin_src emacs-lisp
(general-with-package 'magit
  (general-def 'normal magit-mode-map
    "<tab>" #'magit-section-toggle
    "RET" #'magit-visit-thing
    "C-n" #'magit-section-forward
    "C-e" #'magit-section-backward
    "N" #'magit-section-forward-sibling
    "E" #'magit-section-backward-sibling
    "H" #'magit-section-up
    "+" #'magit-diff-more-context
    ;; "-" #'magit-diff-less-context
    "=" #'magit-diff-default-context
    "$" #'magit-process-buffer
    "%" #'magit-worktree
    "a" #'magit-cherry-pick
    "b" #'magit-branch
    "B" #'magit-bisect
    "c" #'magit-commit
    "d" #'magit-diff
    "D" #'magit-diff-refresh
    ;; not using ediff commands
    ;; "e" #'magit-ediff-dwim
    ;; "E" #'magit-ediff
    ;; swap fetch and pull
    "f" #'magit-pull
    "F" #'magit-fetch
    "gr" #'magit-refresh
    "gR" #'magit-refresh-all
    ;; "h" #'magit-dispatch
    "?" #'magit-dispatch
    "i" #'magit-gitignore
    ;; e.g. discard
    "k" #'magit-delete-thing
    "K" #'magit-file-untrack
    "l" #'magit-log
    "L" #'magit-log-refresh
    "m" #'magit-merge
    "M" #'magit-remote
    "o" #'magit-submodule
    "O" #'magit-subtree
    "p" #'magit-push
    "q" #'magit-mode-bury-buffer
    "r" #'magit-rebase
    "R" #'magit-file-rename
    "T" #'magit-tag
    ;; "T" #'magit-notes
    "s" #'magit-stage-file
    "S" #'magit-stage-modified
    "u" #'magit-unstage-file
    "U" #'magit-unstage-all
    ;; swap revert and revert-no-commit
    ;; TODO visual state and yanking
    "v" #'magit-revert
    "V" #'magit-revert-no-commit
    "w" #'magit-am
    "W" #'magit-patch
    "x" #'magit-reset-quickly
    "X" #'magit-reset
    "y" #'magit-show-refs
    ;; show commits in branch not merged upstream
    "Y" #'magit-cherry
    "z" #'magit-stash
    "Z" #'magit-stash
    ":" #'magit-git-command
    "!" #'magit-run)

  (general-def 'normal magit-log-mode-map
    "q" #'magit-log-bury-buffer
    "RET" #'magit-show-commit
    "v" #'magit-revert)

  ;; e.g. for c F
  (general-def 'normal magit-log-select-mode-map
    "RET" #'magit-log-select-pick)

  ;; `a' in log buffer; use cherry pick transient instead of apply
  (general-def magit-commit-section-map
    "a" #'magit-cherry-pick)

  (general-def 'normal magit-blame-mode-map
    "q" #'magit-blame-quit))
#+end_src

*** With Editor
#+begin_src emacs-lisp
(use-package with-editor
  :config
  (general-def 'normal with-editor-mode-map
    "RET" #'with-editor-finish
    "q" #'with-editor-cancel))
#+end_src

*** Transient
#+begin_src emacs-lisp
(use-package transient
  :config
  ;; higlight infix arguments that do not have equivalent cli args
  (gsetq transient-highlight-mismatched-keys t
         ;; e.g. will now show since and until on log transient
         transient-default-level 7
         ;; TODO issue with it failing because \.\.\. in history
         transient-save-history nil
         transient-display-buffer-action
         '(noct-display-buffer-in-side-window-no-header
           (side . top))
         transient-mode-line-format nil)
  (general-def transient-map
    "<escape>" #'transient-quit-one
    "q" #'transient-quit-one))
#+end_src

*** Forge
#+begin_src emacs-lisp
(use-package forge
  :general
  (general-spc "'" #'forge-dispatch)
  ;; TODO would be nice to replace git-link and browse-at-remote entirely
  (general-t "g RET" #'forge-browse-remote)
  :init
  (general-with 'magit
    (require 'forge))
  :config
  (gsetq forge-owned-accounts '(("noctuid")))

  (general-t
    :infix "g"
    "'" #'forge-dispatch)
  (general-def 'normal magit-mode-map
    "'" #'forge-dispatch)
  (general-def 'normal forge-topic-mode-map
    "i" #'forge-create-post
    "c" #'forge-edit-post)
  (general-def 'normal forge-post-mode-map
    "q" #'forge-post-cancel)

  (general-with 'hardhat
    (general-pushnew
     (cons 'forge-post-mode (lambda (&rest _) t))
     hardhat-buffer-editable-functions)))
#+end_src

** TODO Git Commit Insert Issue
Currently broken for github.
#+begin_src emacs-lisp
(use-package git-commit-insert-issue
  :ghook 'git-commit-mode-hook)
#+end_src

** Git Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :general (general-t "gt" #'git-timemachine)
  :config
  (general-def 'normal git-timemachine-mode-map
    "h" #'git-timemachine-show-previous-revision
    "i" #'git-timemachine-show-next-revision
    "a" #'git-timemachine-kill-abbreviated-revision
    "b" #'git-timemachine-blame
    "c" #'git-timemachine-show-commit
    "q" #'git-timemachine-quit))
#+end_src

** Smerge
TODO RET and m-a don't work
TODO normalize keymaps when starting smerge mode
#+begin_src emacs-lisp
(general-with-package 'smerge-mode
  (general-def 'normal smerge-mode-map "RET" #'smerge-keep-current)
  ;; can temporarily override m bindings until conflicts resolved
  (general-m smerge-mode-map
    "k" #'smerge-vc-next-conflict
    "n" #'smerge-next
    "e" #'smerge-prev
    "u" #'smerge-keep-upper
    "l" #'smerge-keep-lower
    "a" #'smerge-keep-all))
#+end_src

** Vdiff
*** Setup
TODO
- should be able to handle visual line mode like vimdiff can (just more blank lines on one side); minor
- do something like this: https://oremacs.com/2017/03/18/dired-ediff/
- hydra

#+begin_src emacs-lisp
(defvar noct-no-truncate-lines-p nil)
(defvar noct-vdiff-disabled-zoom nil)
(defvar noct-vdiff-disabled-visual-lines nil)
(defvar noct-vdiff-enabled-truncation nil)

(defun noct-vdiff-setup ()
  "Alter modes/settings for proper hunk alignment with `vdiff-mode'.
Restore previous settings after disabling `vdiff-mode'."
  (cond ((bound-and-true-p vdiff-mode)
         (when (bound-and-true-p zoom-mode)
           (setq noct-vdiff-disabled-zoom t)
           (zoom-mode -1))
         (when visual-line-mode
           (setq noct-vdiff-disabled-visual-lines t)
           (visual-line-mode -1))
         (when (not truncate-lines)
           (setq noct-vdiff-enabled-truncation t)
           (toggle-truncate-lines +1)))
        (t
         (when noct-vdiff-disabled-zoom
           (setq noct-vdiff-disabled-zoom nil)
           (zoom-mode))
         (when noct-vdiff-disabled-visual-lines
           (setq noct-vdiff-disabled-visual-lines nil)
           (visual-line-mode))
         (when noct-vdiff-enabled-truncation
           (setq noct-vdiff-enabled-truncation nil)
           (toggle-truncate-lines -1)))))

(declare-function vdiff-merge-conflict "vdiff")
(defun noct-vdiff-resolve-conflicts ()
  "Run `vdiff-merge-conflict' on the current file."
  (interactive)
  (vdiff-merge-conflict buffer-file-name))

(use-package vdiff
  :general
  ;; resolve [m]erge conflicts
  (general-t "gm" #'noct-vdiff-resolve-conflicts)
  :gfhook #'noct-vdiff-setup
  :config
  ;; automatically highlight word differences
  (gsetq vdiff-auto-refine t)

  ;; bind dp and do
  ;; ~/src/forks/evil-collection/evil-collection-vdiff.el
  (evil-collection-init 'vdiff)

  (general-def 'visual (vdiff-mode vdiff-3way-mode)
    :definer 'minor-mode
    "p" #'vdiff-send-changes
    "o" #'vdiff-receive-changes)

  (general-def 'normal (vdiff-mode vdiff-3way-mode)
    :definer 'minor-mode
    "<tab>" #'vdiff-toggle-fold
    "mn" #'vdiff-next-hunk
    "me" #'vdiff-previous-hunk
    "mw" #'vdiff-toggle-whitespace
    "RET" #'vdiff-quit
    "gr" #'vdiff-refresh
    "q" #'vdiff-quit)

  ;; TODO would be preferable to have a setting for this
  ;; for example, stay on working directory buffer when running
  ;; `vdiff-magit-stage'
  (defun noct-vdiff-switch-to-b (&rest args)
    "Select the window containing buffer b.
Meant to be called after `vdiff-buffers' with its args."
    (select-window (get-buffer-window (cadr args))))

  (general-add-advice 'vdiff-buffers :after #'noct-vdiff-switch-to-b))
#+end_src

*** Magit Vdiff
#+begin_src emacs-lisp
(declare-function vdiff-magit-stage "vdiff-magit")
(defun noct-vdiff-stage ()
  "Run `vdiff-magit-stage' on the current file."
  (interactive)
  (vdiff-magit-stage buffer-file-name))

(use-package vdiff-magit
  :general
  (magit-mode-map
   "e" #'vdiff-magit-dwim
   "E" #'vdiff-magit)
  (general-t
    "gd" #'noct-vdiff-stage)
  :config
  (gsetq vdiff-magit-stage-is-2way t)

  (transient-replace-suffix 'magit-dispatch "e"
    '("e" "Vdiff (dwim)" vdiff-magit-dwim))
  (transient-replace-suffix 'magit-dispatch "E"
    '("E" "Vdiff transient" vdiff-magit)))
#+end_src

** Magit Todos
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :demand t
  :config (magit-todos-mode))
#+end_src

* Writing/Prose/Input
There is also artbollocks, which highlight certain weasel words like "very" and can give a readability score, but it's not nearly as sophisticated as other software like languagetool. I'm currently using vale over write-good and proselint, but I haven't tried anything extensively. I need to try proselint more (flycheck has integration with by default). Some of the warnings/errors these packages give can be annoying.

** Clipetty
Clipetty gives clipboard integration in terminal frames. Unlike xclip, it works fine even if enabled for a server that has both graphical and terminal frames. Currently only copying is supported (see [[https://github.com/spudlyo/clipetty/issues/10][issue 10]]).
#+begin_src emacs-lisp
(use-package clipetty
  :init
  (general-after-tty
    (global-clipetty-mode))
  :blackout t)
#+end_src

** Langtool
Quite slow in larger buffers and not integrated with flycheck. Languagetool itself is a pretty impressive piece of software though with ~30k commits currently.
#+begin_src emacs-lisp
;; grammar checking
(use-package langtool
  :config
  (gsetq langtool-default-language "en-US"
         langtool-java-classpath
         "/usr/share/languagetool:/usr/share/java/languagetool/*"))
#+end_src

** Typo
For typographical editing (not fixing typos).
#+begin_src emacs-lisp
(use-package typo
  :general (noct-toggle-map "\"" #'typo-mode))
#+end_src

** Vale
[[https://github.com/errata-ai/vale][Value]] supports proselint and write-good styles with configuration.
#+begin_src emacs-lisp
(use-package flycheck-vale
  :disabled t
  :after flycheck
  :demand t
  :config (flycheck-vale-setup))
#+end_src

** Fcitx
#+begin_src emacs-lisp
(use-package fcitx
  ;; doesn't work with fcitx5
  :disabled t
  ;; :when (executable-find "fcitx")
  :init
  (general-add-hook
   'evil-insert-state-entry-hook
   (noct-defun noct-maybe-require-fcitx ()
     "Require fcitx if the buffer is writable and not derived from prog-mode."
     (unless (or buffer-read-only
                 (derived-mode-p 'prog-mode))
       (require 'fcitx)))
   nil
   nil
   #'identity)
  :config
  (fcitx-aggressive-setup))
#+end_src

** Spelling
*** Flyspell
**** Setup
#+begin_src emacs-lisp
;; it's way too slow; not using for highlighting
(use-package flyspell
  ;; :ghook
  ;; ('text-mode-hook #'turn-on-flyspell)
  ;; ;; will check just comments and strings
  ;; ('prog-mode-hook #'flyspell-prog-mode)
  :blackout t)
#+end_src

**** Flyspell Lazy
This makes things less convenient (there are some cases where mispellings aren't detected), but flyspell is usually the issue when I'm having input lag and profile.
#+begin_src emacs-lisp
(use-package flyspell-lazy
  :disabled t
  :after flyspell
  :init (flyspell-lazy-mode 1))
#+end_src

**** Flyspell Visible Mode
=flyspell-visible-mode= seems like it might be a better alternative to =flyspell-lazy=, but =spell-fu= is working well enough for me at the moment.

**** Flyspell Correct
#+begin_src emacs-lisp
(use-package flyspell-correct
  :config
  ;; https://github.com/clemera/frog-menu#example
  (defun frog-menu-flyspell-correct (candidates word)
    "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
    (let* ((corrects (if flyspell-sort-corrections
                         (sort candidates 'string<)
                       candidates))
           (actions `(("."   "Save word"         (save    . ,word))
                      ("C-a" "Accept (session)"  (session . ,word))
                      ("C-b" "Accept (buffer)"   (buffer  . ,word))
                      ("C-c" "Skip"              (skip    . ,word))))
           (prompt   (format "Dictionary: [%s]"  (or ispell-local-dictionary
                                                     ispell-dictionary
                                                     "default")))
           (res      (frog-menu-read prompt corrects actions)))
      (unless res
        (error "Quit"))
      (when (eq (car res) 'save)
        (spell-fu-word-add)
        (error "Handled with spell-fu"))
      res))

  (gsetq flyspell-correct-interface #'frog-menu-flyspell-correct))
#+end_src

**** Ace Flyspell
#+begin_src emacs-lisp
(use-package ace-flyspell
  :general (general-r "s" #'noct-flyspell-dwim)
  :config
  (gsetq ace-flyspell-handler #'flyspell-correct-at-point)

  (defun noct-flyspell-dwim (arg)
    "Correct or save a word.
If there is a misspelled word at point, correct it. With a prefix ARG, save the
word in the dictionary. Otherwise, select a misspelled word using avy. Save when
pressing \".\" before selecting the word. Otherwise, correct it."
    (interactive "P")
    (let ((avy-dispatch-alist '((?\. . spell-fu-word-add))))
      (if (cl-some #'spell-fu-overlay-p (overlays-at (point)))
          (if arg
              (spell-fu-word-add)
            (funcall ace-flyspell-handler))
        ;; doesn't have an autoload
        (ace-flyspell-correct-word)))))
#+end_src

*** Flycheck Aspell
*** Flycheck Hunspell
#+begin_src emacs-lisp
(use-package flycheck-hunspell
  :disabled t
  :straight (flycheck-hunspell
             :host github
             :repo "leotaku/flycheck-hunspell")
  :after flycheck
  :demand t
  :config
  (cl-pushnew 'plain-hunspell-dynamic flycheck-checkers)
  (gsetq ispell-really-hunspell t
         ispell-dictionary "en_US"))
#+end_src

*** Ispell
#+begin_src emacs-lisp
(use-package ispell
  :config
  ;; TODO try enchant

  ;; http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html
  ;; https://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html
  ;; https://blog.binchen.org/posts/aspell-0-60-8-will-have-direct-support-for-camelcase-words.html
  ;; https://battlepenguin.com/tech/aspell-and-hunspell-a-tale-of-two-spell-checkers/
  ;; Y

  (gsetq ispell-program-name "aspell"
         ispell-local-dictionary "en_US"
         ispell-local-dictionary-alist
         '(("en_US"
            "[[:alpha:]]"
            "[^[:alpha:]]"
            "[']"
            nil
            ("-d" "en_US")
            nil
            utf-8)))

  ;; TODO https://gitlab.com/ideasman42/emacs-spell-fu/-/issues/4
  (gsetq ispell-personal-dictionary "~/.aspell.en.pws")

  ;; https://old.reddit.com/r/emacs/comments/fxs92h/spell_checkers_in_emacs_in_2020/
  ;; aspell works with contractions, camelCase, kebab-case, etc.
  (gsetq ispell-extra-args
         '("--sug-mode=ultra" "--lang=en_US" "--camel-case")))
#+end_src

*** Spell Fu
#+begin_src emacs-lisp
(use-package spell-fu
  :when (executable-find "aspell")
  :init
  (defun noct-maybe-enable-spell-fu (orig-fun &rest args)
    (unless buffer-read-only
      (apply orig-fun args)))
  (general-add-advice 'spell-fu-mode-turn-on :around #'noct-maybe-enable-spell-fu)
  (noct-after-buffer (global-spell-fu-mode))
  :config
  (gsetq-default spell-fu-faces-exclude
                 (cl-union '(org-block org-block-begin-line)
                           spell-fu-faces-exclude))
  ;; repurpose ace-flyspell for spell-fu
  (defun spell-fu-overlay-p (o)
    "Return true if O is an overlay used by spell-fu."
    (and (overlayp o) (overlay-get o 'spell-fu-mode)))

  (defun ace-flyspell--has-spell-fu-overlay-p (ovs)
    (let ((r nil))
      (while (and (not r) (consp ovs))
        (if (spell-fu-overlay-p (car ovs))
            (setq r t)
          (setq ovs (cdr ovs))))
      r))

  (defun ace-flyspell--collect-spell-fu-candidates ()
    (save-excursion
      (save-restriction
        (narrow-to-region (window-start) (window-end (selected-window) t))
        (let ((pos (point-min))
              (pos-max (point-max))
              (pos-list nil)
              (word t))
          (goto-char pos)
          (while (and word (< pos pos-max))
            (setq word (flyspell-get-word t))
            (when word
              (setq pos (nth 1 word))
              (let* ((ovs (overlays-at pos))
                     (r (ace-flyspell--has-spell-fu-overlay-p ovs)))
                (when r
                  (push pos pos-list)))
              (setq pos (1+ (nth 2 word)))
              (goto-char pos)))
          (nreverse pos-list)))))

  (advice-add 'ace-flyspell--collect-candidates
              :override #'ace-flyspell--collect-spell-fu-candidates))
#+end_src

* Other Major Mode Configuration
** Alda
#+begin_src emacs-lisp
(use-package alda-mode
  :config
  (general-m alda-mode-map
    "b" #'alda-play-buffer))
#+end_src

** Apropos
#+begin_src emacs-lisp
(use-package apropos
  :straight (:type built-in)
  :init
  ;; TODO can this be put in :config?
  (noct-handle-popup apropos-mode)
  :config
  (gsetq apropos-do-all t)

  (general-def apropos-mode-map "q" #'quit-window))
#+end_src

** TODO AUCTeX
# https://www.emacswiki.org/emacs/AUCTeX
# https://www.gnu.org/software/auctex/manual/auctex/Quick-Start.html
# https://tex.stackexchange.com/questions/20843/useful-shortcuts-or-key-bindings-or-predefined-commands-for-emacsauctex
# http://wiki.contextgarden.net/What_is_ConTeXt
# http://pmrb.free.fr/contextref.pdf

** Conf Mode
#+begin_src emacs-lisp
(use-package conf-mode
  :straight (:type built-in)
  :mode ("rc\\'" . conf-unix-mode)
  :gfhook
  ('(conf-unix-mode-hook conf-xdefaults-mode-hook) #'outline-minor-mode))
#+end_src

** Comint
#+begin_src emacs-lisp
(use-package comint
  :straight (:type built-in)
  :config
  (general-def 'insert comint-mode-map
    ;; history
    "<up>" #'comint-previous-input
    "<down>" #'comint-next-input))
#+end_src

** Compilation mode
#+begin_src emacs-lisp
(general-with-package 'compile
  (gsetq compilation-always-kill t
         ;; save modified buffers without asking
         compilation-ask-about-save nil
         compilation-scroll-output 'first-error)

  ;; http://stackoverflow.com/a/20788581/2744245
  (defun my-colorize-compilation-buffer ()
    (require 'ansi-color)
    (when (eq major-mode 'compilation-mode)
      (ansi-color-apply-on-region compilation-filter-start (point-max))))

  (general-add-hook 'compilation-filter-hook #'my-colorize-compilation-buffer)

  (noct-handle-popup compilation-mode))
#+end_src

** Crontab
#+begin_src emacs-lisp
(use-package crontab-mode
  ;; kinda works for fcron
  :mode "fcrontab")
#+end_src

** Debugger
#+begin_src emacs-lisp
(general-with 'debug
  (general-def 'normal debugger-mode-map
    "q" #'debugger-quit)

  (general-after 'evil
    (general-add-hook 'debugger-mode-hook #'evil-normalize-keymaps)))
#+end_src

** Diff Mode
#+begin_src emacs-lisp
(use-package diff-mode
  :config
  (general-def 'normal diff-mode-map
    "q" #'quit-window))
#+end_src

** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :general
  (general-def help-map
    "RET" #'helpful-at-point
    "f" #'helpful-callable
    "v" #'helpful-variable
    "k" #'helpful-key
    "o" #'helpful-symbol)
  :init
  ;; using this instead of binding them directly allows taking an alternate action
  ;; without also opening the helpful buffer
  (gsetq counsel-describe-function-function #'helpful-callable
         counsel-describe-variable-function #'helpful-variable)
  :config
  (general-def 'normal helpful-mode
    :definer 'minor-mode
    "q" #'quit-window)

  (noct-handle-popup helpful-mode))
#+end_src

** Info mode
#+begin_src emacs-lisp
(use-package info
  :config
  (general-pushnew (expand-file-name "info" user-emacs-directory)
                   Info-additional-directory-list)

  (general-def 'normal Info-mode-map
    "ESC" #'quit-window))
#+end_src

** Lilypond
#+begin_src emacs-lisp
(use-package lilypond-mode
  ;; TODO from whence does lilypond come?
  :disabled
  :config
  (defun noct-lilypond-generate-midi ()
    "Produce a MIDI for the current lilypond file."
    (interactive)
    (async-shell-command (concat "lilypond " (shell-quote-argument buffer-file-name))))

  (general-m LilyPond-mode-map
    "c" #'noct-lilypond-generate-midi))
#+end_src

** Markdown
#+begin_src emacs-lisp
(use-package vmd-mode)

(use-package markdown-mode
  :config
  (general-m markdown-mode-map
    ;; preview
    "p" #'vmd-mode))
#+end_src

** Message
#+begin_src emacs-lisp
(general-with 'evil
  ;; (evil-set-initial-state 'messages-buffer-mode 'normal)
  ;; this won't work (runs too soon it seems)
  ;; (general-add-hook 'messages-buffer-mode-hook #'evil-normalize-keymaps)
  ;; this doesn't work
  ;; (general-add-advice 'after-find-file
  ;;                     :after (lambda (&rest _)
  ;;                              (when (eq major-mode 'messages-buffer-mode)
  ;;                                (evil-normalize-keymaps)
  ;;                                t))
  ;;                     nil
  ;;                     #'identity)
  ;; this is what fixes things
  ;; (general-add-hook 'post-command-hook
  ;;                   (lambda (&rest _)
  ;;                     (when (eq major-mode 'messages-buffer-mode)
  ;;                       (evil-normalize-keymaps)
  ;;                       t))
  ;;                   nil
  ;;                   nil
  ;;                   #'identity)
  (general-add-hook 'after-init-hook
                    (lambda (&rest _)
                      (when-let ((messages-buffer (get-buffer "*Messages*")))
                        (with-current-buffer messages-buffer
                          (evil-normalize-keymaps))))
                    nil
                    nil
                    t))
#+end_src

** Multiple Major Modes/Polymode
#+begin_src emacs-lisp
(use-package poly-org
  :disabled t
  ;; TODO shouldn't be enabled by default
  :general (noct-toggle-map "o" #'poly-org-mode)
  :config
  (general-def 'normal poly-org-mode-map "SPC u" #'worf-goto)

  (general-with 'lispy
    (mapc (lambda (x)
            (advice-add x :around #'pm-execute-narrowed-to-span))
          (append (apropos-internal "^lispy-" #'commandp)
                  (apropos-internal "^special-lispy-" #'commandp))))

  (general-add-advice '(outline-toggle-children
                        counsel-outline
                        counsel-semantic-or-imenu
                        worf-goto)
                      :around #'polymode-with-current-base-buffer))
#+end_src

** Org Mode
*** External/Contrib
**** Ox Hugo
#+begin_src emacs-lisp
(use-package ox-hugo
  :init
  (general-add-advice 'after-find-file
                      :before
                      (noct-defun noct-maybe-enable-org-hugo-auto-export
                          (&rest _)
                        (when (noct-blog-dir-p buffer-file-name)
                          (org-hugo-auto-export-mode))))
  (general-with 'ox
    (require 'ox-hugo)))
#+end_src

** Pentadactyl
#+begin_src emacs-lisp
(use-package dactyl-mode
  ;; package doesn't add to `auto-mode-alist'
  :mode "\\.pentadactylrc\\'")
#+end_src

** SaltStack
#+begin_src emacs-lisp
(use-package salt-mode)
#+end_src

** Special Mode
Used for =*Warnings*= buffer, for example.
#+begin_src emacs-lisp
(general-def 'normal special-mode-map
  "q" #'quit-window)
#+end_src

** Vimrc Mode
#+begin_src emacs-lisp
(use-package vimrc-mode)
#+end_src

** Which Key
#+begin_src emacs-lisp
(use-package which-key
  :defer 1
  :ghook ('pre-command-hook nil nil nil t)
  :general
  (noct-toggle-map "W" #'which-key-mode)
  (general-s "W" #'which-key-show-top-level)
  :init
  ;; should be set before loading
  (gsetq which-key-idle-delay 0.3)
  :blackout t
  :config
  (gsetq which-key-side-window-location 'top
         which-key-sort-order 'which-key-prefix-then-key-order
         which-key-sort-uppercase-first nil
         which-key-max-display-columns 5)

  (which-key-mode)

  (defun noct-mode-replacement (kb)
    "More generic version of a which-key example."
    (cons (car kb)
          (let ((mode-name (cdr kb))
                (mode (intern (cdr kb))))
            (cond ((and (boundp mode)
                        (symbol-value mode))
                   (concat "[X] " mode-name))
                  ((boundp mode)
                   (concat "[ ] " mode-name))
                  (t
                   mode-name)))))

  (general-pushnew (cons '(nil . "-mode\\'") #'noct-mode-replacement)
                   which-key-replacement-alist))
#+end_src

** Woman
#+begin_src emacs-lisp
(use-package woman
  :general (general-s "w" #'woman)
  :init
  (noct-handle-popup woman-mode))
#+end_src

** Xmodmap
I'm not really using xmodmap files anymore. Config taken from [[https://www.emacswiki.org/emacs/XModMapMode][here]].
#+begin_src emacs-lisp
(define-generic-mode 'xmodmap-mode
  '(?!)
  '("add" "clear" "keycode" "keysym" "remove" "pointer")
  nil
  '("[xX]modmap\\(rc\\)?\\'")
  nil
  "Simple mode for xmodmap files.")
#+end_src

** YAML mode
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

* Programming
** General and Prog Mode
*** Apheleia
#+begin_src emacs-lisp
;; really nice apart from this
;; https://github.com/raxod502/apheleia/issues/2
(use-package apheleia
  :straight (apheleia :host github :repo "raxod502/apheleia")
  :general
  (noct-toggle-map "h" #'apheleia-mode)
  (general-t "=" #'apheleia-format-buffer)
  ;; :init
  ;; this does not load apheleia until file save
  ;; (apheleia-global-mode)
  )
#+end_src

*** Docker
#+begin_src emacs-lisp
(use-package docker
  :config
  (noct-handle-popup "*docker")
  (noct-handle-popup "* docker"))

(use-package dockerfile-mode)

;; /docker:user@container:/path/to/file
(use-package docker-tramp
  :config
  ;; (gsetq docker-tramp-use-names t)
  )
#+end_src

*** Dtrt Indent
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core-editor.el#L339
(defvar doom-detect-indentation-excluded-modes '(fundamental-mode so-long-mode)
  "Major modes for which indentation should not be automatically detected.")

(defvar-local doom-inhibit-indent-detection nil
  "A buffer-local flag that indicates whether `dtrt-indent' should be used.
This should be set by editorconfig if it successfully sets
indent_style/indent_size.")

(defun doom-detect-indentation-h ()
  (unless (or (not after-init-time)
              doom-inhibit-indent-detection
              doom-large-file-p
              (memq major-mode doom-detect-indentation-excluded-modes)
              (member (substring (buffer-name) 0 1) '(" " "*"))
              (not (derived-mode-p 'prog-mode)))
    (dtrt-indent-mode +1)))

(use-package dtrt-indent
  :ghook ('(change-major-mode-after-body-hook read-only-mode-hook)
          'doom-detect-indentation-h)
  :blackout " ›"
  :config
  ;; Enable dtrt-indent even in smie modes so that it can update `tab-width',
  ;; `standard-indent' and `evil-shift-width' there as well.
  (gsetq dtrt-indent-run-after-smie t)
  ;; Reduced from the default of 5000 for slightly faster analysis
  (gsetq dtrt-indent-max-lines 2000)

  ;; always keep tab-width up-to-date
  (push '(t tab-width) dtrt-indent-hook-generic-mapping-list)

  (defvar dtrt-indent-run-after-smie)
  (defun doom--fix-broken-smie-modes-a (orig-fn arg)
    "Some smie modes throw errors when trying to guess their indentation.
One example is `nim-mode'. This prevents them from leaving Emacs in a broken
state."
    (let ((dtrt-indent-run-after-smie dtrt-indent-run-after-smie))
      (cl-letf* ((old-smie-config-guess (symbol-function 'smie-config-guess))
                 (old-smie-config--guess
                  (symbol-function 'symbol-config--guess))
                 ((symbol-function 'symbol-config--guess)
                  (lambda (beg end)
                    (funcall old-smie-config--guess beg (min end 10000))))
                 ((symbol-function 'smie-config-guess)
                  (lambda ()
                    (condition-case e (funcall old-smie-config-guess)
                      (error (setq dtrt-indent-run-after-smie t)
                             (message "[WARNING] Indent detection: %s"
                                      (error-message-string e))
                             (message "")))))) ; warn silently
        (funcall orig-fn arg))))

  (general-add-advice 'dtrt-indent-mode :around #'doom--fix-broken-smie-modes-a))
#+end_src

*** Editorconfig
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/bb702acfd06bd55f7726678f0a24d7242fff1c2d/modules/tools/editorconfig/config.el#L55
(defvar doom-+editorconfig-mode-alist
  '((emacs-lisp-mode . "el")
    (enh-ruby-mode   . "rb")
    (js2-mode        . "js")
    (perl-mode       . "pl")
    (php-mode        . "php")
    (python-mode     . "py")
    (ruby-mode       . "rb")
    (sh-mode         . "sh"))
  "An alist mapping major modes to extensions.
Used by `doom--editorconfig-smart-detection-a' to give editorconfig filetype
hints.")

(use-package editorconfig
  :init
  ;; won't work first time if use `find-file-hook'; advise `after-find-file'
  ;; instead like doom does
  (noct-after-buffer (editorconfig-mode))
  :blackout t
  :config
  (defun doom--editorconfig--smart-detection-a (orig-fn)
    "Retrieve the properties for the current file.
If it doesn't have an extension, try to guess one."
    (let ((buffer-file-name
           (if (and (not (bound-and-true-p org-src-mode))
                    (file-name-extension buffer-file-name))
               buffer-file-name
             (format "%s%s" (buffer-file-name (buffer-base-buffer))
                     (if-let* ((ext (cdr (assq major-mode
                                               doom-+editorconfig-mode-alist))))
                         (concat "." ext)
                       "")))))
      (funcall orig-fn)))
  ;; extend doom's configuration to also work for org src blocks
  (general-add-advice 'editorconfig-apply
                      :around #'doom--editorconfig--smart-detection-a)
  (general-add-hook 'org-src-mode-hook #'editorconfig-apply)

  (defun doom-+editorconfig-disable-ws-butler-maybe-h (props)
    "Disable `ws-butler-mode' if trim_trailing_whitespace is true."
    (when (and (equal (gethash 'trim_trailing_whitespace props) "true")
               (bound-and-true-p ws-butler-mode))
      (ws-butler-mode -1)))
  (general-add-hook 'editorconfig-after-apply-functions
                    #'doom-+editorconfig-disable-ws-butler-maybe-h)

  (defun doom-+editorconfig-disable-indent-detection-h (props)
    "Inhibit `dtrt-indent' if indent_style or indent_size is configured."
    (when (or (gethash 'indent_style props)
              (gethash 'indent_size props))
      (setq doom-inhibit-indent-detection 'editorconfig)))
  (general-add-hook 'editorconfig-after-apply-functions
                    #'doom-+editorconfig-disable-indent-detection-h))
#+end_src

*** Prog Mode Setup
#+begin_src emacs-lisp
(general-add-hook 'after-save-hook
                  #'executable-make-buffer-file-executable-if-script-p)

(defun noct-prog-mode-setup ()
  (setq-local comment-auto-fill-only-comments t))

(general-add-hook 'prog-mode-hook (list #'noct-prog-mode-setup #'auto-fill-mode))
(blackout 'auto-fill-mode)
#+end_src

*** Prog Mode Keybindings
#+begin_src emacs-lisp
(general-with-package 'prog-mode
  (general-m prog-mode-map
    "c" #'compile
    "g" #'first-error))
#+end_src

*** Makefile Executor
#+begin_src emacs-lisp
(use-package makefile-executor
  :general
  (general-t "m" #'makefile-executor-execute-project-target))
#+end_src

*** TODO Taskrunner
=helm-make= doesn't work projectwide. Makefile-executor does but is slow. This seems promising, but it doesn't work at all for me.
#+begin_src emacs-lisp
;; https://github.com/emacs-taskrunner/ivy-taskrunner/issues/2
(use-package taskrunner)
(use-package ivy-taskrunner
  :straight (ivy-taskrunner
             :host github
             :repo "emacs-taskrunner/ivy-taskrunner"))
#+end_src

*** Semantic
Lispy, for example, relies on semantic.
**** Bug Workaround
See [[https://github.com/company-mode/company-mode/issues/525][this issue]].
#+begin_src emacs-lisp
(general-with-package 'semantic
  ;; updated from:
  ;; https://github.com/company-mode/company-mode/issues/525#issuecomment-348635719
  (defun semantic-completion-advice (adviced-f &rest r)
    "Check if POINT it's inside a string or comment before calling semantic-*"
    (unless (or
             ;; in string
             (nth 3 (syntax-ppss))
             ;; in comment
             (save-excursion
               (unless (eolp)
                 (forward-char 1))
               (nth 4 (syntax-ppss))))
      (apply adviced-f r)))

  (general-add-advice '(semantic-analyze-completion-at-point-function
                        semantic-analyze-notc-completion-at-point-function
                        semantic-analyze-nolongprefix-completion-at-point-function)
                      :around #'semantic-completion-advice))
#+end_src

*** Vagrant Tramp
#+begin_src emacs-lisp
(use-package vagrant-tramp)
#+end_src

*** Visual
**** Rainbow Delimiters
[[https://github.com/istib/rainbow-blocks][rainbow-blocks]] is a fork of rainbow-delimeters that highlights the entire block. There is also [[https://github.com/seanirby/rainbow-blocks-bg][rainbow-blocks-bg]]. I personally find these to be too much color.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ghook
  noct-lisp-mode-hooks
  'c-mode-hook)
#+end_src

**** Highlight Parentheses
#+begin_src emacs-lisp
(use-package highlight-parentheses
  :ghook 'prog-mode-hook
  :blackout t
  :config
  (gsetq hl-paren-colors '("firebrick1"))

  (custom-set-faces '(hl-paren-face ((t :inherit show-paren-match)))))
#+end_src

**** Eldoc
#+begin_src emacs-lisp
;; deferred incrementally by other packages
(use-package eldoc
  :blackout t
  :config
  (gsetq eldoc-idle-delay 0.1)

  (global-eldoc-mode))
#+end_src

**** Higlight Numbers
#+begin_src emacs-lisp
(use-package highlight-numbers
  :ghook 'prog-mode-hook)
#+end_src

**** TODO Fixmes
***** Fic Mode
Doesn't work well (highlighting doesn't show up for new... goes away if go to line)
#+begin_src emacs-lisp
(use-package fic-mode
  :disabled t
  :ghook 'prog-mode-hook
  :config
  (gsetq fic-highlighted-words '("TODO" "FIXME" "OPTIMIZE" "HACK" "REVIEW" "BUG"))

  ;; remove white background
  (set-face-attribute 'fic-face nil :background nil)
  (set-face-attribute 'fic-author-face nil :background nil))
#+end_src
***** Fixmee Mode
Breaks syntax highlighting.
#+begin_src emacs-lisp
(use-package fixmee
  :disabled t
  :init (global-fixmee-mode))
#+end_src

***** Alternate Solution
#+begin_src emacs-lisp
(defun noct-font-lock-todo ()
  (font-lock-add-keywords
   nil
   ;; https://github.com/bbatsov/emacs-lisp-style-guide#comment-annotations
   '(("\\<\\(TODO\\|FIXME\\|OPTIMIZE\\|HACK\\|REVIEW\\|BUG\\)"
      1 font-lock-warning-face prepend))))

(general-add-hook 'prog-mode-hook #'noct-font-lock-todo)
#+end_src

*** Aggressive and Electric Indent
#+begin_src emacs-lisp
(defconst noct-no-electric-mode-hooks
  ;; don't indent after bullet points in org-mode
  '(org-mode-hook)
  "Mode hooks to disable `electric-indent-mode' in.")

(general-add-hook noct-no-electric-mode-hooks
                  (lambda () (electric-indent-local-mode -1)))

(use-package aggressive-indent
  ;; works best in lisp modes; in ALGOL-style languages will get annoying shifts
  ;; when typing if statements for example
  ;; also not great in other people's projects
  :ghook noct-lisp-mode-hooks
  :general
  (general-def noct-toggle-map "a" #'aggressive-indent-mode)
  :blackout t
  :config
  (general-pushnew 'python-mode aggressive-indent-excluded-modes)
  (general-pushnew 'asm-mode aggressive-indent-excluded-modes)
  (general-pushnew 'nix-mode aggressive-indent-excluded-modes))
#+end_src

*** Dumb Jump
#+begin_src emacs-lisp
(use-package dumb-jump
  :general ('normal "gd" #'dumb-jump-go)
  :config
  ;; TODO first check that ivy and rg are installed
  (gsetq dumb-jump-selector 'ivy
         dumb-jump-prefer-searcher 'rg))
#+end_src

*** Smart Jump
#+begin_src emacs-lisp
(use-package smart-jump
  :general
  ('normal "gs" #'smart-jump-go)
  (general-m prog-mode-map "x" #'smart-jump-references)
  ;; TODO consider this
  ;; (general-def prog-mode-map
  ;;   "RET" #'smart-jump-go
  ;;   "<S-Return>" #'smart-jump-back)
  :config
  (smart-jump-setup-default-registers)

  (smart-jump-register :modes '(emacs-lisp-mode lisp-interaction-mode)
                       :jump-fn #'xref-find-definitions
                       :pop-fn #'pop-tag-mark
                       :refs-fn #'xref-find-references
                       :should-jump t
                       :heuristic #'error
                       :async nil))
#+end_src

*** Electric Operator Mode
This is a maintained fork of =electric-spacing=.
#+begin_src emacs-lisp
(use-package electric-operator
  :ghook
  'python-mode-hook
  'c-mode-hook)
#+end_src

*** TODO Electric Case
*** Flycheck
**** Setup
#+begin_src emacs-lisp
(use-package flycheck
  :init
  (noct-after-buffer
    (global-flycheck-mode))
  :blackout t
  :config
  ;; decrease delay before showing error
  (gsetq flycheck-display-errors-delay 0.2)

  (general-def noct-toggle-map "f" #'flycheck-mode)

  (general-m
    "F" #'flycheck-list-errors
    "n" #'flycheck-next-error
    "e" #'flycheck-previous-error)

  (general-def 'normal flycheck-error-list-mode
    "q" #'quit-window)

  (noct-handle-popup flycheck-error-list-mode))
#+end_src

**** Flycheck Pos Tip
Compared to other flycheck frontends, pos tip is pretty slow and can cause significant input lag when company mode is enabled.
#+begin_src emacs-lisp
(use-package flycheck-pos-tip
  :disabled t
  :ghook 'flycheck-mode-hook
  :config
  (general-add-hook 'lsp-after-open-hook (noct-disable flycheck-pos-tip-mode)))
#+end_src

**** Flycheck Inline
Seems fast but the addition of extra lines is jarring. I've updated the display function to show over the line after the error. It now handles multiple error messages (at the end of the buffer too).
#+begin_src emacs-lisp
  (use-package flycheck-inline
    :ghook 'flycheck-mode-hook
    :config
    ;; NOTE: unicode prefix makes it shift the line down slightly
    ;; (defconst noct-flycheck-prefix "➵ ")
    (defconst noct-flycheck-prefix "~> ")
  
    (defvar-local noct-flycheck-inline-last-error-point nil)
  
    (defun noct-flycheck-inline-phantom-display (msg &optional pos err)
      "Display MSG in a phantom starting at the beginning of the next line.
  
  MSG is a string that will be put in a line-long overlay (phantom) at the line

  after POS. If POS is nil, current point is used instead.
  
  ERR is the flycheck error
  
  Return the displayed phantom."
      ;; don't use pos;
      (setq noct-flycheck-inline-last-error-point (point))
      (pcase-let* ((p (or pos (point)))
                   (`(,pos-bol . ,pos-eol)
                    (save-excursion
                      (goto-char p)
                      (while (and (not (= (forward-line) 1))
                                  (cl-some (lambda (ov)
                                             (= (point-at-bol)
                                                (overlay-start ov)))
                                           flycheck-inline--phantoms)))
                      (cons (point-at-bol) (point-at-eol))))
                   (str (concat
                         (when (= pos-eol (point-max))
                           "\n")
                         noct-flycheck-prefix
                         msg)))
        ;; don't create duplicate overlays
        (when (not (cl-some (lambda (ov)
                              (member str
                                      (list (overlay-get ov 'after-string)
                                            (overlay-get ov 'display))))
                            flycheck-inline--phantoms))
          (let ((ov (make-overlay
                     (if (= pos-eol (point-max))
                         pos-eol
                       pos-bol)
                     pos-eol)))
            (overlay-put ov 'phantom t)
            (overlay-put ov 'error err)
            (overlay-put ov
                         (if (or (= pos-eol (point-max))
                                 (= pos-bol pos-eol))
                             'after-string
                           'display)
                         str)
            (push ov flycheck-inline--phantoms)
            ov))))
  
    (gsetq flycheck-inline-display-function
           #'noct-flycheck-inline-phantom-display)
  
    (defun general-flycheck-inline-hide-errors ()
      "Hide all inline messages currently being shown if point has changed."
      (when (and noct-flycheck-inline-last-error-point
                 (not (= noct-flycheck-inline-last-error-point (point))))
        (funcall flycheck-inline-clear-function)))
  
    ;; prevent errors from disappearing unless point moves
    (general-add-advice 'flycheck-inline-hide-errors
                        :override #'general-flycheck-inline-hide-errors))
#+end_src

**** TODO Flycheck Posframe
Looks very nice but has various bugs (last character in message sometimes doesn't show, posframe often appears as empty, etc.).
#+begin_src emacs-lisp
(use-package flycheck-posframe
  :disabled t
  :ghook 'flycheck-mode-hook
  :config (flycheck-posframe-configure-pretty-defaults))
#+end_src

**** TODO LSP Sideline
https://github.com/emacs-lsp/lsp-ui/issues/437

*** Xref
#+begin_src emacs-lisp
(general-with 'xref
  ;; window for selecting between definition and variable
  (noct-handle-popup "*xref*")

  (defun noct-xref-find-definition ()
    "Call `xref-find-definitions' but prompt for identifier.
Don't immediately jump to the symbol at the point."
    (interactive)
    (call-interactively #'xref-find-definitions))

  (general-def help-map "x" #'noct-xref-find-definition))

;; now using consult
;; (use-package ivy-xref
;;   :init
;;   (gsetq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+end_src

*** LSP Mode
TODO lsp-use-plists (https://github.com/emacs-lsp/lsp-mode/issues/1807 now fixed)
#+begin_src emacs-lisp
(use-package lsp-mode
  :config
  (gsetq
   ;; https://github.com/emacs-lsp/lsp-mode#performance
   lsp-prefer-capf t
   read-process-output-max (* 1024 1024)
   lsp-headerline-breadcrumb-enable nil)

  (general-def 'normal lsp-mode-map
    "N" #'lsp-describe-thing-at-point
    "RET" #'lsp-find-definition)

  (gsetq lsp-keymap-prefix "mm")
  (general-add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)

  (general-m lsp-mode-map
    "m" lsp-command-map
    "a" #'lsp-execute-code-action
    "v" #'lsp-avy-lens
    "i" #'lsp-goto-implementation
    "D" #'lsp-find-declaration
    "T" #'lsp-find-type-definition
    ;; cross (x) references
    "x" #'lsp-find-references
    "r" #'lsp-rename
    "R" #'lsp-restart-workspace
    "=" #'lsp-format-buffer
    "l" #'lsp-workspace-show-log))

(use-package lsp-ui
  :gfhook
  ('lsp-ui-doc-frame-mode-hook (noct-disable display-line-numbers-mode))
  :config
  (gsetq lsp-ui-sideline-ignore-duplicate t))

(use-package lsp-ivy
  :disabled t
  :after lsp-mode
  :general
  (general-m lsp-mode-map
    "y" #'lsp-ivy-workspace-symbol))

(use-package consult-lsp
  :after lsp-mode
  :general
  (general-m lsp-mode-map
    "y" #'consult-lsp-symbols
    "E" #'consult-lsp-diagnostics))

;; Chaining checkers to lsp; search for `yyoncho-flycheck-local-cache' for uses
(defvar-local yyoncho-flycheck-local-cache nil)
(defun yyoncho-flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker yyoncho-flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around #'yyoncho-flycheck-checker-get)
#+end_src

*** Tree Sitter
Currently, tree sitter can be used for syntax highlighting. There is also the package tree-sitter-indent, but it currently only supports Rust.
#+begin_src emacs-lisp
(use-package tree-sitter
  :ghook
  ('prog-mode-hook #'global-tree-sitter-mode nil nil t)
  ('tree-sitter-after-on-hook #'tree-sitter-hl-mode))

(use-package tree-sitter-langs)
#+end_src

** Lisps (General)
*** Lispy
TODO
- Use c-8 and c-9 and c-ret more
- probably split this section up

#+begin_src emacs-lisp
;; TODO why is hydra/lv loaded?! (even if never load lispy)
(use-package lispy
  :straight (lispy
             :local-repo "~/src/forks/lispy"
             :protocol ssh
             :fork t)
  :defer-incrementally
  (mode-local
   lispy-tags
   help-fns
   edebug
   etags
   outline
   avy
   newcomment
   lispy-inline
   delsel
   swiper
   pcase
   hydra)
  :ghook
  noct-lisp-mode-hooks
  ;; TODO RET doesn't work first time run `eval-expression'
  'eval-expression-minibuffer-setup-hook
  ;; use shortcake as lighter!
  :blackout " 🍰"
  :config
  ;; for insertion; some looking at checks too though
  ;; (gsetq-default lispy-outline-header ";; ")
  (gsetq lispy-avy-keys avy-keys
         lispy-avy-style-paren 'at-full
         ;; lispy-avy-style-char 'at-full
         ;; lispy-avy-style-symbol 'at-full
         ;; lispy-eval-display-style 'overlay
         lispy-safe-delete t
         lispy-safe-copy t
         lispy-safe-paste t
         lispy-safe-actions-no-pull-delimiters-into-comments t
         lispy-delete-sexp-from-within t
         lispy-parens-only-left-in-string-or-comment nil
         ;; TODO see how performant is at larger thresholds and optimize
         lispy-safe-threshold 5000
         lispy-use-sly t
         ;; allow space before asterisk for headings (e.g. ";; *")
         lispy-outline (rx (and bol ";;" (or (and ";" (not (any "#")))
                                             (and (0+ space) (1+ "*"))))))

  (general-def noct-toggle-map "l" #'lispy-mode)

  (general-def 'normal lispy-mode-map
    "SPC y" #'lispy-goto)

  (defun noct-lispy-tab (arg)
    "`outline-toggle-children' if at a heading or `lispy-indent-adjust-parens'."
    (interactive "p")
    (if (looking-at lispy-outline)
        (outline-toggle-children)
      (lispy-indent-adjust-parens arg)))

  (general-def lispy-mode-map-lispy
    "]" nil
    "[" nil
    ":" nil
    ;; exit quotes with "
    "\"" #'lispy-doublequote
    "(" #'lispy-parens-auto-wrap
    "[" #'lispy-brackets-auto-wrap
    "{" #'lispy-braces-auto-wrap
    "TAB" #'noct-lispy-tab
    "<backtab>" #'lispy-dedent-adjust-parens
    "M-h" #'lispy-beginning-of-defun
    ;; "<C-return>" #'lispy-alt-line
    "<C-return>" #'lispy-parens-down
    ;; TODO maybe also bind key to do ret then ()
    "M-d" #'lispy-kill-at-point)
  ;; 'lispy-close-round-and-newline

  ;; override lh-knight for colemak keys
  (defhydra lh-knight ()
    "knight"
    ("n" lispy-knight-down)
    ("e" lispy-knight-up)
    ("z" nil))

  ;; TODO this needs a lot of work
  (defun noct-lispy-delete (arg)
    "Copy and delete current sexp.
Passes ARG to `lispy-delete' or `lispy-delete-backward'."
    (interactive "p")
    (let ((regionp (region-active-p)))
      (cond ((or (lispy-left-p)
                 regionp)
             (lispy-new-copy)
             (lispy-delete arg)
             (unless regionp
               (lispy--indent-for-tab)
               ;; (when (and (looking-at "[[:space:]]*$")
               ;;            (lispy-looking-back "^[[:space:]]*"))
               ;;   (delete-region (line-beginning-position)
               ;;                  (1+ (line-end-position))))
               (cond ((ignore-errors (forward-list))
                      (backward-list)
                      ;; (lispy-delete-backward 1)
                      )
                     ((ignore-errors (backward-list))
                      (forward-list)
                      ;; (lispy-delete 1)
                      (backward-list)
                      )
                     (t))))
            ((lispy-right-p)
             (lispy-new-copy)
             (lispy-delete-backward arg)))))

  (general-def lispy-mode-map
    :definer 'lispy
    "n" #'lispy-down                    ; lose lispy-new-copy -> y
    "e" #'lispy-up                      ; lose lispy-eval -> l
    "i" #'lispy-right                   ; lose lispy-tab -> t
    ;; N and E instead of s and w
    "N" #'lispy-move-down               ; lose lispy-narrow -> w
    "E" #'lispy-move-up                 ; lose lispy-eval-and-insert -> L
    "l" #'lispy-eval                    ; (freed by i)
    "L" #'lispy-eval-and-insert         ; (unbound)
    "y" #'lispy-new-copy                ; lose lispy-occur -> /
    "/" #'lispy-occur                   ; lose lispy-splice -> x
    "w" #'lispy-narrow                  ; lose lispy-move-up -> f
    "x" #'lispy-splice                  ; lose lispy-x -> c
    "c" #'lispy-x                       ; lose lispy-clone -> q
    "f" #'lispy-ace-paren               ; lose lispy-flow -> k
    "F" #'lispy-ace-char                ; lose lispy-follow
    "q" #'lispy-clone                   ; (freed by f)
    "t" #'lispy-tab                     ; lose lispy-teleport -> j
    "j" #'lispy-teleport                ; (freed by n)
    "d" #'noct-lispy-delete             ; lose lispy-different -> o
    ;; like in visual state
    "o" #'lispy-different               ; lose lispy-other-mode (don't use)
    "J" #'lispy-goto-mode               ; from lispy-other-mode (freed by N)
    "k" #'lispy-flow                    ; (freed by e)
    ;; swap p and P
    "p" #'lispy-paste
    "P" #'lispy-eval-other-window
    ;; swap m and v
    "v" #'lispy-mark-list
    "m" #'lispy-view
    ;; swap H and A; makes more sense given h and a
    "H" #'lispy-beginning-of-defun
    "A" #'lispy-ace-symbol-replace
    ;;  make slurp/barf behavior directional (as opposed to grow/shrink)
    ">" #'lispy-slurp-or-barf-right
    "<" #'lispy-slurp-or-barf-left
    ;; useful for writing tests
    "s" #'lispy-stringify-oneline       ; (freed by N)
    "S" #'lispy-string-oneline)

  (defun noct-paren-advice (&rest _)
    (unless (lispy--in-string-or-comment-p)
      (let ((map (make-sparse-keymap)))
        ;; easy way to undo unwanted wrap on reaction
        ;; instead of planning with a prefix arg
        (define-key map ")"
          (lambda ()
            (interactive)
            (call-interactively #'lispy-barf-to-point)
            (backward-char)))
        (set-transient-map map))))

  (general-add-advice 'lispy-parens-auto-wrap :after #'noct-paren-advice)

  (noct-add-undo-bounds 'lispy-yank)
  (noct-add-undo-bounds 'lispy-fill))
#+end_src

*** Lispyville
#+begin_src emacs-lisp
(use-package lispyville
  :straight (lispyville
             :protocol ssh
             :local-repo "~/src/emacs/lispyville/")
  :ghook 'lispy-mode-hook
  :blackout ((lispyville-mode . (lispyville-mode-line-string " 🍙" " 🍙")))
  :config
  (gsetq lispyville-motions-put-into-special t)

  (general-def noct-toggle-map "y" #'lispyville-mode)

  (lispyville-set-key-theme
   '(operators c-w c-u prettify slurp/barf-cp insert mark-toggle))

  (general-def lispy-mode-map
    :definer 'lispy
    "v" #'lispyville-toggle-mark-type)

  (general-def 'normal lispyville-mode-map
    "H" #'lispyville-beginning-of-defun
    "(" #'lispyville-left
    ")" #'lispyville-right))
#+end_src

*** Highlight Quoted
#+begin_src emacs-lisp
(use-package highlight-quoted
  :ghook noct-lisp-mode-hooks)
#+end_src

*** Highlight Stages (Macros)
For quasi-quoted expressions.
#+begin_src emacs-lisp
(use-package highlight-stages
  :ghook noct-lisp-mode-hooks
  :blackout t
  :config
  (gsetq highlight-stages-highlight-real-quote nil))
#+end_src

** C
#+begin_src emacs-lisp
(use-package cc-mode
  :config
  (gsetq-default c-basic-offset 4)
  (setf (alist-get 'other c-default-style) "linux")

  (general-def 'insert c-mode-map
    "RET" #'c-indent-new-comment-line))
#+end_src

** cc-mode
** Clojure
TODO look at these:
- https://github.com/candid82/flycheck-joker
- https://github.com/clojure-emacs/squiggly-clojure
- https://github.com/sanel/monroe
- https://github.com/seanirby/cider-buddy
- etc.

*** Setup
#+begin_src emacs-lisp
(use-package clojure-mode)
#+end_src

*** Cider
TODO read docs
- https://cider.readthedocs.io/en/latest/
- https://www.youtube.com/watch?v=aYA4AAjLfT0
#+begin_src emacs-lisp
(use-package cider
  :ghook 'clojure-mode-hook
  :config
  (general-m clojure-mode-map
    "j" #'cider-jack-in
    "l"  #'cider-eval-last-sexp
    "n" #'cider-repl-set-ns
    "b" #'cider-load-buffer
    "d" #'cider-eval-defun-at-point)

  (general-def 'normal clojure-mode-map
    "RET" #'cider-find-var
    "N" #'cider-doc)

  ;; repl maps
  (general-def 'insert cider-repl-mode-map
    "<up>" #'cider-repl-backward-input
    "<down>" #'cider-repl-forward-input))
#+end_src

** Emacs Lisp
*** Setup
#+begin_src emacs-lisp
(use-package elisp-mode
  :straight (:type built-in)
  :config
  ;; increase docstring fill column
  (gsetq emacs-lisp-docstring-fill-column 80)

  (defun noctuid:byte-compile ()
    "Byte compile the current file."
    (interactive)
    (byte-compile-file (buffer-file-name)))

  (general-m emacs-lisp-mode-map
    "b" #'eval-buffer
    "d" #'eval-defun
    "c" #'noctuid:byte-compile)

  (general-def 'normal emacs-lisp-mode-map
    "RET" #'xref-find-definitions
    "<S-return>" #'pop-tag-mark
    "N" #'helpful-at-point))
#+end_src

*** TODO Indentation Setup
Builtin indentation should be better...
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
(defun fuco1/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

- `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))


(defun noct-lispy-indent-setup ()
  "Make indentation settings compliant with lispy's."
  (interactive)
  ;; https://github.com/abo-abo/oremacs/blob/github/modes/ora-elisp-style-guide.el
  (require 'cl-indent)
  (setq-local lisp-indent-function #'common-lisp-indent-function)
  ;; TODO this is bad for actual common lisp (and not buffer-local)
  (put 'if 'common-lisp-indent-function 2)
  (put 'defface 'common-lisp-indent-function 1)
  (put 'define-minor-mode 'common-lisp-indent-function 1)
  (put 'define-derived-mode 'common-lisp-indent-function 3)
  (put 'cl-flet 'common-lisp-indent-function
       (get 'flet 'common-lisp-indent-function))
  (put 'cl-labels 'common-lisp-indent-function
       (get 'labels 'common-lisp-indent-function))
  ;; additional
  (put 'cl-macrolet 'common-lisp-indent-function (get 'flet 'common-lisp-indent-function))
  (aggressive-indent-mode -1))

(defun noct-elisp-indent-setup ()
  (when (eq major-mode 'emacs-lisp-mode)
    (cond ((when (buffer-file-name)
             (string-match
              ".*lispy/"
              (file-name-directory (buffer-file-name))))
           (noct-lispy-indent-setup))

          (t
           (setq-local lisp-indent-function #'fuco1/lisp-indent-function)
           (put 'cl-macrolet 'lisp-indent-function
                (get 'flet 'common-lisp-indent-function))
           (put 'cl-macrolet 'fuco1/lisp-indent-function
                (get 'flet 'common-lisp-indent-function))))))

(general-add-hook '(find-file-hook emacs-lisp-mode-hook) #'noct-elisp-indent-setup)
#+end_src

*** Cl-lib Highlight
Highlight =cl= functions that aren't prefixed with =cl-=.
#+begin_src emacs-lisp
(use-package cl-lib-highlight
  ;; elisp-mode is loaded before emacs-lisp-buffer
  ;; :after elisp-mode
  :ghook ('emacs-lisp-mode-hook #'cl-lib-highlight-initialize nil nil t)
  :config (cl-lib-highlight-warn-cl-initialize))
#+end_src

*** Highlight Defined
Highlight defined elisp symbols.
#+begin_src emacs-lisp
(use-package highlight-defined
  :ghook 'emacs-lisp-mode-hook)
#+end_src

*** Macrostep
#+begin_src emacs-lisp
(use-package macrostep
  :general
  (lispy-mode-map
   :definer 'lispy
   ;; don't really use `lispy-view' (I've swapped v and m)
   "m" #'macrostep-expand)
  :blackout " 🍔"
  :config
  ;; ~/src/forks/evil-collection/evil-collection-macrostep.el
  (evil-collection-init 'macrostep))
#+end_src

*** Buttercup
#+begin_src emacs-lisp
(use-package buttercup)
#+end_src

*** Cask
#+begin_src emacs-lisp
(use-package cask-mode)
#+end_src

*** IELM
#+begin_src emacs-lisp
(general-with-package 'ielm
  (general-def 'normal ielm-map
    "mb" #'eval-buffer
    "md" #'eval-defun
    "RET" #'xref-find-definitions
    "<S-Return>" #'pop-tag-mark
    "N" #'helpful-at-point)

  (with-eval-after-load 'lispy
    (defun noct-ielm-newline-or-return ()
      "An alternative to setting `ielm-dynamic-return' to nil.
This will only run `ielm-return' when at the end of the buffer."
      (interactive)
      (if (looking-at "\\'")
          (ielm-return)
        (lispy-newline-and-indent)))

    (general-def 'insert ielm-map
      "RET" #'noct-ielm-newline-or-return)))
#+end_src

*** Flycheck Package
#+begin_src emacs-lisp
(use-package flycheck-package
  :after elisp-mode
  :after flycheck
  :demand t
  :config
  (flycheck-package-setup)

  (defun noct-disable-flycheck-emacs-lisp-checkdoc ()
    "Disable the emacs lisp package and checkdoc checkers."
    (when (featurep 'flycheck)
      (cl-pushnew 'emacs-lisp-checkdoc flycheck-disabled-checkers)))
  (general-add-hook 'org-src-mode-hook #'noct-disable-flycheck-emacs-lisp-checkdoc)

  (defun noct-maybe-disable-flycheck-emacs-lisp-checkdoc ()
    (when (and buffer-file-name
               (string= (file-name-nondirectory buffer-file-name) "init.el"))
      (noct-disable-flycheck-emacs-lisp-checkdoc)))
  (general-add-hook 'find-file-hook #'noct-maybe-disable-flycheck-emacs-lisp-checkdoc))
#+end_src

** Fennel
#+begin_src emacs-lisp
(use-package fennel-mode
  :config
  (general-def 'normal fennel-mode-map
    "RET" #'fennel-find-definition)
  (general-m fennel-mode-map
    "c" #'fennel-view-compilation
    "d" #'lisp-eval-defun
    ";" #'fennel-repl
    "=" #'fennel-format)

  ;; https://gitlab.com/technomancy/fennel-mode/-/issues/11
  ;; fennel-mode incorrectly inherits from lisp-mode; TODO need to make more
  ;; changes than this to fix
  (defun noct-unless-fennel (fun &rest args)
    "Don't run FUN with ARGS if `fennel-mode'."
    (unless (memq major-mode '(fennel-mode fennel-repl-mode))
      (apply fun args)))

  (general-add-advice '(sly-mode sly-editing-mode)
                      :around #'noct-unless-fennel)

  (noct-handle-popup inferior-lisp-mode))

#+end_src

** Groovy/Gradle
#+begin_src emacs-lisp
(use-package groovy-mode)
#+end_src

** Haskell
TODO
- Try [[http://chrisdone.github.io/intero/][Intero]] and [[https://github.com/jyp/dante][Dantle]] and HIE/LSP; [[http://haroldcarr.com/posts/2017-10-24-emacs-haskell-dev-env.html][Relevant article]]; https://www.reddit.com/r/haskell/comments/9bxbwp/which_ide_are_you_using_for_hakell/

*** Setup
#+begin_src emacs-lisp
;; https://github.com/haskell/haskell-mode/wiki
(use-package haskell-mode
  :config
  (general-m haskell-mode-map
    "N" #'haskell-navigate-imports
    "i" #'haskell-mode-format-imports
    "c" #'haskell-compile
    ;; #'haskell-debug
    "b" #'haskell-process-load-file
    "f" #'haskell-mode-stylish-buffer))
#+end_src

*** GHC
#+begin_src emacs-lisp
(use-package ghc
  :ghook ('haskell-mode-hook #'ghc-init)
  :config
  (general-m haskell-mode-map
    "n" #'ghc-goto-next-error
    "e" #'ghc-goto-prev-error
    "?" #'ghc-display-errors))
#+end_src

*** Company GHC
#+begin_src emacs-lisp
(use-package company-ghc
  :after (company haskell-mode)
  :config
  (general-pushnew '(company-ghc :with company-yasnippet) company-backends))
#+end_src

*** Flycheck Haskell
#+begin_src emacs-lisp
(use-package flycheck-haskell
  :disabled t
  :ghook ('flycheck-mode-hook #'flycheck-haskell-setup))
#+end_src

*** Hindent
[[https://github.com/chrisdone/hindent][Hindent - Haskell pretty print er]]. There are an unholy number of pretty printers (also stylish-haskell and brittany); [[https://github.com/quchen/prettyprinter][prettyprinter]] seems to be the most recommended at the moment.
#+begin_src emacs-lisp
(use-package hindent
  :ghook 'haskell-mode-hook
  :config
  (general-m haskell-mode-map
    "q" #'hindent-reformat-decl-or-fill))
#+end_src

*** TODO HaRe
*** TODO SHM
*** TODO Hasktags
** JSON
#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** Kmonad
#+begin_src emacs-lisp
(use-package kbd-mode
  :straight (kbd-mode :host github :repo "kmonad/kbd-mode"))
#+end_src

** Lua
#+begin_src emacs-lisp
(use-package lua-mode)
#+end_src

** Nix
#+begin_src emacs-lisp
(use-package nix-mode)
#+end_src

** PKGBUILD mode
#+begin_src emacs-lisp
(use-package pkgbuild-mode)
#+end_src

** Powershell
#+begin_src emacs-lisp
(use-package powershell-mode)
#+end_src

** Python
TODO:
- look at https://github.com/python-rope/ropemacs
- look at https://github.com/millejoh/emacs-ipython-notebook
- look at https://github.com/anachronic/importmagic.el
- dap-mode

*** Setup/LSP
#+begin_src emacs-lisp
(use-package lsp-pyright)

(noct-defun noct-lsp-pyright ()
  "Require lsp-pyright and run `lsp'."
  (require 'lsp-pyright)
  (setq yyoncho-flycheck-local-cache
        '((lsp . ((next-checkers
                   .
                   (python-flake8 python-pylint python-mypy))))))
  (lsp))

(use-package python
  :init
  (noct-handle-popup inferior-python-mode)
  :gfhook #'noct-lsp-pyright)
#+end_src

*** LPY
#+begin_src emacs-lisp
(use-package function-args)

(use-package lpy
  :disabled t
  :straight (lpy :host github :repo "abo-abo/lpy")
  :ghook 'python-mode-hook
  :config
  (general-def lpy-mode-map
    :definer 'lpy
    ;; basic Colemak navigation
    "n" #'lpy-down                      ; lose lispy-new-copy -> y
    "e" #'lpy-up                        ; lose lispy-eval -> l
    "i" #'lpy-right                     ; lose lpy-tab -> t
    ;; s and w don't exist
    "l" #'lispy-eval                    ; (freed by i)
    "L" #'lispy-eval-and-insert         ; (unbound)
    "y" #'lispy-new-copy                ; lose lpy-occur -> /
    "/" #'lpy-occur                     ; lose lpy-contents
    "w" #'lispy-narrow                  ; (unbound)
    ;; "W" #'lispy-widen
    ;; lispy-x
    "t" #'lpy-tab       ; lose lpy-teleport -> j
    "j" #'lpy-teleport  ; (freed by n)
    ;; d
    "o" #'lispy-different ; lose lpy-open (weird currently; requires active region)
    "k" #'lispy-flow      ; (freed by e)
    ;; swap m and v
    "v" #'lpy-mark
    "m" #'lpy-view
    ;; unbound
    "H" #'lispy-beginning-of-defun))
#+end_src

*** REPL
#+begin_src emacs-lisp
(general-with-package 'python
  (gsetq python-shell-interpreter "ipython"
         python-shell-interpreter-args "-i --simple-prompt --no-color-info")
  (when (eq system-type 'darwin)
    ;; breaks things on OSX
    (gsetq python-shell-completion-native-enable nil))
  ;; doesn't work
  ;; (gsetq python-shell-interpreter "ptpython"
  ;;        python-shell-interpreter-args "")

  (general-m python-mode-map
    "b" #'python-shell-send-buffer
    "d" #'python-shell-send-defun
    ;; "l" 'python-shell-send-line
    ;; "m" #'python-shell-switch-to-shell
    ";" #'python-shell-switch-to-shell)

  (general-def 'visual python-mode-map
    ;; eva[l]
    "l" #'python-shell-send-region)

  ;; automatically start shell for commands that use it
  (defun noct-python-shell-get-process (&rest _)
    "Return the python process, starting it if necessary."
    (or (python-shell-get-process)
        (progn (run-python)
               (python-shell-get-process))))

  (general-add-advice 'python-shell-get-process-or-error
                      :override #'noct-python-shell-get-process))
#+end_src

*** Pydoc
Better than default LSP equivalent.
#+begin_src emacs-lisp
(use-package pydoc
  :general
  (general-m python-mode-map
    "h" #'pydoc-at-point
    "/" #'pydoc))
#+end_src

*** TODO Pylookup
Currently requires running =make= for setup and is not on MELPA.
#+begin_src emacs-lisp
(use-package pylookup
  :straight (pylookup :host github :repo "tsgates/pylookup")
  :general
  (general-m python-mode-map
    "H" #'pylookup-lookup-at-pount
    "?" #'pylookup-lookup))
#+end_src

*** Docstrings
#+begin_src emacs-lisp
;; adds syntax highlighting for reST (and epydoc) docstrings and makes filling
;; work as expected.(for all multi-line strings)
(use-package python-docstring
  :ghook 'python-mode-hook
  :blackout t)

;; allows inserting reST docstring skeleton
(use-package sphinx-doc
  :ghook 'python-mode-hook
  :blackout t
  :config
  (general-m python-mode-map
    "s" #'sphinx-doc))
#+end_src

*** Formatting
TODO see python-isort
#+begin_src emacs-lisp
(use-package py-isort)
;; (general-add-hook 'before-save-hook 'py-isort-before-save)

;; using black with lsp instead now
;; (use-package py-yapf)
;; (use-package py-autopep8)

(general-with-package 'python
  ;;  https://gist.github.com/kracekumar/77d29c7410199fd2cda4
  (defun python-remove-unused-imports ()
    "Use Autoflake to remove unused function.
$ autoflake --remove-all-unused-imports -i unused_imports.py"
    (interactive)
    (when (eq major-mode 'python-mode)
      (shell-command (concat "autoflake --remove-all-unused-imports -i "
			                 (shell-quote-argument (buffer-file-name))))
      (revert-buffer t t t))
    nil)

  ;; isort alone is already too slow to add to before-save-hook
  ;; (benchmarks at almost a second)
  (defun noct-python-format-buffer ()
    (interactive)
    (python-remove-unused-imports)
    (py-isort-buffer)
    (lsp-format-buffer))

  (general-def 'normal python-mode-map
    "m=" #'noct-python-format-buffer))
#+end_src

*** TODO Debugger
*** TODO Pyvenv
TODO look at other packages...
https://github.com/robert-zaremba/auto-virtualenvwrapper.el
https://github.com/marcwebbie/auto-virtualenv
https://github.com/ssbb/pyenv-mode-auto
#+begin_src emacs-lisp
(use-package pyvenv
  :general
  (general-m python-mode-map
    "v" #'pyvenv-workon
    "V" #'pyvenv-deactivate))
#+end_src

*** Pytest
#+begin_src emacs-lisp
(use-package pytest
  :general (general-m python-mode-map "t" #'pytest-all)
  :config
  (gsetq pytest-cmd-flags "-x -s -vv"))
#+end_src

*** TODO Pycoverage
Needs extra setup (need to pip install cov2emacs that is in source directory).
#+begin_src emacs-lisp
(use-package pycoverage
  :disabled t
  :ghook 'python-mode-hook)
#+end_src

*** Requirements Mode
#+begin_src emacs-lisp
(use-package pip-requirements)
#+end_src

*** Poetry
#+begin_src emacs-lisp
(use-package poetry)
#+end_src

** R (ESS)
#+begin_src emacs-lisp
;; TODO having issues with this
;; (use-package ess)
#+end_src

** Scheme and Racket
*** Geiser
#+begin_src emacs-lisp
(use-package geiser
  :config
  (gsetq geiser-active-implementations '(chicken guile racket))

  (general-def 'insert geiser-repl-mode-map
    "¸" 'sp-backward-kill-word)

  (general-m (scheme-mode-map racket-mode-map)
    "b" #'geiser-eval-buffer
    "d" #'geiser-eval-definition
    "s" #'geiser-eval-last-sexp))
#+end_src

*** Racket
#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** Shell Mode (Bash, Zsh)
#+begin_src emacs-lisp
(defun noct-sh-mode-setup ()
  (when (eq sh-shell 'bash)
    ;; also use shellcheck even though using lsp
    (setq yyoncho-flycheck-local-cache
          '((lsp . ((next-checkers . (sh-shellcheck sh-bash))))))
    (lsp)))

(use-package sh-script
  :gfhook ('sh-mode-hook #'noct-sh-mode-setup)
  :config
  (with-eval-after-load 'flycheck
    (general-pushnew 'zsh flycheck-shellcheck-supported-shells)))

(use-package company-shell
  :after company
  :init
  (general-pushnew '(company-shell company-shell-env) company-backends))
#+end_src

** Shen
#+begin_src emacs-lisp
(use-package shen-mode)
#+end_src

** TXR
#+begin_src emacs-lisp
(use-package txr-mode
  ;; it requires user local file
  :disabled t
  :straight (txr-mode
             :host github
             :repo "piotrklibert/txr-mode"))
#+end_src

** Web, JavaScript, TypeScript
TODO
- https://github.com/skeeto/skewer-mode
- https://www.reddit.com/r/emacs/comments/9tr2vn/web_development_with_emacs_tips_and_tricks/
- https://github.com/NateEag/skewer-reload-stylesheets
- emmet

*** Eslint
#+begin_src emacs-lisp
;; make use .gitignore mode
;; https://www.reddit.com/r/emacs/comments/cem6h7/overwhelemed_js_jsjsx_rjsx_js2_js3_js2jsx_webmode/eu3zf70/
;; potentially useful
;; use eslint from node modules directory
;; (defun my/use-eslint-from-node-modules ()
;;   (let* ((root (locate-dominating-file
;;                 (or (buffer-file-name) default-directory)
;;                 "node_modules"))
;;          (eslint (and root
;;                       (expand-file-name "node_modules/eslint/bin/eslint.js"
;;                                         root))))
;;     (when (and eslint (file-executable-p eslint))
;;       (setq-local flycheck-javascript-eslint-executable eslint))))
;; (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
#+end_src

*** TypeScript
#+begin_src emacs-lisp
(use-package typescript-mode
  :gfhook #'lsp)
#+end_src
*** Go
#+begin_src emacs-lisp
(use-package go-mode
  :config
  (gsetq gofmt-command "goimports")
  (general-add-hook 'before-save-hook #'gofmt-before-save)
  :gfhook #'lsp)
#+end_src

*** Web
#+begin_src emacs-lisp
(use-package web-mode
  ;; web-mode gives better syntax highlighting than just typescript-mode (and
  ;; supports jsx and tsx)
  :mode ("\\.[tj]sx\\'" . web-mode)
  :gfhook
  #'lsp
  :config
  (gsetq
   ;; auto-close on >
   web-mode-auto-close-style 2
   ;; doesn't work well for ts:
   ;; - may want ={} OR =""
   ;; - incorrectly affects === inside {}
   web-mode-enable-auto-quoting nil))
#+end_src

* Miscellaneous
** Backup Each Save
Backup files on every save to prevent ever losing work.
#+begin_src emacs-lisp
(use-package backup-each-save
  :ghook ('after-save-hook #'backup-each-save)
  :config
  (gsetq backup-each-save-mirror-location "~/.emacs-backups"
         ;; backup TRAMP files
         backup-each-save-remote-files t))
#+end_src

** Benchmark Init
This is installed here and manually (and temporarily) enabled in my =init.el=.
#+begin_src emacs-lisp
(use-package benchmark-init)

(defun noct-end-benchmarking ()
  (interactive)
  (when noct-record-requires
    (advice-remove 'require #'noct-require-advice)
    (when (not noct-benchmark-init)
      (describe-variable 'noct-requires)))
  (when noct-benchmark-init
    (benchmark-init/deactivate)
    (benchmark-init/show-durations-tree)))

(general-t "b" #'noct-end-benchmarking)
#+end_src

** Profile Dotemacs
This is installed here and manually (and temporarily) enabled in my =init.el=.
#+begin_src emacs-lisp
(use-package profile-dotemacs)
#+end_src

** Memory Usage
I don't use this often, but it can be useful for profiling.
#+begin_src emacs-lisp
(use-package memory-usage)
#+end_src

** Free Keys
I really use this but keep it around just in case.
#+begin_src emacs-lisp
(use-package free-keys)
#+end_src

** Hardhat Mode
For making certain files read-only automatically.
#+begin_src emacs-lisp
(use-package hardhat
  ;; TODO nice idea needs some work; uses (require 'cl)
  :disabled t
  :init
  ;; https://github.com/rolandwalker/hardhat/issues/13
  (defvar ert--running-tests nil)

  (general-add-advice 'after-find-file :before #'global-hardhat-mode nil t)
  :blackout global-hardhat-mode)
#+end_src

* Applications/Other
** Dired
Performance notes:
- dired-k slows loading larger directories to a crawl (e.g. 0.08 -> 1 second; with all the icons -> 4 seconds; 450 items)
- all-the-icons-dired also slows loading larger directories (e.g. 0.08 -> 0.5 seconds; 450 items)

Dired-k isn't that useful, and while I really like all-the-icons-dired, I'd rather opening it be fast. I've disabled dired-k completely and for now have made all-the-icons-dired opt-in. I would try diff-hl's dired mode, but I current can't get diff-hl working at all because vc doesn't recognize my files as being under version control.

*** Setup
Notable packages not currently using:
- dired-du
- dired-xattr

TODO: Don't create a bunch of dired buffers (e.g. dired-single-up-directory).

TODO: Async copy/paste with rsync
#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :general ('normal "-" #'dired-jump)
  :gfhook
  ;; automatically refresh
  (nil #'auto-revert-mode)
  ;; by default only show filename
  ('dired-initial-position-hook #'dired-hide-details-mode)
  :config
  (gsetq dired-recursive-copies 'always
         dired-clean-confirm-killing-deleted-buffers nil)

  (if (eq system-type 'darwin)
      (when (executable-find "gls")
        (gsetq insert-directory-program "gls"
               dired-listing-switches "-lha --group-directories-first"))
    ;; use human readable sizes and put directories first
    (gsetq dired-listing-switches "-lha --group-directories-first")))
#+end_src

*** Basic Keybindings
#+begin_src emacs-lisp
(general-with 'dired
  (put 'dired-find-alternate-file 'disabled nil)
  (general-def 'normal dired-mode-map
    "q" #'noct-kill-this-buffer
    "gr" #'revert-buffer

    ;; navigation
    "h" #'dired-up-directory
    "n" #'dired-next-line
    "e" #'dired-previous-line
    "i" #'dired-find-alternate-file
    "f" #'find-file

    ;; marking
    "TAB" #'dired-mark
    "," #'dired-mark
    "\"" #'dired-mark-files-regexp
    "v" #'dired-toggle-marks
    "um" #'dired-unmark
    "uv" #'dired-unmark-all-marks

    ;; make directory
    "cd" #'dired-create-directory

    ;; renaming/changing
    "cc" #'dired-do-rename
    "cm" #'dired-do-chmod
    "ch" #'dired-do-chown
    "cg" #'dired-do-chgrp

    ;; TODO ranger u and c shell bindings (e.g. convert to pdf)

    "di" #'dired-do-delete
    "ud" #'trashed

    ;; encryption and decryption (epa-dired)
    "Ed" #'epa-dired-do-decrypt
    "Ev" #'epa-dired-do-verify
    "Es" #'epa-dired-do-sign
    "Ee" #'epa-dired-do-encrypt

    "o" #'dired-do-shell-command

    ;; toggle details
    "zd" #'dired-hide-details-mode)

  (general-def 'visual dired-mode-map
    "TAB" #'dired-mark
    "um" #'dired-unmark))
#+end_src

*** Quickmarks
#+begin_src emacs-lisp
(general-with 'dired
  ;; TODO can't use this with ranger
  ;; (defmacro noct-dired-alt-file (filename)
  ;;     "Create a named function to visit FILENAME.
  ;; The created function will act like `dired-find-alternate-file'."
  ;;     `(noct-defun ,(intern (concat "noct-dired-alt-find-" filename)) ()
  ;;        ,(concat "Call `find-alternate-file' on " filename ".")
  ;;        (interactive)
  ;;        (set-buffer-modified-p nil)
  ;;        (find-alternate-file ,filename)))

  (general-def 'normal dired-mode-map
    :prefix "g"
    "/" (noct-find-file "/")
    "b" (noct-find-file "/bin/")
    "e" (noct-find-file "/etc/")
    "h" (noct-find-file "~/")
    "m" (noct-find-file "/media/")
    "t" (noct-find-file "/tmp/")
    "u" (noct-find-file "/usr/")
    "v" (noct-find-file "/var/")
    "V" (noct-find-file "/Volumes/"))

  (general-def 'normal dired-mode-map
    :prefix "'"
    "a" (noct-find-file "~/ag-sys")
    "b" (noct-find-file "~/dotfiles/scripts/bin/")
    "B" (noct-find-file "~/src/blog/pir-hana/")
    "c" (noct-find-file "~/src/")
    "d" (noct-find-file "~/database/")
    "e" (noct-find-file user-emacs-directory)
    "E" (noct-find-file "~/ag-sys/else/")
    "f" (noct-find-file "~/dotfiles/")
    "l" (noct-find-file "~/database/library/")
    "m" (noct-find-file "~/move/")
    "p" (noct-find-file "~/ag-sys/else/scrawl/prose/pots/")
    "P" (noct-find-file "~/ag-sys/prog/")
    "s" (noct-find-file "~/school/")
    "S" (noct-find-file "~/move/Screenshots/")
    "w" (noct-find-file "~/wallpaper/")))
#+end_src

*** All the Icons Dired
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  ;; https://github.com/jtbm37/all-the-icons-dired/issues/41
  :general (noct-toggle-map "i" #'noct-toggle-all-the-icons-dired)
  :config
  (defvar noct-dired-icons nil)
  (defun noct-toggle-all-the-icons-dired ()
    (interactive)
    (cond (noct-dired-icons
           (general-remove-hook 'dired-mode-hook #'all-the-icons-dired-mode)
           (message "All the icons disabled for new dired buffers"))
          (t
           (general-add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
           (message "All the icons enabled for new dired buffers")))
    (setq noct-dired-icons (not noct-dired-icons))))
#+end_src

*** Dired Atool
#+begin_src emacs-lisp
(use-package dired-atool
  :general
  ('normal
   dired-mode-map
   "ux" #'dired-atool-do-unpack-with-subdirectory
   "uX" #'dired-atool-do-unpack
   "ca" #'dired-atool-do-pack)
  :config
  (cl-pushnew
   (list (rx "*dired-atool:" (0+ any)) #'display-buffer-no-window)
   display-buffer-alist))
#+end_src

*** TODO Diredfl
Find a theme that customizes these faces.
#+begin_src emacs-lisp
(use-package diredfl
  :disabled t
  :ghook 'dired-mode-hook)
#+end_src

*** Dired Git Info
#+begin_src emacs-lisp
(use-package dired-git-info
  :general ('normal dired-mode-map ")" #'dired-git-info-mode))
#+end_src

*** Dired K
#+begin_src emacs-lisp
(use-package dired-k
  :disabled t
  :ghook
  ('dired-initial-position-hook #'dired-k)
  ('dired-after-readin-hook #'dired-k-no-revert))
#+end_src

*** TODO Dired Toggle Sudo
Change current user to root.
#+begin_src emacs-lisp
(use-package dired-toggle-sudo
  :after dired
  ;; TODO broken?
  :general ('normal dired-mode-map "zs" #'dired-toggle-sudo))
#+end_src

*** FASD
Pretty much just using fasd in terminal at the moment, but maybe this package will be useful in the future.

*** File Opening (External)
https://github.com/Vifon/dired-rifle.el
- Only supports rifle
https://github.com/thomp/dired-launch
- Allows setting a default launcher (e.g. xdg-open, open, rifle, etc.; has sane default based on system)
- Allows using custom commands for specific extensions
https://github.com/garberw/openwith
- Can match full filename (unlike dired-launch I think)
- Disowns process so closing Emacs doesn't affect it
- Affects all file finding
https://github.com/thamer/runner/
- Weird (provides commands for configuring its runner-alist but there's no harm in that; redefines dired commands without using override advice)
https://github.com/DamienCassou/unify-opening
- Uses dired-guess-shell-command for opening with other packages (e.g. org and mu4e)
https://github.com/sfllaw/emacs-launch/blob/master/launch.el
- Uses system launcher
https://github.com/Fuco1/dired-hacks/blob/master/dired-open.el
- Uses nohup (optionally)
- Modifies ~~dired-find-file~ directly instead of adding a new opening command

For now instead of modifying ~dired-find-file~ for specific extensions, I'm just using my own command.
#+begin_src emacs-lisp
(general-with 'dired
  (defun noct-dired-open-external ()
    "Open selected path(s) with external opener."
    (interactive)
    (let ((opener (cond ((executable-find "rifle")
                         "rifle")
                        ((executable-find "open")
                         "open"))))
      (when opener
        (dolist (file (dired-get-marked-files))
          (start-process "noct-dired-open" nil
                         opener (file-truename file))))))

  (general-def 'normal dired-mode-map "I" #'noct-dired-open-external))
#+end_src
*** Wdired
#+begin_src emacs-lisp
(use-package wdired
  :after dired
  :general ('normal dired-mode-map "w" #'wdired-change-to-wdired-mode)
  :config
  (gsetq wdired-create-parent-directories t
         wdired-allow-to-change-permissions t)

  (general-def 'normal wdired-mode-map
    "x" #'wdired-toggle-bit
    "RET" #'wdired-finish-edit))
#+end_src

*** Ranger.el
This package needs some work (and refactoring) and isn't actively updated, but it has a lot of good functionality from ranger that other packages don't.

It also has overlapping functionality with a lot of packages. For example, I'm using ~ranger-show-history~ instead of ivy-dired-history or dired-recent.
#+begin_src emacs-lisp
(use-package ranger
  :init
  (general-add-advice 'ranger-define-additional-maps :override #'ignore)
  :general
  ('normal "-" #'deer)
  (general-s "r" #'deer)
  :config
  ;; default
  ;; (gsetq ranger-show-dotfiles t)

  (gsetq ranger-deer-show-details nil)

  (setq ranger-mode-map (make-sparse-keymap))

  (general-def 'normal ranger-mode-map
    "q" #'ranger-close
    "Q" #'ranger-disable
    "gr" #'ranger-refresh

    ;; navigation
    "gg" #'ranger-goto-top
    "G" #'ranger-goto-bottom
    "h" #'ranger-up-directory
    "n" #'ranger-next-file
    "e" #'ranger-prev-file
    "i" #'ranger-find-file
    "RET" #'ranger-find-file
    "<next>" #'ranger-page-down
    "<prior>" #'ranger-page-up
    "F" #'ranger-travel

    ;; sorting ([c]hange [o]rder)
    "co" #'ranger-sort-criteria

    ;; marking
    "TAB" #'ranger-toggle-mark
    "," #'ranger-toggle-mark

    ;; copying, deleting, and pasting
    "y" nil
    "yy" #'ranger-copy
    "ya" #'ranger-copy-append
    "yp" #'ranger-copy-absolute-file-paths
    "yd" #'ranger-copy-current-dir-path
    "yn" #'ranger-copy-filename

    "d" nil
    "dd" #'ranger-cut
    "da" #'ranger-cut-append

    "p" nil
    "pp" #'ranger-paste
    "po" #'ranger-paste-over
    "p/" #'ranger-show-copy-contents
    "pl" #'ranger-paste-as-symlink
    "pL" #'ranger-paste-as-relative-symlink

    "du" #'ranger-show-size

    ;; history
    "l" #'ranger-prev-history
    "L" #'ranger-next-history
    "zz" #'ranger-show-history

    ;; tabs
    "mm" #'ranger-new-tab
    "mq" #'ranger-close-tab
    "ma" (general-l (ranger-goto-tab 1))
    "mr" (general-l (ranger-goto-tab 2))
    "ms" (general-l (ranger-goto-tab 3))
    "mt" (general-l (ranger-goto-tab 4))
    "md" (general-l (ranger-goto-tab 5))
    "mh" (general-l (ranger-goto-tab 6))
    "mn" (general-l (ranger-goto-tab 7))
    "me" (general-l (ranger-goto-tab 8))
    "mi" (general-l (ranger-goto-tab 9))
    "mo" (general-l (ranger-goto-tab 0))
    "uq" #'ranger-restore-tab

    ;; toggles/settings
    "zm" #'ranger-minimal-toggle
    "zh" #'ranger-toggle-dotfiles
    ;; "zi" #'ranger-toggle-literal
    ;; "zf" #'ranger-toggle-scale-images
    "zo" #'ranger-sort-criteria
    "zp" #'ranger-toggle-details
    "zd" #'ranger-toggle-dir-first
    "zh" #'ranger-toggle-dotfiles)

  (general-def 'visual ranger-mode-map
    "TAB" #'ranger-toggle-mark
    "," #'ranger-toggle-mark)

  ;; move down after toggling mark too
  (general-add-advice 'ranger-toggle-mark :after
                      (lambda () (call-interactively #'ranger-next-file)))

  ;; stfu
  (general-add-advice '(ranger-window-check ranger-revert)
                      :around #'noct-no-message)

  (ranger-override-dired-mode))
#+end_src

*** Dired Hacks
**** Dired AVFS
Allows browsing archives.
#+begin_src emacs-lisp
(use-package dired-avfs
  :when (executable-find "avfs")
  :after 'dired
  :demand t)
#+end_src

**** Dired Collapse Mode
Show entire path for a directory (or chain of directories) that only contains a single file/directory (like on GitHub).
#+begin_src emacs-lisp
(use-package dired-collapse
  :general
  ('normal
   dired-mode-map
   "zc" #'dired-collapse-mode))
#+end_src

**** TODO Dired Filter
**** Dired Narrow
#+begin_src emacs-lisp
(use-package dired-narrow
  :general ('normal dired-mode-map "cf" #'dired-narrow-completion-styles)
  :config
  (general-def dired-narrow-map "ESC" #'keyboard-escape-quit)

  ;; https://github.com/Fuco1/dired-hacks/pull/169
  (defun dired-narrow--completion-styles-filter (filter)
    "Return whether `completion-styles' FILTER matches the current dired file."
    (completion-all-completions filter (list (dired-utils-get-filename 'no-dir))
                                nil nil))

  (defun dired-narrow-completion-styles ()
    "Narrow a dired buffer to the files matching a `completion-styles' query."
    (interactive)
    (dired-narrow--internal #'dired-narrow--completion-styles-filter)))
#+end_src

*** Image Handling
Image display (and resizing) is too slow to be worth it. Assuming that ever changes, do the following:
- Bind =cb= to change wallpaper (see rc.conf; same for below)
- Bind =cw= to change wallpaper and theme with pywal
- Bind =cr=, =cR=, and =cm= to rotate and mirror images
- Bind =cu=  and =cU= to create an upscaled version
- Bind =cj= to tesseract
- Bind =ui= and =uI= to imgur upload
- Bind tmsu keys

*** Trashed
#+begin_src emacs-lisp
;; bound in dired
(use-package trashed
  :config
  (evil-collection-init 'trashed)

  (general-def 'normal trashed-mode-map
    ;; "RET" #'trashed-view-file
    ;; "RET" #'trashed-display-file
    ;; "RET" #'trashed-find-file
    "n" #'trashed-next-line
    "e" #'trashed-previous-line
    "TAB" #'trashed-mark
    "," #'trashed-mark
    "u" #'trashed-do-restore)

  (noct-handle-popup "Trash Can"))
#+end_src

*** Shell Commands
#+begin_src emacs-lisp
(general-with 'dired
  (defun noct-dired-async-run (command)
    "Run `dired-do-async-shell-command' with COMMAND and the marked files."
    (dired-do-async-shell-command command nil (dired-get-marked-files)))

  (defun noct-dired-unoconv-to-txt ()
    "Convert selected file(s) to txt with unoconv."
    (interactive)
    (noct-dired-async-run "unoconv -f txt"))

  (defun noct-dired-unoconv-to-pdf ()
    "Convert selected file(s) to pdf with unoconv."
    (interactive)
    (noct-dired-async-run "unoconv -f pdf"))

  (defun noct-dired-pandoc (extension)
    "Convert selected file(s) to end in EXTENSION."
    (interactive "sConvert to extension: ")
    (dolist (file (dired-get-marked-files))
      (let ((basename (noct-basename file)))
        (dired-do-async-shell-command
         (format "pandoc -o %s.%s" basename extension)
         nil
         (list file)))))

  (general-def 'normal dired-mode-map
    "ct" #'noct-dired-unoconv-to-txt
    "cP" #'noct-dired-unoconv-to-pdf
    "cp" #'noct-dired-pandoc)

  (defun noct-dired-udiskie-umount ()
    "Unmount selected drive(s) with udiskie."
    (interactive)
    (noct-dired-async-run "udiskie-umount"))

  (defun noct-udiskie-umount-all ()
    "Unmount all drives with udiskie."
    (interactive)
    (call-process-shell-command "udiskie-umount --all &"))

  ;; TODO don't have a tray anymore; does this work with external cd reader?
  (defun noct-eject-tray ()
    "Eject tray."
    (interactive)
    (let ((default-directory "/sudo::")
          ;; don't try to get root password from auth sources
          auth-sources)
      (shell-command "eject /dev/sr0")))

  (general-def 'normal dired-mode-map
    "un" #'noct-dired-udiskie-umount
    "uN" #'noct-udiskie-umount-all
    "ue" #'noct-eject-tray)

  (defun noct-dired-sanitize ()
    "Sanitize permission of selected path(s)."
    (interactive)
    (noct-dired-async-run (format "sudo chmod -R u=rwX,go=rX"))
    (noct-dired-async-run (format "sudo chown -R \"%s\" " (getenv "USER"))))

  (general-def 'normal dired-mode-map
    "cs" #'noct-dired-sanitize)

  ;; TODO untested
  (defun noct-dired-beet-import ()
    "Call beet import on the selected path(s)."
    (interactive)
    (dired-do-shell-command "beet import"))

  (general-def 'normal dired-mode-map
    "bi" #'noct-dired-beet-import))
#+end_src

** Eshell
The nice thing about eshell is Emacs integration:
- ability to use ivy/helm/selectrum for completion and search
- evil for navigation/copying/etc.
- ability to use snippets
- intercept commands like man and ~grep <text> <file>~
- TRAMP integration (including docker container integration)
- ability to execute elisp

That said, I don't do many complicated things in terminal, so I mostly use a dedicated terminal window for one-off commands and vterm for project related commands (e.g. ~yarn~ and ~make~). Though for project commands, I try to use keybindings where possible (e.g. ~makefile-executor~).

#+begin_src emacs-lisp
(use-package eshell
  :general
  (general-s "e" #'eshell))

(general-with 'esh-mode
  ;; performance improvement
  ;; https://old.reddit.com/r/emacs/comments/nv7x0h/eshells_speed_on_emacs_28_with_nativecompilation/h13brxk/
  (gsetq eshell-output-filter-functions
         (remove 'eshell-postoutput-scroll-to-bottom
                 eshell-output-filter-functions)))

(use-package stutter
  :straight (stutter :host github :repo "Stebalien/stutter.el")
  :ghook 'eshell-mode-hook)

(use-package eshell-syntax-highlighting
  :ghook ('eshell-mode-hook #'eshell-syntax-highlighting-enable))
#+end_src

** Shell
Shell has some of the advantages of eshell like ~completing-read~ integration in ~term-line-mode~, but it supports zsh and other shells.  Plugins like autosuggestions won't work in line mode (and at least with this basic configuration autosuggestions don't seem to work in char-mode either for fish or zsh). Obviously, it can't execute emacs lisp. It can run it on a remote host, but the shell has to be available there.

#+begin_src emacs-lisp
;; `shell-file-name' is used for `execute-shell-command' (leave as default)
(gsetq explicit-shell-file-name "zsh")

(use-package native-complete
  :disabled t
  :ghook
  ('shell-mode-hook
   (noct-defun noct-shell-setup ()
     (general-pushnew 'native-complete-at-point completion-at-point-functions)
     (when (boundp 'company-backends)
       (general-pushnew 'company-native-complete company-backends))
     (gsetq comint-prompt-regexp "^[^#$%»>\\n]*[#$%»>] *"))))
#+end_src

** Vterm
Vterm is an actual terminal emulator and my preferred method for executing shell command in Emacs. The main downsides it has for me compared to eshell and shell currently:

- There are some things that need to be polished (e.g. it changes cursor shape which is confusing when using different cursors for evil: #342)
- Every character is sent to the terminal immediately, so evil line-editing is not yet possible (minor since Emacs line-editing keybindings are more efficient, and the current behavior works with autosuggestions; sending the line only on enter would break autosuggestions)
- It does not currently integrate with completing-read frontends for completion

It might be cool to eventually replace a dedicated terminal emulator with vterm. Scrollback search, navigation, and copying are definitely better in Emacs than in any terminal or multiplexer.

#+begin_src emacs-lisp
(defun noct-vterm-setup ()
  "Setup for vterm."
  (gsetq-local term-prompt-regexp "^[^#$%»>\\n]*[#$%»>] *")
  (toggle-truncate-lines 1))

(use-package vterm
  ;; :general
  ;; ('normal 'override "T" #'vterm)
  :init
  ;; not defined, vterm checks boundp for some reason
  (defvar vterm-install t)
  :gfhook
  (nil (noct-disable-global-mode whitespace-mode))
  (nil #'noct-vterm-setup)
  :config
  (gsetq vterm-shell "zsh"
         ;; increase scrollback
         vterm-max-scrollback 10000)

  (general-def vterm-mode-map
    "<prior>" nil
    "<next>" nil)

  (general-m vterm-mode-map
    "e" (list #'vterm-previous-prompt :repeat t)
    "n" (list #'vterm-next-prompt :repeat t))

  (general-def 'normal vterm-mode-map
    "<escape>"
    (noct-defun noct-vterm-send-escape ()
      "Send <escape> key."
      (interactive)
      (vterm-send-key "<escape>"))))

(use-package vterm-toggle
  :straight (vterm-toggle
             :host github
             :repo "jixiuf/vterm-toggle")
  :general
  ('normal 'override "T" #'vterm-toggle-cd)
  :init
  (noct-handle-popup vterm-mode)
  :config
  (gsetq vterm-toggle-fullscreen-p nil
         vterm-toggle-evil-state-when-enter nil
         vterm-toggle-evil-state-when-leave nil
         ;; don't create a new buffer if the prompt is not available
         vterm-toggle-cd-auto-create-buffer nil)

  (general-def 'visual vterm-mode-map
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line)

  (general-def 'insert vterm-mode-map
    "<home>" #'vterm--self-insert
    "<end>" #'vterm--self-insert
    "C-r" #'vterm--self-insert
    "C-c" #'vterm--self-insert
    "C-u" #'vterm--self-insert
    "C-w" #'vterm--self-insert
    "¸" #'vterm--self-insert)

  ;; (cl-defun noct-tmux-select-or-create (number &optional (session "emacs"))
  ;;     "Select the tmux window with NUMBER, cerating it if it does not exist.
  ;; If SESSION is specified, act on that session instead of \"emacs\"."
  ;;     (shell-command
  ;;      (format "tmux select-window -t %1$s:%2$s || tmux new-window -t %1$s:%2$s"
  ;;              session number)))

  (defun noct-vterm-select-or-create (&optional number)
    "Switch to a vterm buffer, creating it if it does not exist.
  NUMBER specifies which vterm buffer to switch to. If nil, switch to the
    \"vterm\" buffer."
    (let ((vterm-buffer-name (if number
                                 (format "*vterm<%s>*" number)
                               "vterm")))
      (vterm)))

  (general-def 'normal vterm-mode-map
    "mm" #'vterm
    "mc" #'vterm-toggle-insert-cd
    "ma" #'vterm
    "mr" (general-l (noct-vterm-select-or-create 2))
    "ms" (general-l (noct-vterm-select-or-create 3))
    "mt" (general-l (noct-vterm-select-or-create 4))
    "md" (general-l (noct-vterm-select-or-create 5))
    "mh" (general-l (noct-vterm-select-or-create 6))
    "mn" (general-l (noct-vterm-select-or-create 7))
    "me" (general-l (noct-vterm-select-or-create 8))
    "mi" (general-l (noct-vterm-select-or-create 9))
    "mo" (general-l (noct-vterm-select-or-create 10))))
#+end_src

** Global Hotkeys and Shell Integration
*** Helpers
#+begin_src emacs-lisp
(noct-handle-popup (rx "*Shell Command Output*"))

(defvar noct-global-keybinding nil
  "Whether the current command was spawned by a global system keybinding.
This is used to prevent deleting frames when a command is not called from a
global keybinding.")

(defmacro noct-with-global-keybinding (&rest body)
  "Run BODY with `noct-global-keybinding' non-nil."
  (declare (indent 0) (debug t))
  `(let ((noct-global-keybinding t))
     ,@body))

(defmacro noct-with-reuse-window (&rest body)
  "Run BODY reusing the current window to open new buffers. "
  (declare (indent 0) (debug t))
  `(let ((display-buffer-alist '((".*" . (display-buffer-use-some-window)))))
     ,@body))

(defmacro noct-with-sudo-command (&rest body)
  "Run BODY with the default-directory' as /sudo::."
  (declare (indent 0) (debug t))
  `(progn
     (require 'tramp)
     (let ((default-directory "/sudo::")
           ;; don't try to get sudo password from auth-sources
           auth-sources
           (tramp-remote-path (append tramp-remote-path
                                      (s-split ":" (getenv "PATH")))))
       ,@body)))

(defmacro noct-with-global-completing-read (&rest body)
  "Run BODY with selectrum taking up the full window height.
Open any new windows in same buffer"
  (declare (indent 0) (debug t))
  `(let ((selectrum-num-candidates-displayed 1000)
         (selectrum-display-action '(display-buffer-use-some-window))
         (display-buffer-alist '((".*" . (display-buffer-use-some-window)))))
     ,@body))

(defun noct-global-completing-read-dir (prompt dirs)
  "Run `completing-read' with PROMPT to select a directory from DIRS.
This will add the file completion category to the directories, display selectrum
in an existing window, and open any new windows in the same buffer."
  (noct-with-global-completing-read
    (completing-read prompt
                     (lambda
                       (str pred action)
                       (if
                           (eq action 'metadata)
                           '(metadata
                             (category . file))
                         (complete-with-action action dirs str pred))))))

(defun noct-completing-read-media-dir (prompt)
  "Use `completing-read' to select a directory under /media."
  (let ((dirs
         (f-directories "/media")))
    (noct-global-completing-read-dir prompt dirs)))

(defun noct-run-with-vterm (command)
  "Run COMMAND in a vterm buffer.
Open the vterm buffer reusing a window."
  (noct-with-reuse-window
    (let ((vterm-buffer-name (format "*vterm %s*" (car (split-string command)))))
      (vterm)
      (vterm-insert command)
      (with-current-buffer vterm-buffer-name
        (evil-insert 1))
      (vterm-send-return))))

;; TODO do in empty buffer?
;; TODO allow `completing-read-multiple'
(defun noct-file-filter (&optional file)
  "Use `completing-read' to select a line in the current buffer.
If FILE is specified, first visit FILE. After selection, replace the buffer
contents with the selected line, kill the buffer, and close the frame. This s
meant to be used from the command line (specifically with my esel script)."
  (interactive)
  (when file
    (find-file file))
  (unwind-protect
      ;; TODO show only the selectrum minibuffer
      (let* ((selectrum-num-candidates-displayed 1000)
             (selectrum-display-action '(display-buffer-use-some-window))
             ;; (selectrum-should-sort-p)
             (selection (completing-read
                         "> "
                         (thread-first (buffer-substring-no-properties
                                        (point-min)
                                        (point-max))
                           (split-string (rx (1+ "\n")) t)
                           ;; TODO optional
                           ;; (delete-dups)
                           ))))
        (when selection
          (delete-region (point-min) (point-max))
          (insert selection)
          (save-buffer)))
    (kill-buffer)
    (save-buffers-kill-terminal)
    ;; makes flicker much better
    ;; (switch-to-buffer "*blank*")
    ;; (call-process-shell-command "xdotool getactivewindow windowunmap")
    ))
#+end_src

*** Shell Command Menu
;; TODO differentiate when called globally (don't delete frames)
;TODO audio should close automatically update sxhkrd
; fix delete frame

**** Audio
#+begin_src emacs-lisp
(defun noct-hdmi-audio ()
  "Switch to hdmi audio.
Delete the frame if `noct-global-keybinding'."
  (interactive)
  (start-process "hdmi-audio" nil "audio_switch" "hdmi")
  (when noct-global-keybinding
    (delete-frame)))

(defun noct-analog-audio ()
  "Switch to analog audio.
Delete the frame if `noct-global-keybinding'."
  (interactive)
  (start-process "hdmi-audio" nil "audio_switch" "analog")
  (when noct-global-keybinding
    (delete-frame)))
#+end_src

**** Backup
#+begin_src emacs-lisp
(defun noct--local-borg-backup (command args)
  "Run local borg backup COMMAND with ARGS."
  ;; uses `let*'
  (when-let ((dirs (f-directories "/media"))
             (backup-dir
              ;; (noct-completing-read-media-dir "Backup to: ")
              (frog-menu-read "Backup to: " dirs)))
    (noct-run-with-vterm (concat
                          "borg_backup "
                          command
                          " "
                          (string-join args " ")
                          " "
                          (shell-quote-argument backup-dir)))))

(defun noct-borg-small-local-backup (&optional args)
  "Run small local borg backup with ARGS."
  (interactive (list (transient-args 'noct--backup-menu)))
  (noct--local-borg-backup "borg_small" args))

(defun noct-borgbase-small-backup (&optional args)
  "Run small local borg backup with ARGS."
  (interactive (list (transient-args 'noct--backup-menu)))
  (noct-run-with-vterm (concat
                        "borg_backup borgbase_small "
                        (string-join args " "))))

(general-with 'transient
  (transient-define-prefix noct--backup-menu ()
    "Create a backup with borg."
    ["Arguments"
     ("-n" "Don't check integrity" "-n")]
    ["Backup"
     ("s" "Small local" noct-borg-small-local-backup)
     ("r" "Small remote" noct-borgbase-small-backup)
     ;; ("b" "Big local")
     ])

  (defun noct-backup-menu ()
    "Reusing current window, call `noct--backup-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--backup-menu))))
#+end_src

**** Filesystem and Mounting/Unmounting
#+begin_src emacs-lisp
(defun noct--lsblk ()
  "Run lsblk and display the output."
  (interactive)
  (noct-with-reuse-window
    (shell-command "lsblk")))

(defun noct-unmount-media ()
  "Unmount something under /media with udiskie."
  (interactive)
  (let ((unmount-dir (noct-completing-read-media-dir "Unmount: ")))
    (shell-command (concat "udiskie-umount "
                           (shell-quote-argument unmount-dir)))))

(defun noct-lvm-umount-datab ()
  "Unmount database."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "borg_backup umountdatab")))

(defun noct-lvm-mount-datab ()
  "Mount database."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "borg_backup mountdatab")))
#+end_src

**** Miscellaneous Aliases
#+begin_src emacs-lisp
(defun noct-restow ()
  "Restow dotfiles."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "restow")))
#+end_src

**** Systemd
#+begin_src emacs-lisp
(defun noct--systemd-read (prompt args &optional state)
  "Run `completing-read' on a list of systemd services.
Use PROMPT and add ARGS to systemctl command. Only show services with STATE if
it is specified."
  ;; uses `let*'
  (noct-with-global-completing-read
    (when-let ((base-command
                (concat
                 "systemctl list-units --no-pager --no-legend "
                 "--all --type=service "
                 (string-join args " " )))
               (command
                (concat (if state
                            (concat base-command " --state=" state)
                          base-command)
                        " | grep -v not-found"))
               (services
                (mapcar
                 (lambda (str) (car (split-string str)))
                 (split-string (shell-command-to-string command)
                               (rx (1+ "\n"))
                               t))))
      (completing-read prompt services))))

(defun noct--systemd-command (prompt command
                                     &optional args sudo delete-frame state)
  "Run a systemd command, selecting the service with `completing-read'.
PROMPT should be the prompt when selecting the service. COMMAND should be the
command to append the selected service. ARGS can contain arguments to pass to
the list-units command. If sudo is non-nil, run the command with sudo. If
DELETE-FRAME is non-nil, delete the frame on SUCCESS. If STATE is non-nil, only
allow selecting from units with that state."
  (let ((service (noct--systemd-read prompt args state))
        (default-directory (if sudo "/sudo::" default-directory))
        auth-sources)
    (noct-with-reuse-window
      (when (and (= (shell-command (concat command service)) 0)
                 delete-frame
                 noct-global-keybinding)
        (delete-frame)))))

(defun noct-systemctl-service-status (&optional args)
  "Show the status of a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Show service status: "
                         "systemctl --no-pager status "
                         args))

(defun noct-journalctl-logs (&optional args)
  "Show the journalctl logs of a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Show journactl logs: "
                         "journalctl --no-pager -u "
                         args))

(defun noct-systemctl-start-service (&optional args)
  "Start a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Start service: " "systemctl start " args t t))

(defun noct-systemctl-restart-service (&optional args)
  "Restart a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Retart service: " "systemctl restart " args t t))

(defun noct-systemctl-stop-service (&optional args)
  "Stop a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Stop service: " "systemctl stop " args t t "active"))

(defun noct-systemctl-enable-service (&optional args)
  "Enable and start a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Enable and start service: " "systemctl enable --now"
                         args t t))

(defun noct-systemctl-disable-service (&optional args)
  "Disable and stop a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Disable and stop service: " "systemctl disable --now"
                         args t t "active"))

(general-with 'transient
  (transient-define-prefix noct--systemctl-menu ()
    "Run a systemctl command using `completing-read' to select the service."
    ["Arguments"
     ("-u" "Act on user services" "--user")]
    ["Systemctl"
     ("s" "Service status" noct-systemctl-service-status)
     ("j" "Journalctl logs" noct-journalctl-logs)
     ("t" "Start service"
      (lambda ()
        (noct-with-global-keybinding
          (noct-systemctl-start-service))))
     ("p" "Stop service"
      (lambda ()
        (noct-with-global-keybinding
          (noct-systemctl-stop-service))))
     ("r" "Restart service"
      (lambda ()
        (noct-global-keybinding-lambda
          (noct-systemctl-restart-service))))
     ("e" "Enable/start service"
      (lambda ()
        (noct-with-global-keybinding
          (noct-systemctl-enable-service)))) 
     ("d" "Disable/stop service"
      (lambda ()
        (noct-with-global-keybinding
          (noct-systemctl-disable-service))))])

  (defun noct-systemctl-menu ()
    "Reusing current window, call `noct--systemctl-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--systemctl-menu))))
#+end_src

**** Vpn
#+begin_src emacs-lisp
;; memoized
(defun noct--wireguard-names ()
  "Return a list of available wireguard configurations."
  (let ((default-directory "/sudo::/etc/wireguard")
        auth-sources)
    (mapcar (lambda (path)
              (file-name-sans-extension (f-filename path)))
            (f-files "./"))))

(defun noct--wireguard-command (prompt command)
  "Run a wireguard command.
Select a wireguard configuration using PROMPT and then run COMMAND on it."
  (interactive)
  (noct-with-global-completing-read
    (noct-with-sudo-command
      (let* ((wireguard-names (noct--wireguard-names))
             (wireguard-name (completing-read prompt wireguard-names)))
        (when (and (= (shell-command (concat command " " wireguard-name))
                      0)
                   noct-global-keybinding)
          (delete-frame))))))

(defun noct-vpnup ()
  "Start wireguard vpn."
  (interactive)
  (noct--wireguard-command "Start vpn: " "vpnup"))

(defun noct-vpndown ()
  "Stop wireguard vpn."
  (interactive)
  (noct--wireguard-command "Stop vpn: " "vpndown"))

(defun noct-revpn ()
  "Restart wireguard vpn."
  (interactive)
  (noct--wireguard-command "Restart vpn: " "revpn"))

(general-with 'transient
  (require 'memoize)
  (memoize 'noct--wireguard-names)

  (noct-with-global-keybinding
    (transient-define-prefix noct--vpn-menu ()
      "Start/stop wireguard vpn."
      ["Wireguard vpn"
       ("u" "Vpn up" noct-vpnup)
       ("d" "Vpn down" noct-vpndown)
       ("r" "Restart vpn" noct-revpn)]))

  (defun noct-vpn-menu ()
    "Reusing current window, call `noct--vpn-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--vpn-menu))))
#+end_src

**** X11
#+begin_src emacs-lisp
(defun noct-xprop ()
  "Run xprop in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (shell-command "xprop")))

(defun noct-xwininfo ()
  "Run xwininfo in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (shell-command "xwininfo")))

(defun noct-xev ()
  "Run xev in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "xev")))
#+end_src

**** Menu
#+begin_src emacs-lisp
(general-with 'transient
  (transient-define-prefix noct--shell-menu ()
    "Shell command menu."
    [:description "Shell commands"]
    ["Audio"
     ("h" "Switch to hdmi audio"
      (lambda ()
        (interactive)
        (noct-with-global-keybinding
          (noct-hdmi-audio))))
     ("a" "Switch to analog audio"
      (lambda ()
        (interactive)
        (noct-with-global-keybinding
          (noct-analog-audio))))]
    ["Backup"
     ("b" "Backup" noct-backup-menu)]
    ["Filesystem"
     ("l" "Lsblk" noct--lsblk)
     ("u" "Udiskie unmount" noct-unmount-media)
     ("d" "Lvm mount database" noct-lvm-mount-datab)
     ("D" "Lvm unmount database" noct-lvm-umount-datab)]
    ["Miscellaneous"
     ("r" "Restow" noct-restow)]
    ["Package Management"
     ("i" "AUR installed packages" aurel-installed-packages)
     ("/" "AUR package search" aurel-package-search)]
    ["Systemctl"
     ("s" "Systemctl commands" noct-systemctl-menu)]
    ["Vpn"
     ("v" "Vpn commands" noct-vpn-menu)]
    ["X11"
     ("w" "Xwininfo" noct-xwininfo)
     ("x" "Xprop" noct-xprop)
     ("X" "Xev" noct-xev)]))

(defun noct-shell-menu ()
  "Reusing current window, call `noct--shell-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
  (require 'transient)
  (noct-with-reuse-window (noct--shell-menu)))
#+end_src

* Fun/Games
** Fireplace
#+begin_src emacs-lisp
(use-package fireplace)
#+end_src

** Screenshots
[[https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/][Emacs 27 supports svg screenshots of itself.]]
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))

(general-s "S" #'screenshot-svg)
#+end_src

* Removed
- Various org presentation packages (only used once; haven't decided on one)
- hippie expand (just using company now)
- workgoups2, elscreen, etc. (switched to framegroups)
- eval in repl (never used)
- quickrun (never used)
- helm-swoop (switched to swiper)
- ediff (switched to vdiff)
- nlinum (switched to builtin line numbers)
- unfill (never used)
- weather (never used)
- anyblock (switched to targets/things)
- company quickhelp (company-box replaces it; doesn't work well with company childframe)
- vertigo (switched to using counts and relative line numbers)
- golden ratio (switched to zoom)
- multiple cursors and evil-mc (never found a great use case for)
- key chord (old usage was not ideal or saving much effort; input lag causes accidental actions)
- evil-visual-star (I don't use \* that often and a dedicated text object would be preferable to overriding \* in visual state)
- evil-goggles (really cool package but from a practical standpoint I don't need it)
- evil-anzu (using mainly swiper now which supports this functionality)
- shackle (easy enough to do what I want with =display-buffer-alist= directly)
- circe, ERC, and jabber (for now; haven't used IRC or jabber much in a while)
- shell-pop (not really using Emacs terminals at all; may add back with libvterm keybinding)
- jammer and schrute-mode (good idea but found too intrusive/annoying)
- adjust-parens (I updated lispy to have this functionality)
- cleverparens (using lispyville)
- slime (using sly)
- elisp-slime-nav-mode (using xref and helpful)
- historian and company-statistics (replaced with prescient)
- counsel-projectile (just projectile is good enough for my use cases)
